
<!doctype html>
<html>
<head>
  <meta charset='utf-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
  <meta name='mobile-web-app-capable' content='yes'>
  <meta name='apple-mobile-web-app-capable' content='yes'>
  <link rel='icon' type='image/png' sizes='32x32' href='favicon-32x32.png'>
  <link rel='icon' type='image/png' sizes='96x96' href='favicon-96x96.png'>
  <title>Ring Ring</title>
  <style>
    body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #f0f0f0; }
    canvas { display: block; }
    #vrButton {
      padding: 20px 40px;
      font-size: 24px;
      background-color: #0078d7;
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: background-color 0.3s ease;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    #vrButton:hover { background-color: #005bb5; }
  </style>
</head>
<body>
  <button id="vrButton">Enter VR</button>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
        "three/examples/jsm/webxr/VRButton.js": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/webxr/VRButton.js",
        "three/examples/jsm/webxr/XRControllerModelFactory.js": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/webxr/XRControllerModelFactory.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { VRButton } from 'three/examples/jsm/webxr/VRButton.js';

    let camera, scene, renderer, controller1, controller2, sphere1, sphere2, ring, textMesh, timerMesh;
let grabbed = false, grabbingController = null, grabOffset = new THREE.Vector3(), grabRotationOffset = new THREE.Quaternion();
let startTime = null, elapsedTime = 0, font, timerFont, wire, wirePoints = [], wireMaterial, victorySound, contactSound;
const ringStartPosition = new THREE.Vector3(0, 1.35, -0.75);
let currentLevel = 3; // Track current level
let levelTimes = []; // Array to store completion times for each level

// Sound effects and flashing state
let applauseSound, longApplauseSound, longHornsSound;
let isFlashing = false;

// Celebration particles
let celebrationParticles = []; // Array to store multiple particle systems

init();
animate();

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);

  const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
  light.position.set(0.5, 1, 0.25);
  scene.add(light);

  const ringGeometry = new THREE.TorusGeometry(0.075, 0.00625, 16, 100);
  const ringMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 1.0, metalness: 1.0, roughness: 0.0 });
  ring = new THREE.Mesh(ringGeometry, ringMaterial);
  ring.position.copy(ringStartPosition);
  ring.rotation.y = Math.PI / 2;
  scene.add(ring);

  const loader = new THREE.FontLoader();
  loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (loadedFont) {
    font = loadedFont;
    const textGeometry = new THREE.TextGeometry(`LEVEL ${currentLevel}`, { font: font, size: 0.02, height: 0.005 });
    const textMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
    textMesh = new THREE.Mesh(textGeometry, textMaterial);
    textGeometry.computeBoundingBox();
    const centerOffset = -0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x);
    textMesh.position.set(centerOffset, 2.0, -0.75);
    scene.add(textMesh);

    // Load a monospaced font for the timer
    const timerFontURL = 'https://threejs.org/examples/fonts/droid/droid_sans_mono_regular.typeface.json';
    loader.load(timerFontURL, function (loadedTimerFont) {
      timerFont = loadedTimerFont;
      // Use the loaded font for the timer with shorter format
      const timerGeometry = new THREE.TextGeometry('00:000', { font: timerFont, size: 0.02, height: 0.005 });
      const timerMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
      timerMesh = new THREE.Mesh(timerGeometry, timerMaterial);
      timerGeometry.computeBoundingBox();
      const timerCenterOffset = -0.5 * (timerGeometry.boundingBox.max.x - timerGeometry.boundingBox.min.x);
      timerMesh.position.set(timerCenterOffset, 1.8, -0.75);
      scene.add(timerMesh);
    });
  });

  const sphereGeometry = new THREE.SphereGeometry(0.05, 32, 32);
  const sphereMaterial = new THREE.MeshStandardMaterial({ color: 0x0078d7, transparent: true, opacity: 0.5 });
  sphere1 = new THREE.Mesh(sphereGeometry, sphereMaterial);
  scene.add(sphere1);
  sphere2 = new THREE.Mesh(sphereGeometry, sphereMaterial);
  scene.add(sphere2);

  controller1 = renderer.xr.getController(0);
  controller1.addEventListener('selectstart', onSelectStart);
  controller1.addEventListener('selectend', onSelectEnd);
  controller1.addEventListener('squeezestart', onSelectStart);
  controller1.addEventListener('squeezeend', onSelectEnd);
  scene.add(controller1);

  controller2 = renderer.xr.getController(1);
  controller2.addEventListener('selectstart', onSelectStart);
  controller2.addEventListener('selectend', onSelectEnd);
  controller2.addEventListener('squeezestart', onSelectStart);
  controller2.addEventListener('squeezeend', onSelectEnd);
  scene.add(controller2);

  window.addEventListener('resize', onWindowResize, false);

  const vrButton = document.getElementById('vrButton');
  vrButton.addEventListener('click', async () => {
    try {
      const session = await navigator.xr.requestSession('immersive-vr', { optionalFeatures: ['local-floor', 'hand-tracking'] });
      renderer.xr.setSession(session);
      vrButton.style.display = 'none';
    } catch (error) {
      console.error('Failed to enter VR:', error);
    }
  });

  const particlesGeometry = new THREE.BufferGeometry();
  const particlesCount = 3000;
  const posArray = new Float32Array(particlesCount * 3);
  for (let i = 0; i < particlesCount * 3; i += 3) {
    let x = (Math.random() - 0.5) * 100;
    let y = (Math.random() - 0.5) * 100;
    let z = (Math.random() - 0.5) * 100;
    posArray[i] = x;
    posArray[i + 1] = y;
    posArray[i + 2] = z;
  }
  particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
  const particlesMaterial = new THREE.PointsMaterial({ size: 0.2, color: 0x00ffff, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
  const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
  scene.add(particlesMesh);

  wire = createWire(currentLevel);

  // Load all sound effects
  victorySound = new Audio('short_horns.mp3');
  contactSound = new Audio('contact.mp3');
  applauseSound = new Audio('short_applause.mp3');
  longApplauseSound = new Audio('long_applause.mp3');
  longHornsSound = new Audio('long_horns.mp3');
}

// Function to create celebration particles with multiple colors and effects
function createCelebrationParticles() {
  // Define a palette of celebration colors
  const colors = [
    0xffff00, // Gold
    0xff0000, // Red
    0x00ff00, // Green
    0x0000ff, // Blue
    0xff00ff, // Magenta
    0xffffff, // White
    0xff8800, // Orange
    0x00ffff  // Cyan
  ];
  
  // Create several particle systems with different colors and properties
  for (let c = 0; c < colors.length; c++) {
    // Create different types of particle systems
    const particleCount = 500;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const velocities = new Float32Array(particleCount * 3);
    const sizes = new Float32Array(particleCount);
    const opacities = new Float32Array(particleCount);
    
    // Position particles around the completion message area
    for (let i = 0; i < particleCount; i++) {
      // Create a cloud of particles around the game completion area
      positions[i * 3] = (Math.random() - 0.5) * 1.5; // x: spread horizontally
      positions[i * 3 + 1] = (Math.random() - 0.5) * 1.2 + 1.1; // y: centered on game complete text
      positions[i * 3 + 2] = (Math.random() - 0.5) * 0.5 - 0.75; // z: shallow depth
      
      // Random initial velocities for movement
      velocities[i * 3] = (Math.random() - 0.5) * 0.01;
      velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.01 + 0.001; // slight upward drift
      velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.01;
      
      // Random sizes for twinkling effect
      sizes[i] = Math.random() * 0.15 + 0.05;
      
      // Random starting opacities for fade in/out effect
      opacities[i] = Math.random() * 0.7 + 0.3;
    }
    
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
    
    // Create a material with additive blending for sparkle effect
    const material = new THREE.PointsMaterial({
      size: 0.10,
      color: colors[c],
      transparent: true,
      opacity: 0.8,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      sizeAttenuation: true
    });
    
    const particles = new THREE.Points(geometry, material);
    
    // Store animation properties in userData
    particles.userData = {
      velocities: velocities,
      opacities: opacities,
      originalSizes: sizes.slice(),
      pulseFactor: Math.random(),
      pulseSpeed: Math.random() * 0.03 + 0.01,
      rotationSpeed: (Math.random() - 0.5) * 0.005,
      rotationAxis: new THREE.Vector3(
        Math.random() - 0.5,
        Math.random() - 0.5,
        Math.random() - 0.5
      ).normalize(),
      spawnTime: Date.now(),
      color: colors[c]
    };
    
    scene.add(particles);
    celebrationParticles.push(particles);
  }
  
  // Add a special starburst particle system for dramatic effect
  createStarburstParticles();
  
  // Add some slow-moving golden confetti particles
  createConfettiParticles();
}

// Create a starburst effect with particles emanating from center
function createStarburstParticles() {
  const particleCount = 1000;
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(particleCount * 3);
  const velocities = new Float32Array(particleCount * 3);
  const colors = new Float32Array(particleCount * 3);
  const sizes = new Float32Array(particleCount);
  
  // Initial positions (all at center)
  for (let i = 0; i < particleCount; i++) {
    positions[i * 3] = 0; 
    positions[i * 3 + 1] = 1.1; // Center y of completion message
    positions[i * 3 + 2] = -0.75; // Center z of completion message
    
    // Velocities radiating outward in all directions
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.random() * Math.PI;
    const speed = Math.random() * 0.02 + 0.01;
    
    velocities[i * 3] = Math.sin(phi) * Math.cos(theta) * speed;
    velocities[i * 3 + 1] = Math.cos(phi) * speed;
    velocities[i * 3 + 2] = Math.sin(phi) * Math.sin(theta) * speed;
    
    // Rainbow colors
    const hue = (i / particleCount) * 360;
    const color = new THREE.Color().setHSL(hue/360, 1, 0.5);
    colors[i * 3] = color.r;
    colors[i * 3 + 1] = color.g;
    colors[i * 3 + 2] = color.b;
    
    // Various sizes
    sizes[i] = Math.random() * 0.08 + 0.02;
  }
  
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
  
  const material = new THREE.PointsMaterial({
    size: 0.05,
    vertexColors: true,
    transparent: true,
    opacity: 1.0,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });
  
  const particles = new THREE.Points(geometry, material);
  
  // Store animation properties
  particles.userData = {
    velocities: velocities,
    type: 'starburst',
    creationTime: Date.now(),
    maxLifetime: 5000 // milliseconds
  };
  
  scene.add(particles);
  celebrationParticles.push(particles);
}

// Create floating confetti-like particles
function createConfettiParticles() {
  const particleCount = 300;
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(particleCount * 3);
  const velocities = new Float32Array(particleCount * 3);
  const rotations = new Float32Array(particleCount * 3);
  const colors = new Float32Array(particleCount * 3);
  
  // Create confetti particles at top of view
  for (let i = 0; i < particleCount; i++) {
    positions[i * 3] = (Math.random() - 0.5) * 2.0; // x: wide spread
    positions[i * 3 + 1] = Math.random() * 0.5 + 1.4; // y: above completion message
    positions[i * 3 + 2] = (Math.random() - 0.5) * 0.5 - 0.75; // z: shallow depth
    
    // Slow downward drift with some sideways motion
    velocities[i * 3] = (Math.random() - 0.5) * 0.005;
    velocities[i * 3 + 1] = -Math.random() * 0.003 - 0.001; // downward
    velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.005;
    
    // Random rotation speeds
    rotations[i * 3] = (Math.random() - 0.5) * 0.1;
    rotations[i * 3 + 1] = (Math.random() - 0.5) * 0.1;
    rotations[i * 3 + 2] = (Math.random() - 0.5) * 0.1;
    
    // Gold and silver colors
    if (Math.random() > 0.5) {
      colors[i * 3] = 1.0; // Gold R
      colors[i * 3 + 1] = 0.84; // Gold G
      colors[i * 3 + 2] = 0.0; // Gold B
    } else {
      colors[i * 3] = 0.75; // Silver R
      colors[i * 3 + 1] = 0.75; // Silver G
      colors[i * 3 + 2] = 0.75; // Silver B
    }
  }
  
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  
  const material = new THREE.PointsMaterial({
    size: 0.03,
    vertexColors: true,
    transparent: true,
    opacity: 0.9,
    blending: THREE.NormalBlending
  });
  
  const particles = new THREE.Points(geometry, material);
  
  particles.userData = {
    velocities: velocities,
    rotations: rotations,
    type: 'confetti',
    lastTime: Date.now()
  };
  
  scene.add(particles);
  celebrationParticles.push(particles);
}

// Update all celebration particle systems
function updateCelebrationParticles() {
  if (celebrationParticles.length === 0) return;
  
  const now = Date.now();
  
  celebrationParticles.forEach((particles, index) => {
    const positions = particles.geometry.attributes.position.array;
    const velocities = particles.userData.velocities;
    const sizes = particles.geometry.attributes.size?.array;
    
    // Handle different particle system types
    if (particles.userData.type === 'starburst') {
      // Starburst particles expand outward and fade over time
      const elapsed = now - particles.userData.creationTime;
      const lifeFactor = 1 - Math.min(elapsed / particles.userData.maxLifetime, 1);
      
      // Update opacity based on lifetime
      particles.material.opacity = lifeFactor;
      
      // Update positions and velocities
      for (let i = 0; i < positions.length; i += 3) {
        positions[i] += velocities[i];
        positions[i + 1] += velocities[i + 1];
        positions[i + 2] += velocities[i + 2];
        
        // Slow down over time
        velocities[i] *= 0.99;
        velocities[i + 1] *= 0.99;
        velocities[i + 2] *= 0.99;
      }
      
      // Remove starburst when its lifetime is over
      if (elapsed > particles.userData.maxLifetime) {
        scene.remove(particles);
        celebrationParticles.splice(index, 1);
        return;
      }
    } 
    else if (particles.userData.type === 'confetti') {
      // Update confetti particles with realistic flutter motion
      const deltaTime = now - particles.userData.lastTime;
      particles.userData.lastTime = now;
      
      const rotations = particles.userData.rotations;
      
      for (let i = 0; i < positions.length; i += 3) {
        // Apply flutter effect - sine wave modulation of horizontal velocity
        const flutterX = Math.sin(now * 0.001 + i * 0.1) * 0.0005;
        const flutterZ = Math.cos(now * 0.0015 + i * 0.1) * 0.0005;
        
        positions[i] += velocities[i] + flutterX;
        positions[i + 1] += velocities[i + 1];
        positions[i + 2] += velocities[i + 2] + flutterZ;
        
        // Reset position if it falls below the view
        if (positions[i + 1] < 0.5) {
          positions[i] = (Math.random() - 0.5) * 2.0;
          positions[i + 1] = Math.random() * 0.5 + 1.4;
          positions[i + 2] = (Math.random() - 0.5) * 0.5 - 0.75;
        }
      }
    }
    else {
      // Standard colorful particles with twinkling and movement
      for (let i = 0; i < positions.length; i += 3) {
        // Update position with velocity
        positions[i] += velocities[i];
        positions[i + 1] += velocities[i + 1];
        positions[i + 2] += velocities[i + 2];
        
        // Add some subtle swirling motion
        const angle = now * 0.0005;
        const swirl = 0.0003 * Math.sin(angle + i * 0.01);
        velocities[i] += swirl * (Math.random() - 0.5);
        velocities[i + 2] += swirl * (Math.random() - 0.5);
        
        // Keep particles in a bounded area around the game complete message
        if (Math.abs(positions[i]) > 1.5) velocities[i] *= -0.9;
        if (Math.abs(positions[i + 1] - 1.1) > 1.0) velocities[i + 1] *= -0.9;
        if (Math.abs(positions[i + 2] + 0.75) > 0.5) velocities[i + 2] *= -0.9;
        
        // Random chance to change velocity slightly for organic movement
        if (Math.random() < 0.01) {
          velocities[i] += (Math.random() - 0.5) * 0.001;
          velocities[i + 1] += (Math.random() - 0.5) * 0.001;
          velocities[i + 2] += (Math.random() - 0.5) * 0.001;
        }
        
        // Cap max velocity
        const maxVel = 0.01;
        velocities[i] = Math.max(Math.min(velocities[i], maxVel), -maxVel);
        velocities[i + 1] = Math.max(Math.min(velocities[i + 1], maxVel), -maxVel);
        velocities[i + 2] = Math.max(Math.min(velocities[i + 2], maxVel), -maxVel);
      }
      
      // Update twinkling effect by changing sizes
      if (sizes) {
        const originalSizes = particles.userData.originalSizes;
        const timeFactor = Math.sin(now * 0.001 + particles.userData.pulseFactor * Math.PI * 2) * 0.5 + 0.5;
        
        for (let i = 0; i < sizes.length; i++) {
          if (Math.random() < 0.03) {
            // Random flicker effect
            sizes[i] = originalSizes[i] * (Math.random() * 0.5 + 0.5);
          } else {
            // Smooth breathing effect
            sizes[i] = originalSizes[i] * (0.7 + timeFactor * 0.6);
          }
        }
        particles.geometry.attributes.size.needsUpdate = true;
      }
      
      // Pulsing opacity effect
      particles.userData.pulseFactor += particles.userData.pulseSpeed;
      const opacityPulse = (Math.sin(particles.userData.pulseFactor) * 0.3) + 0.7;
      particles.material.opacity = opacityPulse;
      
      // Color shifting effect
      if (Math.random() < 0.01) {
        const hue = (now * 0.0001) % 1.0;
        const color = new THREE.Color().setHSL(hue, 1, 0.5);
        particles.material.color.set(color);
      }
    }
    
    particles.geometry.attributes.position.needsUpdate = true;
  });
  
  // Create new starburst particles occasionally for continuous celebration
  if (celebrationParticles.length > 0 && Math.random() < 0.005) {
    createStarburstParticles();
  }
}

// Function to make the wire flash
function flashWire(times = 3, isGameComplete = false) {
  if (isFlashing) return;
  isFlashing = true;
  
  let flashCount = 0;
  const maxFlashes = times * 2; // Each flash is white->blue, so double the count
  const flashDuration = isGameComplete ? 250 : 150; // Slower flashing for game complete
  
  function flash() {
    if (flashCount >= maxFlashes) {
      isFlashing = false;
      return;
    }
    
    const colors = wire.geometry.attributes.color.array;
    const isWhite = flashCount % 2 === 0;
    
    for (let i = 0; i < colors.length; i += 3) {
      colors[i] = isWhite ? 1 : 0;     // R
      colors[i + 1] = isWhite ? 1 : 0; // G
      colors[i + 2] = 1;               // B (always 1 for white or blue)
    }
    
    wire.geometry.attributes.color.needsUpdate = true;
    flashCount++;
    
    setTimeout(flash, flashDuration);
  }
  
  flash();
}

function createWire(level = 1) {
  // Remove old wire if it exists
  if (wire) {
    scene.remove(wire);
    if (wire.geometry) wire.geometry.dispose();
  }
  
  const points = [];
  const segments = 200;
  const radius = 0.75;
  
  // Add rotation offset for different levels
  const rotationOffset = level === 2 ? Math.PI / 3 : 
                        level === 3 ? Math.PI / 6 : 
                        level === 4 ? Math.PI / 7 : 0;
  
  for (let i = 0; i <= segments; i++) {
    const t = i / segments;
    const angle = t * Math.PI * 2;
    
    let waveX, waveY, waveZ, x, y, z;
    
    if (level === 1) {
      // Level 1 wire pattern
      waveX = Math.sin(angle * 8) * 0.05;
      waveY = Math.cos(angle * 6) * 0.05;
      x = (Math.cos(angle) * radius) + waveX;
      y = 1.4 + waveY;
      z = (Math.sin(angle) * radius) + waveX;
    } 
    else if (level === 2) {
      // Level 2 wire pattern - more complex waves
      waveX = Math.sin(angle * 7) * 0.07 + Math.cos(angle * 3) * 0.04;
      waveY = Math.cos(angle * 5) * 0.08 + Math.sin(angle * 9) * 0.03;
      waveZ = Math.sin(angle * 6) * 0.06;
      
      x = (Math.cos(angle + rotationOffset) * radius) + waveX;
      y = 1.4 + waveY;
      z = (Math.sin(angle + rotationOffset) * radius) + waveZ;
    }
    else if (level === 3) {
      // Level 3 wire pattern - figure-eight with waves
      const figureEight = Math.sin(angle * 2) * 0.2;
      waveX = Math.sin(angle * 10) * 0.05 + Math.cos(angle * 4) * 0.03;
      waveY = Math.cos(angle * 8) * 0.07 + Math.sin(angle * 12) * 0.04;
      
      x = (Math.cos(angle + rotationOffset) * (radius + figureEight)) + waveX;
      y = 1.4 + waveY;
      z = (Math.sin(angle + rotationOffset) * (radius - figureEight * 0.8)) + waveX;
    }
    else if (level === 4) {
      // Level 4 wire pattern - spiral with multiple oscillations
      const spiral = 0.1 * Math.sin(angle * 3);
      const verticalWave = Math.sin(angle * 7) * 0.15;
      waveX = Math.sin(angle * 13) * 0.05 + Math.cos(angle * 5) * 0.04;
      waveY = Math.cos(angle * 9) * 0.06 + Math.sin(angle * 15) * 0.03;
      
      x = (Math.cos(angle + rotationOffset) * (radius + spiral)) + waveX;
      y = 1.4 + waveY + verticalWave;
      z = (Math.sin(angle + rotationOffset) * (radius + spiral)) + waveX;
    }
    
    points.push(new THREE.Vector3(x, y, z));
  }
  
  // Create a path from the points
  const path = new THREE.CatmullRomCurve3(points);
  
  // Create the tube geometry that follows the path
  const tubeGeometry = new THREE.TubeGeometry(path, segments, 0.01, 8, false);
  
  // Create per-vertex colors for the tube
  const colors = new Float32Array(tubeGeometry.attributes.position.count * 3);
  for (let i = 0; i < colors.length; i += 3) {
    // Blue color for the wire
    colors[i] = 0;     // R
    colors[i + 1] = 0; // G
    colors[i + 2] = 1; // B
  }
  tubeGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  
  // Create a material with vertex colors
  wireMaterial = new THREE.MeshStandardMaterial({
    vertexColors: true,
    emissive: 0x0000ff,
    emissiveIntensity: 0.5,
    metalness: 0.8,
    roughness: 0.2
  });
  
  // Create and return the mesh
  const wireMesh = new THREE.Mesh(tubeGeometry, wireMaterial);
  scene.add(wireMesh);
  
  return wireMesh;
}

function onSelectStart(event) {
  const controller = event.target;
  const intersect = getIntersections(controller);
  
  if (intersect && !grabbed) {
    // Start grabbing the ring
    grabbed = true;
    grabbingController = controller;
    
    // Calculate the offset between controller position and ring position
    const controllerPosition = new THREE.Vector3();
    controller.getWorldPosition(controllerPosition);
    grabOffset.copy(ring.position).sub(controllerPosition);
    
    // Calculate rotation offset
    const controllerRotation = new THREE.Quaternion();
    controller.getWorldQuaternion(controllerRotation);
    const ringRotation = new THREE.Quaternion();
    ring.getWorldQuaternion(ringRotation);
    grabRotationOffset.copy(ringRotation).premultiply(controllerRotation.invert());
    
    // Start the timer when ring is first grabbed
    if (startTime === null) {
      startTime = Date.now();
      console.log("Timer started");
    }
  }
}

function onSelectEnd(event) {
  if (grabbed && event.target === grabbingController) {
    grabbed = false;
    grabbingController = null;
  }
}

function getIntersections(controller) {
  // Simple distance-based intersection test with a larger capture radius
  const tempMatrix = new THREE.Matrix4();
  tempMatrix.identity().extractRotation(controller.matrixWorld);
  
  const controllerPosition = new THREE.Vector3();
  controller.getWorldPosition(controllerPosition);
  
  // Calculate distance from controller to ring
  const distance = controllerPosition.distanceTo(ring.position);
  
  // Return the ring if it's close enough to the controller
  return distance < 0.15 ? ring : null;
}

function checkWireCollision() {
  // Create an array of points representing the wire
  if (!wire || !wire.geometry) return false;
  
  // Get the ring position
  const ringPosition = ring.position;
  
  // Get the curve geometry from the tube
  const curve = wire.geometry.parameters?.path;
  if (!curve) return false;
  
  // Check distance from ring to each point along the curve
  const segments = 100;
  const wireRadius = 0.01; // Radius of the wire tube
  const ringRadius = 0.075; // Ring radius
  
  // Combined collision radius (wire + ring radii)
  const collisionRadius = wireRadius + ringRadius * 0.85; // Slightly reduce ring radius for better gameplay feel
  
  for (let i = 0; i <= segments; i++) {
    const t = i / segments;
    const wirePoint = curve.getPointAt(t);
    
    // Calculate distance from ring center to this point on the wire
    const distance = ringPosition.distanceTo(wirePoint);
    
    // If the distance is less than the combined radius, there's a collision
    if (distance < collisionRadius) {
      return true;
    }
  }
  
  return false;
}

function updateTimer() {
  if (startTime !== null && timerMesh && timerFont) {
    const now = Date.now();
    elapsedTime = now - startTime;
    
    // Convert to seconds and milliseconds
    const seconds = Math.floor(elapsedTime / 1000);
    const milliseconds = elapsedTime % 1000;
    
    // Create formatted string (e.g. "12:345")
    const timeStr = `${seconds.toString().padStart(2, '0')}:${milliseconds.toString().padStart(3, '0')}`;
    
    // Update the timer text
    scene.remove(timerMesh);
    const timerGeometry = new THREE.TextGeometry(timeStr, { font: timerFont, size: 0.02, height: 0.005 });
    const timerMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
    timerMesh = new THREE.Mesh(timerGeometry, timerMaterial);
    timerGeometry.computeBoundingBox();
    const timerCenterOffset = -0.5 * (timerGeometry.boundingBox.max.x - timerGeometry.boundingBox.min.x);
    timerMesh.position.set(timerCenterOffset, 1.8, -0.75);
    scene.add(timerMesh);
  }
}

function victory() {
  if (startTime !== null) {
    // Store the completion time for this level
    const levelTime = Date.now() - startTime;
    levelTimes[currentLevel - 1] = levelTime;
    
    startTime = null;
    
    // Play victory sounds
    victorySound.play().catch(error => console.log('Sound play error:', error));
    applauseSound.play().catch(error => console.log('Sound play error:', error));
    
    // Flash the wire white and blue
    flashWire(3, false);
    
    console.log(`Level ${currentLevel} completed in ${levelTime}ms`);
    
    // Advance to the next level - CHANGED to support four levels
    if (currentLevel < 4) {
      currentLevel++;
      
      // Update level text
      if (textMesh && font) {
        scene.remove(textMesh);
        const textGeometry = new THREE.TextGeometry(`LEVEL ${currentLevel}`, { font: font, size: 0.02, height: 0.005 });
        const textMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
        textMesh = new THREE.Mesh(textGeometry, textMaterial);
        textGeometry.computeBoundingBox();
        const centerOffset = -0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x);
        textMesh.position.set(centerOffset, 2.0, -0.75);
        scene.add(textMesh);
      }
      
      // Create new wire
      wire = createWire(currentLevel);
      
      // Reset ring to starting position
      ring.position.copy(ringStartPosition);
      ring.rotation.y = Math.PI / 2;
      
      // Ready the timer for next level
      if (timerMesh && timerFont) {
        scene.remove(timerMesh);
        const timerGeometry = new THREE.TextGeometry('00:000', { font: timerFont, size: 0.02, height: 0.005 });
        const timerMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
        timerMesh = new THREE.Mesh(timerGeometry, timerMaterial);
        timerGeometry.computeBoundingBox();
        const timerCenterOffset = -0.5 * (timerGeometry.boundingBox.max.x - timerGeometry.boundingBox.min.x);
        timerMesh.position.set(timerCenterOffset, 1.8, -0.75);
        scene.add(timerMesh);
      }
    } else {
      // Game complete! Show summary of times
      const totalTime = levelTimes.reduce((total, time) => total + time, 0);
      
      // Play grand finale sounds
      longHornsSound.play().catch(error => console.log('Sound play error:', error));
      longApplauseSound.play().catch(error => console.log('Sound play error:', error));
      
      // Flash the wire more dramatically
      flashWire(6, true);
      
      // Create celebration particles for finale - ENHANCED
      createCelebrationParticles(); // Original
      
      // Add new particle types for a more spectacular finale
      createSpiralParticles();
      createSpiralParticles(); // Create multiple for richness
      createGlitteringParticles();
      
      // Schedule additional bursts for continuous celebration
      setTimeout(() => createStarburstParticles(), 500);
      setTimeout(() => createSpiralParticles(), 1200);
      setTimeout(() => createGlitteringParticles(), 1800);
      setTimeout(() => createStarburstParticles(), 2400);
      setTimeout(() => createSpiralParticles(), 3000);
      
      // Show completion text
      if (textMesh && font) {
        scene.remove(textMesh);
        const textGeometry = new THREE.TextGeometry('GAME COMPLETE!', { font: font, size: 0.03, height: 0.005 });
        const textMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
        textMesh = new THREE.Mesh(textGeometry, textMaterial);
        textGeometry.computeBoundingBox();
        const centerOffset = -0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x);
        textMesh.position.set(centerOffset, 2.0, -0.75);
        scene.add(textMesh);
      }
      
      // Display time summary
      if (timerMesh && timerFont) {
        scene.remove(timerMesh);
        
        // Format times
        let summaryText = '';
        for (let i = 0; i < levelTimes.length; i++) {
          const seconds = Math.floor(levelTimes[i] / 1000);
          const millis = levelTimes[i] % 1000;
          summaryText += `Lvl ${i+1}: ${seconds}:${millis.toString().padStart(3, '0')}\n`;
        }
        
        const totalSeconds = Math.floor(totalTime / 1000);
        const totalMillis = totalTime % 1000;
        summaryText += `\nTotal: ${totalSeconds}:${totalMillis.toString().padStart(3, '0')}`;
        
        const timerGeometry = new THREE.TextGeometry(summaryText, { 
          font: timerFont, 
          size: 0.015, 
          height: 0.005,
          lineHeight: 0.02
        });
        
        const timerMaterial = new THREE.MeshStandardMaterial({ color: 0x00ffff });
        timerMesh = new THREE.Mesh(timerGeometry, timerMaterial);
        timerGeometry.computeBoundingBox();
        const timerCenterOffset = -0.5 * (timerGeometry.boundingBox.max.x - timerGeometry.boundingBox.min.x);
        timerMesh.position.set(timerCenterOffset, 1.8, -0.75);
        scene.add(timerMesh);
      }
    }
  }
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// Create spiral/helix particle effects that sweep around in patterns
function createSpiralParticles() {
  const particleCount = 800;
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(particleCount * 3);
  const velocities = new Float32Array(particleCount * 3);
  const colors = new Float32Array(particleCount * 3);
  const sizes = new Float32Array(particleCount);
  
  // Create particles arranged in spiral patterns
  for (let i = 0; i < particleCount; i++) {
    const spiralType = Math.floor(i / (particleCount / 3)); // 3 different spiral types
    const t = (i % (particleCount / 3)) / (particleCount / 3);
    const angle = t * Math.PI * 10; // Multiple full rotations
    
    // Different spiral patterns
    let x, y, z;
    const radius = 0.2 + t * 0.8; // Expanding radius
    
    if (spiralType === 0) {
      // Horizontal expanding spiral
      x = Math.cos(angle) * radius;
      y = 1.1 + t * 0.2;
      z = Math.sin(angle) * radius - 0.75;
    } else if (spiralType === 1) {
      // Vertical spiral
      x = Math.cos(angle) * (radius * 0.7);
      y = 1.1 + Math.sin(angle * 0.5) * 0.2;
      z = Math.sin(angle) * (radius * 0.7) - 0.75;
    } else {
      // DNA-like double helix
      const side = Math.floor(i % 2);
      const helix = Math.sin(angle) * 0.15;
      const offset = (side === 0) ? 0.05 : -0.05;
      x = Math.cos(angle) * 0.3 + offset;
      y = 0.8 + t * 0.6;
      z = helix - 0.75;
    }
    
    positions[i * 3] = x;
    positions[i * 3 + 1] = y;
    positions[i * 3 + 2] = z;
    
    // Create velocities that follow the spiral paths
    const tangentialSpeed = 0.003;
    velocities[i * 3] = Math.random() * 0.002 - 0.001;
    velocities[i * 3 + 1] = Math.random() * 0.002 - 0.001;
    velocities[i * 3 + 2] = Math.random() * 0.002 - 0.001;
    
    // Create rainbow gradient based on position in spiral
    const hue = (t + spiralType * 0.33) % 1.0;
    const color = new THREE.Color().setHSL(hue, 1, 0.5);
    colors[i * 3] = color.r;
    colors[i * 3 + 1] = color.g;
    colors[i * 3 + 2] = color.b;
    
    // Varying sizes
    sizes[i] = Math.random() * 0.04 + 0.02;
  }
  
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
  
  const material = new THREE.PointsMaterial({
    size: 0.04,
    vertexColors: true,
    transparent: true,
    opacity: 0.8,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });
  
  const particles = new THREE.Points(geometry, material);
  
  // Store animation properties
  particles.userData = {
    velocities: velocities,
    type: 'spiral',
    creationTime: Date.now(),
    maxLifetime: 8000, // longer lifetime
    angleOffset: 0
  };
  
  scene.add(particles);
  celebrationParticles.push(particles);
}

// Create glittering diamond-like particles
function createGlitteringParticles() {
  const particleCount = 200;
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(particleCount * 3);
  const velocities = new Float32Array(particleCount * 3);
  const colors = new Float32Array(particleCount * 3);
  const sizes = new Float32Array(particleCount);
  const opacities = new Float32Array(particleCount);
  
  for (let i = 0; i < particleCount; i++) {
    // Position in a sphere around the completion area
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.random() * Math.PI;
    const radius = Math.random() * 0.8 + 0.2;
    
    positions[i * 3] = Math.sin(phi) * Math.cos(theta) * radius;
    positions[i * 3 + 1] = Math.cos(phi) * radius + 1.1;
    positions[i * 3 + 2] = Math.sin(phi) * Math.sin(theta) * radius - 0.75;
    
    // Very slow drift
    velocities[i * 3] = (Math.random() - 0.5) * 0.001;
    velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.001;
    velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.001;
    
    // White/silver with slight color tints
    const colorTint = Math.random() * 0.2;
    colors[i * 3] = 0.8 + colorTint; // R
    colors[i * 3 + 1] = 0.8 + colorTint; // G
    colors[i * 3 + 2] = 0.8 + colorTint; // B
    
    // Random sizes for intense twinkling
    sizes[i] = Math.random() * 0.05 + 0.01;
    
    // Random opacities
    opacities[i] = Math.random();
  }
  
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
  
  const material = new THREE.PointsMaterial({
    size: 0.03,
    vertexColors: true,
    transparent: true,
    opacity: 1.0,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });
  
  const particles = new THREE.Points(geometry, material);
  
  particles.userData = {
    velocities: velocities,
    originalSizes: sizes.slice(),
    opacities: opacities.slice(),
    type: 'glitter',
    lastUpdate: Date.now()
  };
  
  scene.add(particles);
  celebrationParticles.push(particles);
}

function animate() {
  renderer.setAnimationLoop(render);
}

function render() {
  // Update controller spheres
  sphere1.visible = false;
  sphere2.visible = false;
  
  const controllerPosition1 = new THREE.Vector3();
  controller1.getWorldPosition(controllerPosition1);
  sphere1.position.copy(controllerPosition1);
  sphere1.visible = true;
  
  const controllerPosition2 = new THREE.Vector3();
  controller2.getWorldPosition(controllerPosition2);
  sphere2.position.copy(controllerPosition2);
  sphere2.visible = true;
  
  // Update ring position and rotation if grabbed
  if (grabbed && grabbingController) {
    const controllerPosition = new THREE.Vector3();
    grabbingController.getWorldPosition(controllerPosition);
    
    // Apply the position offset to keep ring in same relative position to controller
    ring.position.copy(controllerPosition).add(grabOffset);
    
    // Apply rotation
    const controllerRotation = new THREE.Quaternion();
    grabbingController.getWorldQuaternion(controllerRotation);
    ring.quaternion.copy(controllerRotation).multiply(grabRotationOffset);
    
    // Check for wire collision
    if (checkWireCollision()) {
      // Game over! Reset the level
      contactSound.play().catch(error => console.log('Sound play error:', error));
      
      console.log("Hit the wire! Resetting level.");
      
      // Reset ring to starting position
      ring.position.copy(ringStartPosition);
      ring.rotation.y = Math.PI / 2;
      
      // Reset timer
      startTime = null;
      
      // Reset timer display to 00:000
      if (timerMesh && timerFont) {
        scene.remove(timerMesh);
        const timerGeometry = new THREE.TextGeometry('00:000', { font: timerFont, size: 0.02, height: 0.005 });
        const timerMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
        timerMesh = new THREE.Mesh(timerGeometry, timerMaterial);
        timerGeometry.computeBoundingBox();
        const timerCenterOffset = -0.5 * (timerGeometry.boundingBox.max.x - timerGeometry.boundingBox.min.x);
        timerMesh.position.set(timerCenterOffset, 1.8, -0.75);
        scene.add(timerMesh);
      }
      
      // Release the grabbed state
      grabbed = false;
      grabbingController = null;
    }
    
    // Check for victory condition - reached the end of the wire path
    const wireEnd = wire.geometry.parameters?.path.getPoint(1);
    if (wireEnd) {
      const distanceToEnd = ring.position.distanceTo(wireEnd);
      if (distanceToEnd < 0.2) { // If ring is close enough to the end of wire
        victory();
      }
    }
  }
  
  // Update the timer display
  updateTimer();
  
  // Update celebration particles animation
  updateCelebrationParticles();

  renderer.render(scene, camera);
}
</script>
</body>
</html>

