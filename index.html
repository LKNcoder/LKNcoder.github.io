<!doctype html>
<html>
<head>
<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
<meta name='mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<link rel='icon' type='image/png' sizes='32x32' href='favicon-32x32.png'>
<link rel='icon' type='image/png' sizes='96x96' href='favicon-96x96.png'>
<title>Ring Ring</title>
<style>
body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #f0f0f0; }
canvas { display: block; }
#vrButton {
padding: 20px 40px;
font-size: 24px;
background-color: #0078d7;
color: white;
border: none;
border-radius: 10px;
cursor: pointer;
transition: background-color 0.3s ease;
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
}
#vrButton:hover { background-color: #005bb5; }
</style>


<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>

</head>
<body>
<button id="vrButton">Enter VR</button>
<script type="importmap">
{
"imports": {
"three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
"three/examples/jsm/webxr/VRButton.js": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/webxr/VRButton.js",
"three/examples/jsm/webxr/XRControllerModelFactory.js": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/webxr/XRControllerModelFactory.js",
"three-mesh-ui": "https://cdn.jsdelivr.net/npm/three-mesh-ui@6.5.4/build/three-mesh-ui.module.js"
}
}
</script>
<script type="module">
import * as THREE from 'three';
import { VRButton } from 'three/examples/jsm/webxr/VRButton.js';

let camera, scene, renderer, controller1, controller2, sphere1, sphere2, ring, textMesh, timerMesh;
let grabbed = false, grabbingController = null, grabOffset = new THREE.Vector3(), grabRotationOffset = new THREE.Quaternion();
let startTime = null, elapsedTime = 0, font, timerFont, wire, wirePoints = [], wireMaterial, victorySound, contactSound;
const ringStartPosition = new THREE.Vector3(0, 1.35, -0.75);
let currentLevel = 1; // Track current level
let levelTimes = []; // Array to store completion times for each level

let explosionFragments = [];
let explosionStartTime = null;
let isExploding = false;
let confettiParticles = [];
let confettiStartTime = null;
let gameCompletionMeshes = [];

let transitionImmunity = false;
let xrInputSources = [];

let gameCompleted = false;
let scoreSummaryMeshes = []; 
let keyboardMeshes = [];
let initialsDisplayMesh;
let nameEntered = false;
let playerName = ""; // Empty string to start
let maxNameLength = 10;
let hoveredButton = null;
let keyboardActive = false;
let controllerRays = [];
const keyboardRaycaster = new THREE.Raycaster();
const tempVector = new THREE.Vector3();

// Sound effects and flashing state
let applauseSound, longApplauseSound, longHornsSound, hornsSound, chimeSound;
let isFlashing = false;

const firebaseConfig = {
  apiKey: "AIzaSyCvzAS8zXYraoP-a10eAMFAZX7u1TQNY-M",
  databaseURL: "https://ring-ring-vr-game-default-rtdb.firebaseio.com/",
  projectId: "ring-ring-vr-game"
};
firebase.initializeApp(firebaseConfig);
const leaderboardRef = firebase.database().ref('leaderboard');


init();
animate();

function init() {
scene = new THREE.Scene();
camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.xr.enabled = true;
document.body.appendChild(renderer.domElement);

const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
light.position.set(0.5, 1, 0.25);
scene.add(light);

const ringGeometry = new THREE.TorusGeometry(0.075, 0.00625, 16, 100);
const ringMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 1.0, metalness: 1.0, roughness: 0.0 });
ring = new THREE.Mesh(ringGeometry, ringMaterial);
ring.position.copy(ringStartPosition);
ring.rotation.y = Math.PI / 2;
scene.add(ring);

const loader = new THREE.FontLoader();
loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (loadedFont) {
font = loadedFont;
console.log('Font loaded successfully!', font);
const textGeometry = new THREE.TextGeometry(`LEVEL ${currentLevel}/5`, { font: font, size: 0.02, height: 0.005 });
const textMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
textMesh = new THREE.Mesh(textGeometry, textMaterial);
textGeometry.computeBoundingBox();
const centerOffset = -0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x);
textMesh.position.set(centerOffset, 2.0, -0.75);
scene.add(textMesh);

// Load a monospaced font for the timer
const timerFontURL = 'https://threejs.org/examples/fonts/gentilis_regular.typeface.json';
loader.load(timerFontURL, function (loadedTimerFont) {
timerFont = loadedTimerFont;

// Use the loaded font for the timer with shorter format
const timerGeometry = new THREE.TextGeometry('0:00:000', { font: timerFont, size: 0.02, height: 0.005 });
const timerMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
timerMesh = new THREE.Mesh(timerGeometry, timerMaterial);
timerGeometry.computeBoundingBox();
const timerCenterOffset = -0.5 * (timerGeometry.boundingBox.max.x - timerGeometry.boundingBox.min.x);
timerMesh.position.set(timerCenterOffset, 1.8, -0.75);
scene.add(timerMesh);
});
});


const sphereGeometry = new THREE.SphereGeometry(0.05, 32, 32);
const sphereMaterial = new THREE.MeshStandardMaterial({ color: 0x0078d7, transparent: true, opacity: 0.5 });
sphere1 = new THREE.Mesh(sphereGeometry, sphereMaterial);
scene.add(sphere1);
sphere2 = new THREE.Mesh(sphereGeometry, sphereMaterial);
scene.add(sphere2);

controller1 = renderer.xr.getController(0);
controller1.addEventListener('selectstart', onSelectStart);
controller1.addEventListener('selectend', onSelectEnd);
controller1.addEventListener('squeezestart', onSelectStart);
controller1.addEventListener('squeezeend', onSelectEnd);
scene.add(controller1);

controller2 = renderer.xr.getController(1);
controller2.addEventListener('selectstart', onSelectStart);
controller2.addEventListener('selectend', onSelectEnd);
controller2.addEventListener('squeezestart', onSelectStart);
controller2.addEventListener('squeezeend', onSelectEnd);
scene.add(controller2);

window.addEventListener('resize', onWindowResize, false);

const vrButton = document.getElementById('vrButton');

vrButton.addEventListener('click', async () => {
try {
chimeSound.play().catch(error => console.log('Chime sound play error:', error));
const session = await navigator.xr.requestSession('immersive-vr', { optionalFeatures: ['local-floor', 'hand-tracking'] });
renderer.xr.setSession(session);
vrButton.style.display = 'none';

    // Set a flag to track first frame
    let firstFrameRendered = false;

     // Initialize haptics after the first frame is rendered
     session.requestAnimationFrame(() => {
      console.log('First XR frame rendered');
      if (!firstFrameRendered) {
        firstFrameRendered = true;
        console.log('Waiting for controllers to initialize...');
        setTimeout(initControllerHaptics, 1000);        
      }
    });
    
    // Also listen for input source changes
    session.addEventListener('inputsourceschange', (event) => {
      console.log('Input sources changed:', event);
      setTimeout(initControllerHaptics, 500); // Small delay after change
    });


} catch (error) {
console.error('Failed to enter VR:', error);
}
});


const particlesGeometry = new THREE.BufferGeometry();
const particlesCount = 3000;
const posArray = new Float32Array(particlesCount * 3);
const minDistance = 5.0; // Minimum distance from center to avoid particles near wire
for (let i = 0; i < particlesCount * 3; i += 3) {
let x = (Math.random() - 0.5) * 100;
let y = (Math.random() - 0.5) * 100;
let z = (Math.random() - 0.5) * 100;

 // Calculate distance from center
 const distance = Math.sqrt(x*x + y*y + z*z);

   // If too close, push it outward to minimum distance
   if (distance < minDistance) {
    const scale = minDistance / distance;
    x *= scale;
    y *= scale;
    z *= scale;
  }

posArray[i] = x;
posArray[i + 1] = y;
posArray[i + 2] = z;
}
particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
const particlesMaterial = new THREE.PointsMaterial({ size: 0.2, color: 0x00ffff, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
scene.add(particlesMesh);

wire = createWire(currentLevel);

// Load all sound effects
victorySound = new Audio('short_horns.mp3');
contactSound = new Audio('contact.mp3');
applauseSound = new Audio('short_applause.mp3');
longApplauseSound = new Audio('long_applause.mp3');
longHornsSound = new Audio('long_horns.mp3');
chimeSound = new Audio('chime.mp3');
}

// Function to initialize haptic feedback system using direct XR input sources
function initControllerHaptics() {
  console.log('Initializing haptic feedback system');
  
  // Clear any previous input sources
  xrInputSources = [];
  
  // Get current session
  const session = renderer.xr.getSession();
  if (!session) {
    console.warn('No XR session available for haptics');
    return;
  }

 // Get and store all input sources
 xrInputSources = Array.from(session.inputSources || []);
  console.log('Found input sources:', xrInputSources.length);
  
  // Log details about each input source
  xrInputSources.forEach((inputSource, index) => {
    console.log(`Input source ${index}:`, {
      handedness: inputSource.handedness,
      profiles: inputSource.profiles,
      hasGamepad: !!inputSource.gamepad
    });
  });
  
  // Set up listener for future input source changes
  session.addEventListener('inputsourceschange', (event) => {
    console.log('Input sources changed:', event);
    
    // Update our stored input sources
    xrInputSources = Array.from(session.inputSources || []);
    console.log('Updated input sources count:', xrInputSources.length);
    
    // Test newly added input sources
    if (event.added && event.added.length > 0) {
      event.added.forEach(source => {
        console.log('Testing new input source:', source.handedness);
        setTimeout(() => {
          triggerHapticFeedbackByHandedness(source.handedness, 0.7, 300);
        }, 500);
      });
    }
  });
}

function createImprovedVirtualKeyboard() {
    keyboardActive = true;
    createControllerRays();

  // Remove any existing keyboard elements
  keyboardMeshes.forEach(mesh => {
    scene.remove(mesh);
    if (mesh.geometry) mesh.geometry.dispose();
    if (mesh.material) mesh.material.dispose();
  });
  keyboardMeshes = [];

  //check for font
  if (!font) {
    console.error("Font not loaded, cannot create keyboard");
    // Try again in a second
    setTimeout(createImprovedVirtualKeyboard, 1000);
    return null;
  }
  
  // Keyboard container to group all elements
  const keyboardContainer = new THREE.Group();
  keyboardContainer.name = "keyboardContainer"; 
  keyboardContainer.position.set(0, 1.2, -0.75);
  keyboardContainer.scale.set(0.4, 0.4, 0.4);
  scene.add(keyboardContainer);
  gameCompletionMeshes.push(keyboardContainer);
  keyboardMeshes.push(keyboardContainer);
  
  // Keyboard background panel
  const panelGeometry = new THREE.BoxGeometry(0.8, 0.65, 0.01);
  const panelMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x222222, 
    transparent: true, 
    opacity: 0.8 
  });
  const panel = new THREE.Mesh(panelGeometry, panelMaterial);
  panel.position.set(0, -0.08, -0.01);
  keyboardContainer.add(panel);
  keyboardMeshes.push(panel);
  
  // Display area for input
  const displayGeometry = new THREE.BoxGeometry(0.7, 0.08, 0.01);
  const displayMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x333333, 
    transparent: true, 
    opacity: 0.9 
  });
  const displayPanel = new THREE.Mesh(displayGeometry, displayMaterial);
  displayPanel.position.set(0, 0.15, 0);
  keyboardContainer.add(displayPanel);
  keyboardMeshes.push(displayPanel);
  
  // Create initial text display
  updateNameDisplay(keyboardContainer);
  
  // Define key rows
  const rows = [
    "1234567890",
    "QWERTYUIOP",
    "ASDFGHJKL",
    "ZXCVBNM"
  ];
  
  // Config
  const keySize = 0.06;
  const keyMargin = 0.01;
  const keyHeight = 0.06;
  const startY = 0.05;
  
  // Create all keys
  rows.forEach((row, rowIndex) => {
    const rowWidth = row.length * (keySize + keyMargin) - keyMargin;
    const startX = -rowWidth / 2;
    
    row.split('').forEach((letter, colIndex) => {
      const x = startX + colIndex * (keySize + keyMargin) + keySize/2;
      const y = startY - rowIndex * (keyHeight + keyMargin);
      
      const keyGeometry = new THREE.BoxGeometry(keySize, keyHeight, 0.01);
      const keyMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x444444,
        emissive: 0x222222,
        emissiveIntensity: 0.2
      });
      const key = new THREE.Mesh(keyGeometry, keyMaterial);
      key.position.set(x, y, 0);
      keyboardContainer.add(key);
      keyboardMeshes.push(key);
      
      // Add letter text
      const textGeometry = new THREE.TextGeometry(letter, { 
        font: font, 
        size: 0.025, 
        height: 0.001 
      });
      const textMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xffffff 
      });
      const textMesh = new THREE.Mesh(textGeometry, textMaterial);
      textGeometry.computeBoundingBox();
      const textOffset = new THREE.Vector3(
        -(textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x) / 2,
        -(textGeometry.boundingBox.max.y - textGeometry.boundingBox.min.y) / 2,
        0
      );
      textMesh.position.copy(textOffset);
      textMesh.position.z = 0.006;
      key.add(textMesh);
      
      // Make key interactive
      key.userData.isButton = true;
      key.userData.buttonType = 'letter';
      key.userData.letter = letter;
      key.userData.defaultColor = 0x444444;
      key.userData.hoverColor = 0x666666;
      key.userData.pressColor = 0x888888;
    });
  });
  
  // Special keys - common row
  const specialRow = [
    { label: "Space", width: 0.25, action: 'space', x: -0.15 },
    { label: "Back", width: 0.15, action: 'backspace', x: 0.15, color: 0x884444 }
  ];
  
  const specialY = startY - 4 * (keyHeight + keyMargin);
  
  specialRow.forEach(key => {
    const keyGeometry = new THREE.BoxGeometry(key.width, keyHeight, 0.01);
    const keyMaterial = new THREE.MeshStandardMaterial({ 
      color: key.color || 0x444444,
      emissive: key.color ? 0x220000 : 0x222222,
      emissiveIntensity: 0.2
    });
    const keyMesh = new THREE.Mesh(keyGeometry, keyMaterial);
    keyMesh.position.set(key.x, specialY, 0);
    keyboardContainer.add(keyMesh);
    keyboardMeshes.push(keyMesh);
    
    // Add text label
    const textGeometry = new THREE.TextGeometry(key.label, { 
      font: font, 
      size: 0.02, 
      height: 0.001 
    });
    const textMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
    const textMesh = new THREE.Mesh(textGeometry, textMaterial);
    textGeometry.computeBoundingBox();
    const textOffset = new THREE.Vector3(
      -(textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x) / 2,
      -(textGeometry.boundingBox.max.y - textGeometry.boundingBox.min.y) / 2,
      0
    );
    textMesh.position.copy(textOffset);
    textMesh.position.z = 0.006;
    keyMesh.add(textMesh);
    
    // Set button data
    keyMesh.userData.isButton = true;
    keyMesh.userData.buttonType = key.action;
    keyMesh.userData.defaultColor = key.color || 0x444444;
    keyMesh.userData.hoverColor = key.color ? 0xbb5555 : 0x666666;
    keyMesh.userData.pressColor = key.color ? 0xff6666 : 0x888888;
  });
  
  // Submit button
  const submitGeometry = new THREE.BoxGeometry(0.7, 0.08, 0.01);
  const submitMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x008800,
    emissive: 0x004400,
    emissiveIntensity: 0.3
  });
  const submitButton = new THREE.Mesh(submitGeometry, submitMaterial);
  submitButton.position.set(0, specialY - keyHeight - keyMargin*2, 0);
  keyboardContainer.add(submitButton);
  keyboardMeshes.push(submitButton);
  
  // Add submit text
  const submitTextGeometry = new THREE.TextGeometry("SUBMIT NAME", { 
    font: font, 
    size: 0.03, 
    height: 0.001 
  });
  const submitTextMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
  const submitTextMesh = new THREE.Mesh(submitTextGeometry, submitTextMaterial);
  submitTextGeometry.computeBoundingBox();
  const submitTextOffset = new THREE.Vector3(
    -(submitTextGeometry.boundingBox.max.x - submitTextGeometry.boundingBox.min.x) / 2,
    -(submitTextGeometry.boundingBox.max.y - submitTextGeometry.boundingBox.min.y) / 2,
    0
  );
  submitTextMesh.position.copy(submitTextOffset);
  submitTextMesh.position.z = 0.006;
  submitButton.add(submitTextMesh);
  
  submitButton.userData.isButton = true;
  submitButton.userData.buttonType = 'submit';
  submitButton.userData.defaultColor = 0x008800;
  submitButton.userData.hoverColor = 0x00aa00;
  submitButton.userData.pressColor = 0x00cc00;
  
  return keyboardContainer;
}

// Updated name display function to work with the new keyboard
// Updated name display function to have a separate cursor mesh
function updateNameDisplay(container) {
  // Remove existing display elements
  if (initialsDisplayMesh) {
    if (container) {
      container.remove(initialsDisplayMesh);
    } else {
      scene.remove(initialsDisplayMesh);
    }
    
    if (initialsDisplayMesh.geometry) {
      initialsDisplayMesh.geometry.dispose();
    }
  }
  
  // Clear any existing cursor blink interval
  if (initialsDisplayMesh && initialsDisplayMesh.userData.blinkInterval) {
    clearInterval(initialsDisplayMesh.userData.blinkInterval);
  }
  
  // Create a group to hold both name and cursor
  const textGroup = new THREE.Group();
  
  // Create the name text (without cursor)
  const nameGeometry = new THREE.TextGeometry(playerName, { 
    font: font, 
    size: 0.04, 
    height: 0.001 
  });
  
  const nameMesh = new THREE.Mesh(
    nameGeometry, 
    new THREE.MeshStandardMaterial({ color: 0x00ffff })
  );
  
  nameGeometry.computeBoundingBox();
  const nameWidth = nameGeometry.boundingBox.max.x - nameGeometry.boundingBox.min.x;
  
  // Position name text at left side of the centered group
  nameMesh.position.set(0, 0, 0.006);
  textGroup.add(nameMesh);
  
  // Create separate cursor mesh only if we haven't reached max length
  let cursorMesh = null;
  if (playerName.length < maxNameLength) {
    const cursorGeometry = new THREE.TextGeometry("|", { 
      font: font, 
      size: 0.04, 
      height: 0.001 
    });
    
    cursorMesh = new THREE.Mesh(
      cursorGeometry, 
      new THREE.MeshStandardMaterial({ color: 0x00ffff })
    );
    
    // Position cursor right after the name text
    cursorMesh.position.set(nameWidth, 0, 0.006);
    textGroup.add(cursorMesh);
    
    // Set up blinking for cursor only
    const blinkInterval = setInterval(() => {
      if (cursorMesh && cursorMesh.parent) {
        cursorMesh.visible = !cursorMesh.visible;
      } else {
        clearInterval(blinkInterval);
      }
    }, 500);
    
    textGroup.userData.blinkInterval = blinkInterval;
  }
  
  // Center the entire text group
  textGroup.position.set(-nameWidth/2, 0, 0);
  
  // Add the group to the container or scene
  if (container) {
    textGroup.position.y = 0.13;
    container.add(textGroup);
  } else {
    textGroup.position.set(-nameWidth/2, 1.05, -0.75);
    scene.add(textGroup);
    gameCompletionMeshes.push(textGroup);
  }
  
  // Store reference to the text group
  initialsDisplayMesh = textGroup;
}

// Function to trigger haptics by controller handedness
function triggerHapticFeedbackByHandedness(handedness, intensity, duration) {
  // Find the input source for the specified hand
  const inputSource = xrInputSources.find(source => source.handedness === handedness);
  
  if (!inputSource) {
    console.warn(`No input source found for ${handedness} hand`);
    return;
  }
  
  console.log(`Attempting haptic feedback on ${handedness} controller:`, inputSource);
  
  try {
    // Try to use the gamepad haptics
    if (inputSource.gamepad) {
      console.log(`Gamepad found for ${handedness}:`, inputSource.gamepad);
      
      // Method 1: Standard haptic actuators array
      if (inputSource.gamepad.hapticActuators && inputSource.gamepad.hapticActuators.length > 0) {
        console.log(`Using hapticActuators for ${handedness}`);
        return inputSource.gamepad.hapticActuators[0].pulse(intensity, duration);
      } 
      
      // Method 2: Single haptic actuator (some Quest versions)
      if (inputSource.gamepad.hapticActuator) {
        console.log(`Using single hapticActuator for ${handedness}`);
        return inputSource.gamepad.hapticActuator.pulse(intensity, duration);
      }
      
      // Method 3: Vibration actuator (older standard)
      if (inputSource.gamepad.vibrationActuator) {
        console.log(`Using vibrationActuator for ${handedness}`);
        return inputSource.gamepad.vibrationActuator.playEffect('dual-rumble', {
          duration: duration,
          strongMagnitude: intensity,
          weakMagnitude: intensity
        });
      }
      
      // Log all available properties on the gamepad
      console.log(`All gamepad properties for ${handedness}:`);
      for (const prop in inputSource.gamepad) {
        console.log(`- ${prop}:`, inputSource.gamepad[prop]);
      }
    }
    
    console.warn(`No haptic capability found for ${handedness} controller`);
  } catch (error) {
    console.error(`Error triggering haptic on ${handedness} controller:`, error);
  }
}

// Function to trigger haptics on a controller
function triggerHapticFeedback(controller, intensity, duration) {
  // Determine handedness from controller index
  const handedness = controller === controller1 ? 'left' : 'right';
  return triggerHapticFeedbackByHandedness(handedness, intensity, duration);
}

// create visible controller rays while keyboard is active
function createControllerRays() {
  // Clear any existing rays
  controllerRays.forEach(ray => {
    if (ray.parent) ray.parent.remove(ray);
    if (ray.geometry) ray.geometry.dispose();
    if (ray.material) ray.material.dispose();
  });
  controllerRays = [];
  
  // Create a ray for each controller
  [controller1, controller2].forEach((controller, index) => {
    // Create ray geometry (a thin, long cylinder)
    const rayGeometry = new THREE.CylinderGeometry(0.001, 0.001, 3, 8);
    rayGeometry.rotateX(Math.PI / 2); // Point forward
    rayGeometry.translate(0, 0, -1.5); // Center ray with origin at controller
    
    // Create material with appropriate color
    const rayMaterial = new THREE.MeshBasicMaterial({
      color: index === 0 ? 0x0088ff : 0xff8800,
      transparent: true,
      opacity: 0.7
    });
    
    // Create mesh and add to controller
    const rayMesh = new THREE.Mesh(rayGeometry, rayMaterial);
    controller.add(rayMesh);
    controllerRays.push(rayMesh);
  });
}

// Function to remove rays when keyboard is dismissed
function hideControllerRays() {
  controllerRays.forEach(ray => {
    if (ray.parent) ray.parent.remove(ray);
    if (ray.geometry) ray.geometry.dispose();
    if (ray.material) ray.material.dispose();
  });
  controllerRays = [];
  keyboardActive = false;
}

// Function to make the wire flash
function flashWire(times = 3, isGameComplete = false) {
if (isFlashing) return;
isFlashing = true;

let flashCount = 0;
const maxFlashes = times * 2; // Each flash is white->blue, so double the count
const flashDuration = isGameComplete ? 250 : 150; // Slower flashing for game complete

function flash() {
if (flashCount >= maxFlashes) {
isFlashing = false;
return;
}

const colors = wire.geometry.attributes.color.array;
const isWhite = flashCount % 2 === 0;

for (let i = 0; i < colors.length; i += 3) {
colors[i] = isWhite ? 1 : 0;     // R
colors[i + 1] = isWhite ? 1 : 0; // G
colors[i + 2] = 1;               // B (always 1 for white or blue)
}

wire.geometry.attributes.color.needsUpdate = true;
flashCount++;

setTimeout(flash, flashDuration);
}

flash();
}

function createWire(level = 1) {
// Remove old wire if it exists
if (wire) {
scene.remove(wire);
if (wire.geometry) wire.geometry.dispose();
}

const points = [];
const segments = 200;
const radius = 0.75;

// Add rotation offset for different levels
const rotationOffset = level === 2 ? Math.PI / 5.3 : 
level === 3 ? Math.PI / 1.6 : 
level === 4 ? Math.PI / 6.3 : 
level === 5 ? Math.PI / 1.1 : 0;

for (let i = 0; i <= segments; i++) {
const t = i / segments;
const angle = t * Math.PI * 2;

let waveX, waveY, waveZ, x, y, z;

if (level === 1) {
      // Test level - perfectly smooth circular wire
      x = Math.cos(angle) * radius;
      y = 1.4; // Fixed height
      z = Math.sin(angle) * radius;
    }

if (level === 0) {
// Level 1 wire pattern
waveX = Math.sin(angle * 8) * 0.05;
waveY = Math.cos(angle * 6) * 0.05;
x = (Math.cos(angle) * radius) + waveX;
y = 1.4 + waveY;
z = (Math.sin(angle) * radius) + waveX;
} 
else if (level === 2) {
// Level 2 wire pattern 
waveX = Math.sin(angle * 7) * 0.07 + Math.cos(angle * 3) * 0.04;
waveY = Math.cos(angle * 5) * 0.08 + Math.sin(angle * 9) * 0.03;
waveZ = Math.sin(angle * 6) * 0.07 + Math.cos(angle * 4) * 0.05;

// Create gentle undulations in height
const heightVar = Math.sin(angle * 3) * 0.06;

const rotatedAngle = angle + rotationOffset;
// Create an elliptical path 
x = (Math.cos(rotatedAngle) * radius * (1 + Math.sin(angle * 2) * 0.1)) + waveX;
y = 1.4 + waveY + heightVar;
z = (Math.sin(rotatedAngle) * radius * (1 + Math.cos(angle * 2) * 0.08)) + waveZ;
}
else if (level === 3) {
// Level 3 wire pattern
waveX = Math.sin(angle * 10) * 0.08;
waveY = Math.cos(angle * 8) * 0.08 + Math.sin(angle * 16) * 0.03;
waveZ = Math.sin(angle * 12) * 0.06;

const rotatedAngle = angle + rotationOffset;
x = (Math.cos(rotatedAngle) * radius) + waveX;
y = 1.4 + waveY;
z = (Math.sin(rotatedAngle) * radius) + waveZ;
}
else if (level === 4) {
// Level 4 wire pattern - most complex but still navigable

// Use prime number frequencies for less predictable patterns
waveX = Math.sin(angle * 11) * 0.07 + Math.cos(angle * 5) * 0.05;
waveY = Math.cos(angle * 7) * 0.09 + Math.sin(angle * 13) * 0.04;
waveZ = Math.sin(angle * 17) * 0.06 + Math.cos(angle * 3) * 0.07;

// Add some controlled chaos with sectional variations
// Divide the wire into sections with different behaviors
const section = Math.floor(angle / (Math.PI/2)); // 0-3 sections

// Base Y position that's consistent across all sections
y = 1.4 + waveY + Math.sin(angle * 2) * 0.07;

// Apply section-specific modifications to y-coordinate
const sectionFactor = section === 0 ? t * 4 : 
section === 1 ? (t - 0.25) * 4 :
section === 2 ? (t - 0.5) * 4 :
(t - 0.75) * 4;

if (section === 0) {
// First quarter - spiral up - add to base y
y += (sectionFactor * 0.15);
} else if (section === 3) {
// Fourth quarter - smooth transition back
// Use a sine curve for smooth transition
y += Math.sin(sectionFactor * Math.PI) * 0.08;
}

// Create smooth transition variations in radius
const radiusVar = 1 + 0.15 * Math.sin(angle * 2) - 0.05 * Math.cos(angle * 5);

const rotatedAngle = angle + rotationOffset;
x = (Math.cos(rotatedAngle) * radius * radiusVar) + waveX;
// y is already set above
z = (Math.sin(rotatedAngle) * radius * radiusVar) + waveZ;
}

else if (level === 5) {
  // Level 5 - challenging but navigable
  // Use moderate frequency combinations
  waveX = Math.sin(angle * 9) * 0.07 + Math.cos(angle * 5) * 0.05;
  waveY = Math.cos(angle * 7) * 0.08 + Math.sin(angle * 4) * 0.06;
  waveZ = Math.sin(angle * 6) * 0.07 + Math.cos(angle * 3) * 0.05;

  // Create gentle undulation with variable height
  const heightFactor = Math.sin(angle * 2) * 0.15;
  y = 1.4 + waveY + heightFactor;
  
  // Create interesting path with 4 distinct sections
  const section = Math.floor(angle / (Math.PI/2)); // 0-3 sections
  const sectionFactor = section === 0 ? t * 4 : 
                        section === 1 ? (t - 0.25) * 4 :
                        section === 2 ? (t - 0.5) * 4 : 
                        (t - 0.75) * 4;
  
  // Section-specific modifications
  if (section === 0) {
    // First quarter - gradual ascent
    y += Math.sin(sectionFactor * Math.PI * 0.5) * 0.12;
  } else if (section === 1) {
    // Second quarter - oscillating path
    waveX += Math.sin(sectionFactor * Math.PI * 3) * 0.06;
    waveZ += Math.cos(sectionFactor * Math.PI * 3) * 0.06;
  } else if (section === 2) {
    // Third quarter - gentle descent with wider radius
    y -= Math.sin(sectionFactor * Math.PI * 0.5) * 0.12;
    waveX *= 1.2;
    waveZ *= 1.2;
  } else {
    // Fourth quarter - smooth transition back to start
    waveX *= (1.2 - sectionFactor * 0.2);
    waveZ *= (1.2 - sectionFactor * 0.2);
  }

  // Add some controlled radius variation
  const radiusVar = 1 + Math.sin(angle * 2) * 0.1;
  
  const rotatedAngle = angle + rotationOffset;
  x = (Math.cos(rotatedAngle) * radius * radiusVar) + waveX;
  // y is already set above
  z = (Math.sin(rotatedAngle) * radius * radiusVar) + waveZ;
}

points.push(new THREE.Vector3(x, y, z));
}

wirePoints = points;
const geometry = new THREE.BufferGeometry().setFromPoints(points);
const colors = new Float32Array(points.length * 3);
for (let i = 0; i < points.length; i++) {
colors[i * 3] = 1; // R
colors[i * 3 + 1] = 0; // G
colors[i * 3 + 2] = 1; // B
}
geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
wireMaterial = new THREE.LineBasicMaterial({ vertexColors: true, linewidth: 7 });

wire = new THREE.Line(geometry, wireMaterial);
scene.add(wire);

console.log(`Wire for level ${level} created:`, wire);
return wire;
}

function explodeRing() {
  if (isExploding) return; // Prevent multiple explosions
  isExploding = true;
  explosionStartTime = Date.now();
  
  // Hide the original ring
  ring.visible = false;
  
  // Create fragments
  const segments = 20;
  for (let i = 0; i < segments; i++) {
    // Create fragment geometry (smaller than the original ring)
    const fragGeometry = new THREE.TorusGeometry(0.075, 0.00625, 8, 6, Math.PI * 2 / segments);
    const fragMaterial = new THREE.MeshStandardMaterial({ 
      color: 0x00ff00, 
      emissive: 0x00ff00, 
      emissiveIntensity: 1.0, 
      metalness: 1.0, 
      roughness: 0.0 
    });
    const fragment = new THREE.Mesh(fragGeometry, fragMaterial);
    
    // Position and rotate to match the original ring
    fragment.position.copy(ring.position);
    fragment.rotation.copy(ring.rotation);
    
    // Rotate fragment to correct position in the ring
    fragment.rotateOnAxis(new THREE.Vector3(0, 1, 0), (i / segments) * Math.PI * 2);
    
    // Add explosion velocity - direction slightly outward from the center
    const angle = (i / segments) * Math.PI * 2;
    const direction = new THREE.Vector3(Math.cos(angle), 0.2, Math.sin(angle));
    direction.normalize();
    
    fragment.userData.velocity = direction.multiplyScalar(0.02 + Math.random() * 0.02);
    fragment.userData.rotationSpeed = {
      x: (Math.random() - 0.5) * 0.2,
      y: (Math.random() - 0.5) * 0.2,
      z: (Math.random() - 0.5) * 0.2
    };
    
    // Add to scene and array
    scene.add(fragment);
    explosionFragments.push(fragment);
  }
}

function onWindowResize() {
camera.aspect = window.innerWidth / window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth, window.innerHeight);
}

function checkCollision() {
const ringVertices = ring.geometry.attributes.position.array;
const ringMatrixWorld = ring.matrixWorld;
const thresholdDistance = 0.01; // Adjust this value as needed

for (let i = 0; i < ringVertices.length; i += 3) {
const vertex = new THREE.Vector3(ringVertices[i], ringVertices[i + 1], ringVertices[i + 2]);
vertex.applyMatrix4(ringMatrixWorld);

for (let j = 0; j < wirePoints.length; j++) {
const distance = vertex.distanceTo(wirePoints[j]);
if (distance < thresholdDistance) {
console.log('Collision detected');
return true;
}
}
}

return false;
}

function onSelectStart(event) {
  const controllerPosition = event.target.position;
  
  // Check for button interactions first if game is completed OR keyboard is active
  if (gameCompletionMeshes.length > 0 || keyboardActive) {
    const raycaster = new THREE.Raycaster();
    const direction = new THREE.Vector3(0, 0, -1);
    direction.applyQuaternion(event.target.quaternion);
    raycaster.set(controllerPosition, direction);
    
       // Use BOTH arrays for detection
       const interactiveObjects = [
      ...gameCompletionMeshes.filter(mesh => mesh.userData && mesh.userData.isButton),
      ...keyboardMeshes.filter(mesh => mesh.userData && mesh.userData.isButton)
    ];
     
    const buttonIntersects = raycaster.intersectObjects(interactiveObjects, true); // Added true to check children

    console.log('Button intersects:', buttonIntersects.length);
    
    if (buttonIntersects.length > 0) {
  const buttonObject = buttonIntersects[0].object;
  // Make sure we're working with the button itself, not a child (like text)
 const button = buttonObject.userData.isButton ? buttonObject : 
                     buttonObject.parent && buttonObject.parent.userData && 
                     buttonObject.parent.userData.isButton ? buttonObject.parent : null;
      
      if (button && (button.userData.buttonType === 'letter' || 
          button.userData.buttonType === 'space' || 
          button.userData.buttonType === 'backspace' || 
          button.userData.buttonType === 'submit')) {
    // Use the centralized handler for keyboard buttons
    handleKeyPress(button);
    return;
  }
  else if (button.userData.buttonType === 'restart') {
    restartGame();
    triggerHapticFeedbackByHandedness('left', 0.4, 100);
    triggerHapticFeedbackByHandedness('right', 0.4, 100);
    return;
  }
  else if (button.userData.buttonType === 'quit') {
    // Exit VR session
    if (renderer.xr.isPresenting) {
      renderer.xr.getSession().end();
      triggerHapticFeedbackByHandedness('left', 0.6, 150);
      triggerHapticFeedbackByHandedness('right', 0.6, 150);
    }
    return;
  }
}
}

// handle ring grabbing if no UI element was interacted with
const ringBox = new THREE.Box3().setFromObject(ring);
const sphereBox1 = new THREE.Sphere(sphere1.position, 0.05);
const sphereBox2 = new THREE.Sphere(sphere2.position, 0.05);

if (!gameCompleted) {
if (ringBox.intersectsSphere(sphereBox1) && event.target === controller1) {
grabbed = true;
grabbingController = controller1;
grabOffset.copy(ring.position).sub(controller1.position);
grabRotationOffset.copy(controller1.quaternion).invert().multiply(ring.quaternion);
if (startTime === null) {
startTime = Date.now() - elapsedTime;
}
} else if (ringBox.intersectsSphere(sphereBox2) && event.target === controller2) {
grabbed = true;
grabbingController = controller2;
grabOffset.copy(ring.position).sub(controller2.position);
grabRotationOffset.copy(controller2.quaternion).invert().multiply(ring.quaternion);
if (startTime === null) {
startTime = Date.now() - elapsedTime;
}
}
}
}

function onSelectEnd(event) {
if (event.target === grabbingController) {
grabbed = false;
grabbingController = null;
}
}

// Add the restartGame function
function restartGame() {
  // Clean up game completion meshes
  gameCompletionMeshes.forEach(mesh => {
    scene.remove(mesh);
    if (mesh.geometry) mesh.geometry.dispose();
    if (mesh.material) mesh.material.dispose();
  });
  gameCompletionMeshes = [];
  
  // Reset game state
  currentLevel = 1;
  levelTimes = [];
  startTime = null;
  elapsedTime = 0;
  
  // Show ring and reset position
  gameCompleted = false;
  ring.visible = true;
  ring.position.copy(ringStartPosition);
  ring.rotation.set(0, Math.PI / 2, 0);
  
  // Create new wire for level 1
  wire = createWire(currentLevel);
  wire.visible = true;
  
  // Reset the level text
  if (textMesh && font) {
    textMesh.geometry.dispose();
    textMesh.geometry = new THREE.TextGeometry(`LEVEL ${currentLevel}/5`, { font: font, size: 0.02, height: 0.005 });
    textMesh.geometry.computeBoundingBox();
    const centerOffset = -0.5 * (textMesh.geometry.boundingBox.max.x - textMesh.geometry.boundingBox.min.x);
    textMesh.position.set(centerOffset, 2.0, -0.75);
    scene.add(textMesh);
  }
  
  // Reset and show timer
  if (timerMesh && timerFont) {
    timerMesh.geometry.dispose();
    timerMesh.geometry = new THREE.TextGeometry('0:00:000', {
      font: timerFont,
      size: 0.02,
      height: 0.005,
    });
    timerMesh.visible = true;
    timerMesh.geometry.computeBoundingBox();
    const timerCenterOffset = -0.5 * (timerMesh.geometry.boundingBox.max.x - timerMesh.geometry.boundingBox.min.x);
    timerMesh.position.set(ring.position.x + timerCenterOffset, ring.position.y + 0.1, ring.position.z);
  }
  
  // Play chime sound to indicate restart
  chimeSound.play().catch(error => console.log('Sound play error:', error));
}

function animate() {
renderer.setAnimationLoop(render);
}
 
  function handleKeyPress(button) {
  // Visual feedback
  if (button.material && button.userData.pressColor) {
    const originalColor = button.material.color.getHex();
    button.material.color.setHex(button.userData.pressColor);
    
    // Reset color after short delay
    setTimeout(() => {
      if (button.material) {
        button.material.color.setHex(button.userData.hoverColor || button.userData.defaultColor);
      }
    }, 150);
  }
  
  // Process button action
  if (button.userData.buttonType === 'letter' && !nameEntered) {
    // Add letter if under max length
    if (playerName.length < maxNameLength) {
      playerName += button.userData.letter;
      updateNameDisplay(button.parent);
      triggerHapticFeedbackByHandedness('left', 0.3, 50);
      triggerHapticFeedbackByHandedness('right', 0.3, 50);
    }
  } 
  else if (button.userData.buttonType === 'space' && !nameEntered) {
    // Add space if under max length
    if (playerName.length < maxNameLength) {
      playerName += ' ';
      updateNameDisplay(button.parent);
      triggerHapticFeedbackByHandedness('left', 0.2, 40);
      triggerHapticFeedbackByHandedness('right', 0.2, 40);
    }
  }
  else if (button.userData.buttonType === 'backspace' && !nameEntered) {
    // Remove the last letter
    if (playerName.length > 0) {
      playerName = playerName.slice(0, -1);
      updateNameDisplay(button.parent);
      triggerHapticFeedbackByHandedness('left', 0.2, 40);
      triggerHapticFeedbackByHandedness('right', 0.2, 40);
    }
  }

  else if (button.userData.buttonType === 'submit' && !nameEntered && playerName.length > 0) {
  // Submit score to leaderboard
  nameEntered = true;
  
  if (gameCompleted) {
    // If game is complete, submit full game score
    submitScore(playerName, levelTimes);
    fetchLeaderboard();
  } else {
    // If individual level, save just that level record
    saveLevelRecord(currentLevel, levelTimes[currentLevel-1], playerName);
  }
  
  // Clear any cursor blink interval
  if (initialsDisplayMesh && initialsDisplayMesh.userData.blinkInterval) {
    clearInterval(initialsDisplayMesh.userData.blinkInterval);
    initialsDisplayMesh.userData.blinkInterval = null;
  }
  
  triggerHapticFeedbackByHandedness('left', 0.5, 100);
  triggerHapticFeedbackByHandedness('right', 0.5, 100);
  
  // Hide keyboard after submission
  button.parent.visible = false;
  hideControllerRays();
  keyboardActive = false;
  
  // If mid-game, continue to next level
  if (!gameCompleted) {
    proceedToNextLevel();
  }
}
}

// Function to check if a level time is a record
function checkIfNewRecord(levelIndex, levelTime, callback) {
  // Get current best time from database
  const levelRef = firebase.database().ref(`records/level${levelIndex + 1}`);
  levelRef.once('value', snapshot => {
    const record = snapshot.val();
    // If no record exists or new time is better, it's a record
    const isRecord = !record || levelTime < record.time;
    callback(isRecord);
  });
}

// Function to save individual level records
function saveLevelRecord(levelNumber, time, playerName) {
  // Save to the database
  const levelRef = firebase.database().ref(`records/level${levelNumber}`);
  levelRef.set({
    playerName: playerName,
    time: time,
    date: Date.now()
  });
}

// Function to proceed to next level (extracted from victory function)
function proceedToNextLevel() {
  // Clean up any notification meshes
  gameCompletionMeshes.forEach(mesh => {
    if (mesh.userData && mesh.userData.isNotification) {
      scene.remove(mesh);
    }
  });
  
  ring.visible = false;
  transitionImmunity = true;
  setTimeout(() => {
    currentLevel++;
    // Update the level text
    if (textMesh && font) {
      textMesh.geometry.dispose();
      textMesh.geometry = new THREE.TextGeometry(`LEVEL ${currentLevel}/5`, 
        { font: font, size: 0.02, height: 0.005 });
      textMesh.geometry.computeBoundingBox();
    }

    // Create the new wire
    wire = createWire(currentLevel);

    // Reset the ring position
    ring.position.copy(ringStartPosition);
    ring.rotation.set(0, Math.PI / 2, 0);

    // Keep ring invisible until we're sure it's safe
    setTimeout(() => {
      ring.visible = true;
      transitionImmunity = false;
    }, 100);

    // Reset timer for next level
    elapsedTime = 0;
    grabbed = false;
    grabbingController = null;

    // Reset timer display
    if (timerMesh && timerFont) {
      timerMesh.geometry.dispose();
      timerMesh.geometry = new THREE.TextGeometry('0:00:000', {
        font: timerFont, size: 0.02, height: 0.005,
      });
      timerMesh.geometry.computeBoundingBox();
      const timerCenterOffset = -0.5 * (timerMesh.geometry.boundingBox.max.x - timerMesh.geometry.boundingBox.min.x);
      timerMesh.position.set(ring.position.x + timerCenterOffset, ring.position.y + 0.1, ring.position.z);
    }
  }, 2000);
}


// implement keyboard hover effects
function updateKeyboardHoverState() {
  // Only check if keyboard is active
  if (!keyboardActive) return;
  
  // Reset previously hovered button
  if (hoveredButton) {
    if (hoveredButton.material && hoveredButton.userData.defaultColor) {
      hoveredButton.material.color.setHex(hoveredButton.userData.defaultColor);
    }
    hoveredButton = null;
  }

  // Check both controllers
  [controller1, controller2].forEach(controller => {
    if (!controller) return;
    
    const raycaster = new THREE.Raycaster();
    const direction = new THREE.Vector3(0, 0, -1);
    direction.applyQuaternion(controller.quaternion);
    raycaster.set(controller.position, direction);
    
    // Get all keyboard button objects
    const buttonObjects = keyboardMeshes.filter(mesh => 
      mesh.userData && mesh.userData.isButton);
    
    const intersects = raycaster.intersectObjects(buttonObjects, true);
    
    if (intersects.length > 0) {
      // Get the actual button (might be a child of a group)
      const intersectedObj = intersects[0].object;
      const button = intersectedObj.userData.isButton ? 
                    intersectedObj : 
                    findButtonParent(intersectedObj);
      
      if (button && button.material) {
        // Apply hover color based on userData
        if (button.userData.hoverColor) {
          button.material.color.setHex(button.userData.hoverColor);
        } else {
          // Default hover color
          button.material.color.set(0x4477ff);
        }
        hoveredButton = button;
      }
    }
  });
}

// Helper function to find button parent
function findButtonParent(obj) {
  let current = obj;
  while (current && !current.userData.isButton) {
    current = current.parent;
  }
  return current;
}

function render() {
// Update sphere positions to match controller positions
if (controller1 && controller2) {
sphere1.position.copy(controller1.position);
sphere2.position.copy(controller2.position);
}

// Check for collisions
if (!isExploding && !transitionImmunity && checkCollision()) {
    handleCollision();
  }

// Move ring with the grabbing controller while maintaining the offset
if (grabbed && grabbingController) {
ring.position.copy(grabbingController.position).add(grabOffset);
ring.quaternion.copy(grabbingController.quaternion).multiply(grabRotationOffset); // Update ring rotation to match controller rotation

// Hide the spheres when the ring is grabbed
sphere1.visible = false;
sphere2.visible = false;
} else {
// Show the spheres when the ring is not grabbed
sphere1.visible = true;
sphere2.visible = true;
}

// Keep the text and timer above the ring and billboarded to face the player
if (textMesh) {
textMesh.position.set(ring.position.x, ring.position.y + 0.2, ring.position.z);
textMesh.geometry.computeBoundingBox();
const centerOffset = -0.5 * (textMesh.geometry.boundingBox.max.x - textMesh.geometry.boundingBox.min.x);
textMesh.position.x += centerOffset;
textMesh.lookAt(camera.position);
}

// Update timer with seconds:milliseconds format and check time limit
if (startTime !== null && timerFont) {
elapsedTime = Date.now() - startTime;

const minutes = Math.floor(elapsedTime / 60000);
const seconds = Math.floor((elapsedTime % 60000) / 1000);
const milliseconds = Math.floor(elapsedTime % 1000);
const timerText = `${minutes}:${seconds.toString().padStart(2, '0')}:${milliseconds.toString().padStart(3, '0')}`;

// Update timer text
if (timerMesh && timerMesh.geometry) {
timerMesh.geometry.dispose();
timerMesh.geometry = new THREE.TextGeometry(timerText, {
font: timerFont,
size: 0.02,
height: 0.005,
});
timerMesh.geometry.computeBoundingBox();
const timerCenterOffset = -0.5 * (timerMesh.geometry.boundingBox.max.x - timerMesh.geometry.boundingBox.min.x);
timerMesh.position.set(ring.position.x + timerCenterOffset, ring.position.y + 0.1, ring.position.z);
timerMesh.lookAt(camera.position);
}
}

// Ensure timer text stays attached to the ring and faces the player
if (timerMesh) {
timerMesh.position.set(ring.position.x, ring.position.y + 0.15, ring.position.z);
const timerCenterOffset = -0.5 * (timerMesh.geometry.boundingBox.max.x - timerMesh.geometry.boundingBox.min.x);
timerMesh.position.x += timerCenterOffset;
timerMesh.lookAt(camera.position);
}

// Check for wire collision and update wire color
updateWireColor();

if (confettiStartTime !== null) {
  const elapsed = Date.now() - confettiStartTime;
  
  if (elapsed < 10000) { // 10 seconds of confetti
    for (let i = 0; i < confettiParticles.length; i++) {
      const confetti = confettiParticles[i];
      
      // Add gravity and update position
      confetti.userData.velocity.y -= 0.0003;
      confetti.position.add(confetti.userData.velocity);
      
      // Update rotation
      confetti.rotation.x += confetti.userData.rotationSpeed.x;
      confetti.rotation.y += confetti.userData.rotationSpeed.y;
      confetti.rotation.z += confetti.userData.rotationSpeed.z;
      
      // Add fluttering effect
      confetti.userData.velocity.x += Math.sin(elapsed * 0.01 + confetti.userData.flutter) * 0.0001;
      confetti.userData.velocity.z += Math.cos(elapsed * 0.01 + confetti.userData.flutter) * 0.0001;
    }
  } else {
    // Clean up confetti
    for (let i = 0; i < confettiParticles.length; i++) {
      scene.remove(confettiParticles[i]);
      confettiParticles[i].material.dispose();
    }
    confettiParticles = [];
    confettiStartTime = null;
  }
}

if (isExploding) {
    const explosionElapsed = Date.now() - explosionStartTime;
    const explosionDuration = 2000; // 2 seconds
    
    if (explosionElapsed < explosionDuration) {
      // Update fragment positions and rotations
      for (let i = 0; i < explosionFragments.length; i++) {
        const fragment = explosionFragments[i];
        fragment.position.add(fragment.userData.velocity);
        fragment.rotation.x += fragment.userData.rotationSpeed.x;
        fragment.rotation.y += fragment.userData.rotationSpeed.y;
        fragment.rotation.z += fragment.userData.rotationSpeed.z;
        
        // Add gravity effect
        fragment.userData.velocity.y -= 0.0005;
      }
    } else {
      // Clean up explosion
      for (let i = 0; i < explosionFragments.length; i++) {
        const fragment = explosionFragments[i];
        scene.remove(fragment);
        if (fragment.geometry) fragment.geometry.dispose();
        if (fragment.material) fragment.material.dispose();
      }
      
      // Reset
      explosionFragments = [];
      isExploding = false;
      
      // Show and reset ring
      if (!gameCompleted) {
      ring.visible = true;
      ring.position.copy(ringStartPosition);
      ring.rotation.set(0, Math.PI / 2, 0);
      }

        // Reset timer display to 0:00:000
    if (timerMesh && timerFont) {
      timerMesh.geometry.dispose();
      timerMesh.geometry = new THREE.TextGeometry('0:00:000', {
        font: timerFont,
        size: 0.02,
        height: 0.005,
      });
      timerMesh.geometry.computeBoundingBox();
      const timerCenterOffset = -0.5 * (timerMesh.geometry.boundingBox.max.x - timerMesh.geometry.boundingBox.min.x);
      timerMesh.position.set(ring.position.x + timerCenterOffset, ring.position.y + 0.1, ring.position.z);
      timerMesh.lookAt(camera.position);
    
    }
  }
  }
  // Check for keyboard button hover states
if (gameCompleted) {
  updateKeyboardHoverState();
}

if (keyboardActive) {
  updateKeyboardHoverState();
}

renderer.render(scene, camera);
}

function updateWireColor() {
const ringBox = new THREE.Box3().setFromObject(ring);
const colors = wire.geometry.attributes.color.array;

// Calculate a dynamic pointBox size based on the ring's scale
const ringScale = ring.scale.x; // Assuming uniform scale
const pointBoxSize = 0.01 * ringScale; // Adjust the multiplier as needed

for (let i = 0; i < wirePoints.length; i++) {
const point = wirePoints[i];
const pointBox = new THREE.Box3().setFromCenterAndSize(point, new THREE.Vector3(pointBoxSize, pointBoxSize, pointBoxSize));

if (ringBox.intersectsBox(pointBox)) {
// Color this segment blue
colors[i * 3] = 0;     // R
colors[i * 3 + 1] = 0; // G
colors[i * 3 + 2] = 1; // B
}
//No ELSE, so color will remain unless reset
}

wire.geometry.attributes.color.needsUpdate = true;

// Check if the entire wire is blue (victory condition)
let allBlue = true;
for (let i = 0; i < wirePoints.length; i++) {
if (colors[i * 3] !== 0 || colors[i * 3 + 1] !== 0 || colors[i * 3 + 2] !== 1) {
allBlue = false;
break;
}
}
if (allBlue && !gameCompleted) {
victory();
}
}

function handleCollision() {
explodeRing(); // Add explosion effect
contactSound.play().catch(error => console.log('Sound play error:', error)); // Play contact sound
resetWireColor(); // Reset wire color to pink
triggerHapticFeedbackByHandedness('left', 1.0, 80); // haptic feedback
triggerHapticFeedbackByHandedness('right', 1.0, 80);  // haptic feedback
grabbed = false; // Override the grab
grabbingController = null; // Clear the grabbing controller

// Reset timer but don't change level
elapsedTime = 0;
startTime = null;
}

function resetWireColor() {
const colors = wire.geometry.attributes.color.array;
for (let i = 0; i < colors.length; i += 3) {
colors[i] = 1; // R
colors[i + 1] = 0; // G
colors[i + 2] = 1; // B
}
wire.geometry.attributes.color.needsUpdate = true;
}

// Helper function to format time as SS:MMM
function formatTime(ms) {
const minutes = Math.floor(ms / 60000);  
const seconds = Math.floor((ms % 60000) / 1000);
const milliseconds = Math.floor(ms % 1000);
return `${minutes}:${seconds.toString().padStart(2, '0')}:${milliseconds.toString().padStart(3, '0')}`;
}

function createConfetti() {
  confettiStartTime = Date.now();
  const confettiGeometry = new THREE.PlaneGeometry(0.015, 0.015);
  const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
  
  // Create 3000 confetti particles
  for (let i = 0; i < 1000; i++) {
    const material = new THREE.MeshBasicMaterial({ 
      color: colors[Math.floor(Math.random() * colors.length)], 
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.9
    });
    
    const confetti = new THREE.Mesh(confettiGeometry, material);
    // Position around center with slight spread
    confetti.position.set(
      ring.position.x + (Math.random() - 0.5) * 2,
      ring.position.y + Math.random() * 1.5,
      ring.position.z + (Math.random() - 0.5) * 2
    );
    
    confetti.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
    
    // Physics properties
    confetti.userData.velocity = new THREE.Vector3(
      (Math.random() - 0.5) * 0.03,
      Math.random() * 0.03,
      (Math.random() - 0.5) * 0.03
    );
    confetti.userData.rotationSpeed = new THREE.Vector3(
      (Math.random() - 0.5) * 0.15,
      (Math.random() - 0.5) * 0.15,
      (Math.random() - 0.5) * 0.15
    );
    confetti.userData.flutter = Math.random() * 10;
    
    scene.add(confetti);
    confettiParticles.push(confetti);
  }
}

function showNewRecordNotification(recordTime) {
  // Create record notification text
  const recordGeometry = new THREE.TextGeometry('NEW RECORD!', { 
    font: font, 
    size: 0.05, // Slightly larger
    height: 0.008 
  });
  const recordMaterial = new THREE.MeshStandardMaterial({ 
    color: 0xffff00,
    emissive: 0xffff00,
    emissiveIntensity: 0.7 // Brighter
  });
  const recordMesh = new THREE.Mesh(recordGeometry, recordMaterial);
  recordGeometry.computeBoundingBox();
  const recordOffset = -0.5 * (recordGeometry.boundingBox.max.x - recordGeometry.boundingBox.min.x);
  recordMesh.position.set(recordOffset, 1.5, -0.75);
  scene.add(recordMesh);
  
  // Show the time
  const timeGeometry = new THREE.TextGeometry(`Time: ${formatTime(recordTime)}`, { 
    font: font, 
    size: 0.035, 
    height: 0.005 
  });
  const timeMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x00ffff,
    emissive: 0x00ffff, 
    emissiveIntensity: 0.3 
  });
  const timeMesh = new THREE.Mesh(timeGeometry, timeMaterial);
  timeGeometry.computeBoundingBox();
  const timeOffset = -0.5 * (timeGeometry.boundingBox.max.x - timeGeometry.boundingBox.min.x);
  timeMesh.position.set(timeOffset, 1.4, -0.75);
  scene.add(timeMesh);
  
  // Add "Enter your name:" text
  const promptGeometry = new THREE.TextGeometry('Enter your name:', { 
    font: font, 
    size: 0.03, 
    height: 0.005 
  });
  const promptMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
  const promptMesh = new THREE.Mesh(promptGeometry, promptMaterial);
  promptGeometry.computeBoundingBox();
  const promptOffset = -0.5 * (promptGeometry.boundingBox.max.x - promptGeometry.boundingBox.min.x);
  promptMesh.position.set(promptOffset, 1.3, -0.75);
  scene.add(promptMesh);
  
  // Store these for later cleanup and mark them as notifications
  recordMesh.userData.isNotification = true;
  timeMesh.userData.isNotification = true;
  promptMesh.userData.isNotification = true;
  gameCompletionMeshes.push(recordMesh, timeMesh, promptMesh);
  
  // Make the record text blink
  let blinkCount = 0;
  const blinkInterval = setInterval(() => {
    recordMesh.visible = !recordMesh.visible;
    blinkCount++;
    if (blinkCount >= 10) {
      clearInterval(blinkInterval);
      recordMesh.visible = true;
    }
  }, 250);
}

// Submit score to Leaderboard 
function submitScore(playerName, levelTimes) {
  const totalTime = levelTimes.reduce((total, time) => total + time, 0);
  
  // Add to leaderboard
  leaderboardRef.push({
    playerName: playerName || 'Anonymous Player',
    totalTime: totalTime,
    levelTimes: levelTimes,
    date: Date.now()
  });
}

// Fetch and display top scores
function fetchLeaderboard() {
  leaderboardRef.orderByChild('totalTime').limitToFirst(10).once('value', snapshot => {
    const scores = [];
    snapshot.forEach(child => {
      scores.push({
        name: child.val().playerName,
        time: child.val().totalTime
      });
    });
    displayScores(scores); 
  });
}

// display leaderboard scores
function displayScores(scores) {
  // Remove any existing leaderboard display
  gameCompletionMeshes.forEach(mesh => {
    if (mesh.userData && mesh.userData.isLeaderboard) {
      scene.remove(mesh);
    }
  });
  
  // Create leaderboard header
  const headerGeometry = new THREE.TextGeometry('TOP SCORES', { 
    font: font, 
    size: 0.03, 
    height: 0.005 
  });
  const headerMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00 });
  const headerMesh = new THREE.Mesh(
    headerGeometry, 
    headerMaterial
  );
  headerGeometry.computeBoundingBox();
  const headerOffset = -0.5 * (headerGeometry.boundingBox.max.x - headerGeometry.boundingBox.min.x);
  headerMesh.position.set(headerOffset, 0.65, -0.65);
  headerMesh.userData.isLeaderboard = true;
  scene.add(headerMesh);
  gameCompletionMeshes.push(headerMesh);
  
  // Display up to 5 scores
  scores.slice(0, 5).forEach((score, i) => {
    const scoreText = `${i+1}. ${score.name.substring(0, 10)} - ${formatTime(score.time)}`;
    const scoreGeometry = new THREE.TextGeometry(scoreText, { 
      font: font, 
      size: 0.02, 
      height: 0.005 
    });
    const scoreColor = score.name === playerName ? 0x00ffff : 0xffffff;
    const scoreMesh = new THREE.Mesh(
      scoreGeometry, 
      new THREE.MeshStandardMaterial({ color: scoreColor })
    );
    scoreGeometry.computeBoundingBox();
    const scoreOffset = -0.5 * (scoreGeometry.boundingBox.max.x - scoreGeometry.boundingBox.min.x);
    scoreMesh.position.set(scoreOffset, 0.6 - (i * 0.05), -0.65);
    scoreMesh.userData.isLeaderboard = true;
    scene.add(scoreMesh);
    gameCompletionMeshes.push(scoreMesh);
  });
}

// fetch best times for each level
function fetchBestTimes(callback) {
  // Structure to store best times
  const bestTimes = {
    level1: { time: Number.MAX_VALUE, name: "" },
    level2: { time: Number.MAX_VALUE, name: "" },
    level3: { time: Number.MAX_VALUE, name: "" },
    level4: { time: Number.MAX_VALUE, name: "" },
    level5: { time: Number.MAX_VALUE, name: "" },
    total: { time: Number.MAX_VALUE, name: "" }
  };
  
  // Get all leaderboard entries
  leaderboardRef.once('value', snapshot => {
    snapshot.forEach(child => {
      const entry = child.val();
      
      // Check for total time record
      if (entry.totalTime && entry.totalTime < bestTimes.total.time) {
        bestTimes.total.time = entry.totalTime;
        bestTimes.total.name = entry.playerName || "Anonymous";
      }
      
      // Check each level time
      if (entry.levelTimes) {
        for (let i = 0; i < 5; i++) {
          if (entry.levelTimes[i] && entry.levelTimes[i] < bestTimes[`level${i+1}`].time) {
            bestTimes[`level${i+1}`].time = entry.levelTimes[i];
            bestTimes[`level${i+1}`].name = entry.playerName || "Anonymous";
          }
        }
      }
    });
    
    // Replace MAX_VALUE with null for any levels without records
    for (const key in bestTimes) {
      if (bestTimes[key].time === Number.MAX_VALUE) {
        bestTimes[key].time = null;
        bestTimes[key].name = "N/A";
      }
    }
    
    if (callback) callback(bestTimes);
  });
}

function victory() {
  if (startTime !== null && (!gameCompleted || currentLevel < 5)) {
    // Store the completion time for this level
    const levelTime = Date.now() - startTime;
    levelTimes[currentLevel - 1] = levelTime;
    startTime = null;

    if (textMesh) textMesh.visible = false; 
    if (timerMesh) timerMesh.visible = false;

    // Play victory sounds
    victorySound.play().catch(error => console.log('Sound play error:', error));
    applauseSound.play().catch(error => console.log('Sound play error:', error));
    triggerHapticFeedbackByHandedness('left', 0.5, 500); 
    triggerHapticFeedbackByHandedness('right', 0.5, 500);

    // Flash the wire white and blue
    flashWire(3, false);

    console.log(`Level ${currentLevel} completed in ${levelTime}ms`);
    
    // Check if this is a new record for this level
    checkIfNewRecord(currentLevel - 1, levelTime, function(isRecord) {
      if (isRecord) {
        // Create "NEW RECORD!" notification
        showNewRecordNotification(levelTime);
        
        // Create confetti effect
        createConfetti();
        
        // Show the keyboard for name entry
        playerName = ""; // Reset player name for new entry
        nameEntered = false;
        
        // Add slight delay before showing keyboard
        setTimeout(() => {
          const keyboard = createImprovedVirtualKeyboard();
          // Position keyboard appropriately
          if (keyboard) {
            keyboard.position.set(0, 1.2, -0.75);
          }
        }, 1500);
        
        // The game will continue after name submission in the handleKeyPress function
      } else {
        // If no record, continue normally
        proceedToNextLevel();
      }
    });
  }

else {
// Game complete! Show summary of times
gameCompleted = true;
const totalTime = levelTimes.reduce((total, time) => total + time, 0);

// Hide the ring and wire when game is complete
ring.visible = false;
wire.visible = false;

// Play grand finale sounds
longHornsSound.play().catch(error => console.log('Sound play error:', error));
longApplauseSound.play().catch(error => console.log('Sound play error:', error));

 // special game completion haptic pattern - alternating pulses
 const celebratePulses = () => {
    let count = 0;
    const interval = setInterval(() => {
      triggerHapticFeedbackByHandedness('left', 0.7, 100);
      triggerHapticFeedbackByHandedness('right', 0.7, 100);
      count++;
      if (count >= 5) clearInterval(interval);
    }, 300);
  };
  celebratePulses();

createConfetti(); // Add confetti effect

// Flash the wire more dramatically
flashWire(6, true);

// Fetch best times then create the completion display
fetchBestTimes(bestTimes => {
if (textMesh && font) {
textMesh.geometry.dispose();

// Create individual text meshes for each line of the summary
// Game complete text
const gameCompleteGeometry = new THREE.TextGeometry('GAME COMPLETE!', { 
      font: font, 
      size: 0.03, 
      height: 0.005 
    });
    const gameCompleteMesh = new THREE.Mesh(
      gameCompleteGeometry, 
      new THREE.MeshStandardMaterial({ color: 0xffff00 })
    );
    gameCompleteGeometry.computeBoundingBox();
    const completeOffset = -0.5 * (gameCompleteGeometry.boundingBox.max.x - gameCompleteGeometry.boundingBox.min.x);
    gameCompleteMesh.position.set(completeOffset, 1.5, -0.75);
    scene.add(gameCompleteMesh);
    gameCompletionMeshes.push(gameCompleteMesh);
    scoreSummaryMeshes = [gameCompleteMesh];

// Add column headers
const yourTimesGeometry = new THREE.TextGeometry('YOUR TIMES', { 
  font: font, 
  size: 0.025, 
  height: 0.005 
});
const yourTimesMesh = new THREE.Mesh(
  yourTimesGeometry, 
  new THREE.MeshStandardMaterial({ color: 0x00ffff })
);
yourTimesMesh.position.set(-0.35, 1.4, -0.75);
scene.add(yourTimesMesh);
gameCompletionMeshes.push(yourTimesMesh);
scoreSummaryMeshes.push(yourTimesMesh);

const recordTimesGeometry = new THREE.TextGeometry('RECORD TIMES', { 
  font: font, 
  size: 0.025, 
  height: 0.005 
});
const recordTimesMesh = new THREE.Mesh(
  recordTimesGeometry, 
  new THREE.MeshStandardMaterial({ color: 0xffff00 })
);
recordTimesMesh.position.set(0, 1.4, -0.75);
scene.add(recordTimesMesh);
gameCompletionMeshes.push(recordTimesMesh);
scoreSummaryMeshes.push(recordTimesMesh);

// column for record holders
const recordHoldersGeometry = new THREE.TextGeometry('RECORD HOLDERS', { 
  font: font, 
  size: 0.025, 
  height: 0.005 
});
const recordHoldersMesh = new THREE.Mesh(
  recordHoldersGeometry, 
  new THREE.MeshStandardMaterial({ color: 0xffff00 })
);
recordHoldersMesh.position.set(0.35, 1.4, -0.75); // Right column
scene.add(recordHoldersMesh);
gameCompletionMeshes.push(recordHoldersMesh);
scoreSummaryMeshes.push(recordHoldersMesh);

// Level rows
for (let i = 0; i < 5; i++) {
  const levelTime = levelTimes[i] || 0;
  const recordTime = bestTimes[`level${i+1}`];
  
  // Create level number label
  const levelLabelGeometry = new THREE.TextGeometry(`Level ${i+1}:`, { 
    font: font, 
    size: 0.02, 
    height: 0.005 
  });
  const levelLabelMesh = new THREE.Mesh(
    levelLabelGeometry, 
    new THREE.MeshStandardMaterial({ color: 0xffffff })
  );
  levelLabelMesh.position.set(-0.55, 1.35 - (i * 0.05), -0.75);
  scene.add(levelLabelMesh);
  gameCompletionMeshes.push(levelLabelMesh);
  scoreSummaryMeshes.push(levelLabelMesh);
  
  // Format player's time
  const playerTimeText = formatTime(levelTime);
  
  // Player time - left column
  const isNewLevelRecord = (levelTime > 0 && recordTime && levelTime <= recordTime);
  const playerTextColor = isNewLevelRecord ? 0x00ff00 : 0x00ffff;
  const playerTimeGeometry = new THREE.TextGeometry(playerTimeText, { 
    font: font, 
    size: 0.02, 
    height: 0.005 
  });
  const playerTimeMesh = new THREE.Mesh(
    playerTimeGeometry, 
    new THREE.MeshStandardMaterial({ 
      color: playerTextColor,
      emissive: isNewLevelRecord ? 0x00ff00 : 0,
      emissiveIntensity: 0.3
    })
  );
  playerTimeMesh.position.set(-0.35, 1.35 - (i * 0.05), -0.75);
  scene.add(playerTimeMesh);
  gameCompletionMeshes.push(playerTimeMesh);
  scoreSummaryMeshes.push(playerTimeMesh);
  
  // Format record time or show "N/A"
  const recordTimeText = recordTime ? formatTime(recordTime) : "N/A";
  
  // Record time - middle column
  const recordTimeGeometry = new THREE.TextGeometry(recordTimeText, { 
    font: font, 
    size: 0.02, 
    height: 0.005 
  });
  const recordTimeMesh = new THREE.Mesh(
    recordTimeGeometry, 
    new THREE.MeshStandardMaterial({ color: 0xffff00 })
  );
  recordTimeMesh.position.set(0, 1.35 - (i * 0.05), -0.75);
  scene.add(recordTimeMesh);
  gameCompletionMeshes.push(recordTimeMesh);
  scoreSummaryMeshes.push(recordTimeMesh);
}

// record holders - right column
  // Truncate name if too long
  const displayName = recordHolder ? 
    (recordHolder.length > 10 ? recordHolder.substring(0, 9) + "…" : recordHolder) : 
    "N/A";
  
  const recordHolderGeometry = new THREE.TextGeometry(displayName, { 
    font: font, 
    size: 0.02, 
    height: 0.005 
  });
  const recordHolderMesh = new THREE.Mesh(
    recordHolderGeometry, 
    new THREE.MeshStandardMaterial({ color: 0xffff00 })
  );
  recordHolderMesh.position.set(0.35, 1.35 - (i * 0.05), -0.75);
  scene.add(recordHolderMesh);
  gameCompletionMeshes.push(recordHolderMesh);
  scoreSummaryMeshes.push(recordHolderMesh);
}

// Total label
const totalLabelGeometry = new THREE.TextGeometry("Total:", { 
  font: font, 
  size: 0.025, 
  height: 0.005 
});
const totalLabelMesh = new THREE.Mesh(
  totalLabelGeometry, 
  new THREE.MeshStandardMaterial({ color: 0xffffff })
);
totalLabelMesh.position.set(-0.55, 1.1, -0.75);
scene.add(totalLabelMesh);
gameCompletionMeshes.push(totalLabelMesh);
scoreSummaryMeshes.push(totalLabelMesh);

// Player total time
const totalRecordTime = bestTimes.total;
const isNewRecord = totalTime > 0 && (!totalRecordTime || totalTime <= totalRecordTime);
const playerTotalGeometry = new THREE.TextGeometry(formatTime(totalTime), { 
  font: font, 
  size: 0.025, 
  height: 0.005 
});
const playerTotalMesh = new THREE.Mesh(
  playerTotalGeometry, 
  new THREE.MeshStandardMaterial({ 
    color: isNewRecord ? 0x00ff00 : 0x00ffff,
    emissive: isNewRecord ? 0x00ff00 : 0,
    emissiveIntensity: isNewRecord ? 0.5 : 0
  })
);
playerTotalMesh.position.set(-0.35, 1.1, -0.75);
scene.add(playerTotalMesh);
gameCompletionMeshes.push(playerTotalMesh);
scoreSummaryMeshes.push(playerTotalMesh);

// Record total time
const recordTotalGeometry = new THREE.TextGeometry(totalRecordTime ? formatTime(totalRecordTime) : "N/A", { 
  font: font, 
  size: 0.025, 
  height: 0.005 
});
const recordTotalMesh = new THREE.Mesh(
  recordTotalGeometry, 
  new THREE.MeshStandardMaterial({ color: 0xffff00 })
);
recordTotalMesh.position.set(0, 1.1, -0.75);
scene.add(recordTotalMesh);
gameCompletionMeshes.push(recordTotalMesh);
scoreSummaryMeshes.push(recordTotalMesh);

// Add total record holder name
const totalRecordHolder = bestTimes.total.name;
const displayTotalHolder = totalRecordHolder ? 
  (totalRecordHolder.length > 10 ? totalRecordHolder.substring(0, 9) + "…" : totalRecordHolder) : 
  "N/A";

const totalHolderGeometry = new THREE.TextGeometry(displayTotalHolder, { 
  font: font, 
  size: 0.025, 
  height: 0.005 
});
const totalHolderMesh = new THREE.Mesh(
  totalHolderGeometry, 
  new THREE.MeshStandardMaterial({ color: 0xffff00 })
);
totalHolderMesh.position.set(0.35, 1.1, -0.75);
scene.add(totalHolderMesh);
gameCompletionMeshes.push(totalHolderMesh);
scoreSummaryMeshes.push(totalHolderMesh);

const newRecordMeshes = [];

// Add "NEW RECORD!" text if applicable
if (isNewRecord) {
    scene.remove(recordTotalMesh);
  const newRecordTextGeometry = new THREE.TextGeometry('NEW RECORD!', { 
    font: font, 
    size: 0.025, 
    height: 0.005 
  });
  const newRecordTextMesh = new THREE.Mesh(
    newRecordTextGeometry, 
    new THREE.MeshStandardMaterial({ 
      color: 0xffff00,
      emissive: 0xffff00,
      emissiveIntensity: 0.5
    })
  );
 
  newRecordTextMesh.position.set(0.12, 1.1, -0.75);
  scene.add(newRecordTextMesh);
  gameCompletionMeshes.push(newRecordTextMesh);
  scoreSummaryMeshes.push(newRecordTextMesh);

  // Add both player and new record meshes to blink array
  newRecordMeshes.push(playerTotalMesh, newRecordTextMesh);
}   

// Function to make new record meshes blink
function blinkNewRecords(meshes, times = 5) {
  if (meshes.length === 0) return;
  
  let count = 0;
  const interval = setInterval(() => {
    // Toggle visibility for blink effect
    meshes.forEach(mesh => {
      if (mesh.material) {
        mesh.visible = !mesh.visible;
      }
    });
    
    count++;
    if (count >= times * 2) { // Each blink is two state changes (on/off)
      clearInterval(interval);
      // Make sure meshes are visible when done
      meshes.forEach(mesh => {
        if (mesh.material) {
          mesh.visible = true;
        }
      });
    }
  }, 250); // Blink interval in ms
}
    
setTimeout(() => {
  blinkNewRecords(newRecordMeshes);
}, 1000);

// Show keyboard only if it's a new record
setTimeout(() => {
  showNameEntry(isNewRecord);
}, 3000); // Short delay to let player see the scores first

});
}
}

// use new keyboard 
function showNameEntry(isNewRecord) {
  // Only show keyboard if it's a new record
  if (!isNewRecord) {
    // If no record was set, just show a simple message and the restart/quit buttons
    const noRecordGeometry = new THREE.TextGeometry("Thanks for playing!", { 
      font: font, 
      size: 0.025, 
      height: 0.005 
    });
    const noRecordMesh = new THREE.Mesh(
      noRecordGeometry, 
      new THREE.MeshStandardMaterial({ color: 0xffffff })
    );
    noRecordGeometry.computeBoundingBox();
    const noRecordOffset = -0.5 * (noRecordGeometry.boundingBox.max.x - noRecordGeometry.boundingBox.min.x);
    noRecordMesh.position.set(noRecordOffset, 1.0, -0.75);
    scene.add(noRecordMesh);
    gameCompletionMeshes.push(noRecordMesh);
    
    // Just add restart and quit buttons
    addGameControlButtons();
    return;
  }

  // Create custom keyboard
  console.log("Using custom 3D keyboard");
  createImprovedVirtualKeyboard();
  
  // Add restart and quit buttons
  addGameControlButtons();
} 

// create the restart and quit buttons
function addGameControlButtons() {
  // Add Restart button
  const restartGeometry = new THREE.TextGeometry('RESTART', { font: font, size: 0.025, height: 0.005 });
  const restartMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 0.5 });
  const restartMesh = new THREE.Mesh(restartGeometry, restartMaterial);
  restartGeometry.computeBoundingBox();
  const restartWidth = restartGeometry.boundingBox.max.x - restartGeometry.boundingBox.min.x;
  const restartOffset = -0.5 * restartWidth;
  restartMesh.position.set(restartOffset - 0.1, 0.7, -0.75); // Positioned lower
  scene.add(restartMesh);
  gameCompletionMeshes.push(restartMesh);
  keyboardMeshes.push(restartMesh);

  // Create invisible box for restart button interaction
  const restartBox = new THREE.Mesh(
    new THREE.BoxGeometry(restartWidth + 0.05, 0.05, 0.01),
    new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 })
  );
  restartBox.position.copy(restartMesh.position);
  restartBox.position.y += 0.01; // Slight offset for better interaction
  scene.add(restartBox);
  restartBox.userData.isButton = true;
  restartBox.userData.buttonType = 'restart';
  gameCompletionMeshes.push(restartBox);
  keyboardMeshes.push(restartBox);

  // Add Quit button
  const quitGeometry = new THREE.TextGeometry('QUIT', { font: font, size: 0.025, height: 0.005 });
  const quitMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.5 });
  const quitMesh = new THREE.Mesh(quitGeometry, quitMaterial);
  quitGeometry.computeBoundingBox();
  const quitWidth = quitGeometry.boundingBox.max.x - quitGeometry.boundingBox.min.x;
  const quitOffset = -0.5 * quitWidth;
  quitMesh.position.set(quitOffset + 0.15, 0.7, -0.75); // Positioned lower
  scene.add(quitMesh);
  gameCompletionMeshes.push(quitMesh);
  keyboardMeshes.push(quitMesh);

  // Create invisible box for quit button interaction
  const quitBox = new THREE.Mesh(
    new THREE.BoxGeometry(quitWidth + 0.05, 0.05, 0.01),
    new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 })
  );
  quitBox.position.copy(quitMesh.position);
  quitBox.position.y += 0.01; // Slight offset for better interaction
  scene.add(quitBox);
  quitBox.userData.isButton = true;
  quitBox.userData.buttonType = 'quit';
  gameCompletionMeshes.push(quitBox);
  keyboardMeshes.push(quitBox);
}

     
</script>
</body>
</html>
