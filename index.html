<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Firefly Catcher VR</title>
        <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js",
        "three/examples/jsm/webxr/VRButton.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/VRButton.js",
        "three/examples/jsm/webxr/XRControllerModelFactory.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/XRControllerModelFactory.js"
      }
    }
    </script>
    <style>
       body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #000;
    }
    #container {
        position: absolute;
        width: 100%;
        height: 100%;
    }
    #gameInterface {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
    }
    #gameImage {
        width: 300px;
        height: 200px;
        border-radius: 8px;
        box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
    }
    #info {
        color: white;
        font-family: Arial, sans-serif;
        font-size: 18px;
        text-align: center;
        max-width: 500px;
        margin-bottom: 15px;
        text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
    }
    #startButton {
        padding: 12px 24px;
        font-size: 20px;
        background-color: #4CAF50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.3s;
    }
    #startButton:hover {
        background-color: #45a049;
        box-shadow: 0 0 15px rgba(76, 175, 80, 0.7);
    }
    </style>
</head>
<body>
  <div id="container"></div>
  <div id="gameInterface">
    <img id="gameImage" src="https://images.unsplash.com/photo-1566151449979-b5e3f3953da6?auto=format&fit=crop&w=300&h=200" alt="Fireflies glowing in the dark">
    <div id="info">Catch the fireflies and put them in matching color jars!</div>
    <button id="startButton">ENTER VR</button>
  </div>

  <script type="module">
        import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { VRButton } from 'three/examples/jsm/webxr/VRButton.js';
import { XRControllerModelFactory } from 'three/examples/jsm/webxr/XRControllerModelFactory.js';

        // Game variables
        let scene, camera, renderer, controls;
        let controllers = [];
        let controllerGrips = [];
        let controllerHemispheres = [];
        let fireflies = [];
        let jars = [];
        let clock = new THREE.Clock();
        let score = 0;
        let timeRemaining = 120; // 2 minutes
        let gameStarted = false;
        let gameEnded = false;
        
        // Firefly colors
        const fireflyColors = [
            new THREE.Color(0.8, 0.2, 0.8), // Purple
            new THREE.Color(0.2, 0.8, 0.2), // Green
            new THREE.Color(0.8, 0.8, 0.2)  // Yellow
        ];
        
        // Initialize the game
        function init() {
            // Create the scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.FogExp2(0x000000, 0.02);
            
            // Create the camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50);
            camera.position.set(0, 1.6, 3);
            
            // Create the renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.shadowMap.enabled = true;
            renderer.xr.enabled = true;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Add orbit controls for non-VR viewing
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 1, 0);
            controls.update();
            
            // Setup XR button
            const button = VRButton.createButton(renderer);
            document.getElementById('startButton').addEventListener('click', function() {
                document.body.appendChild(button);
                button.click();
                gameStarted = true;
                this.style.display = 'none';
                document.getElementById('info').style.display = 'none';
                setup();
            });
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Start the animation loop
            renderer.setAnimationLoop(animate);
        }
        
        // Setup the game environment
        function setup() {
    // Add ambient light - bluish violet for swamp atmosphere
    const ambientLight = new THREE.AmbientLight(0x2A1E5C, 0.2); // Inky bluish-violet, low intensity
    scene.add(ambientLight);
    
    // Add directional moonlight (very dim for atmosphere)
    const directionalLight = new THREE.DirectionalLight(0x5D4E8C, 0.3);
    directionalLight.position.set(0, 10, 0);
    directionalLight.castShadow = true;
    scene.add(directionalLight);
    
    // Create the ground plane (swampy terrain)
    const groundGeometry = new THREE.PlaneGeometry(20, 20, 32, 32);
    // Add some vertex displacement for uneven swampy ground
    const vertices = groundGeometry.attributes.position.array;
    for (let i = 0; i < vertices.length; i += 3) {
        // Skip the edges to keep them level
        if (Math.abs(vertices[i]) < 9 && Math.abs(vertices[i+2]) < 9) {
            vertices[i+1] = Math.random() * 0.1 - 0.05; // Small bumps
        }
    }
    
    const groundMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x0A3B0A, // Dark swamp green
        roughness: 0.9,
        metalness: 0.1
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);
    
    // Create swampy elements
    createSwampEnvironment();
    
    // Create glowing mushrooms
    createMushrooms(30); // Create 30 mushrooms
    
    // Create fireflies
    createFireflies(25); // 25 fireflies
    
    // Setup controllers with nets
    setupNetControllers();
    
    // Create UI elements
    createUI();
}
        
    
        
        // Create fireflies
        function createFireflies(count) {
            for (let i = 0; i < count; i++) {
                const colorIndex = Math.floor(Math.random() * 3);
                const color = fireflyColors[colorIndex];
                
                // Create firefly body
                const bodyGeometry = new THREE.SphereGeometry(0.0075, 8, 8); 
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                
                // Create simple wings (two small planes)
                const wingGeometry = new THREE.PlaneGeometry(0.0125, 0.01); 
                const wingMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                
                const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
                leftWing.position.set(-0.0075, 0, 0); 
                leftWing.rotation.y = Math.PI / 4;
                body.add(leftWing);
                
                const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
                rightWing.position.set(0.0075, 0, 0); 
                rightWing.rotation.y = -Math.PI / 4;
                body.add(rightWing);
                
                // Create point light for the glow effect
                 const light = new THREE.PointLight(color, 0, 0.125); 
                light.intensity = 0;
                body.add(light);
                
                // Position randomly in the scene
                body.position.set(
                 (Math.random() - 0.5) * 2, 
            0.25 + Math.random() * 0.5,
            (Math.random() - 0.5) * 2  
                );
                
                scene.add(body);
                
                // Firefly properties
                const firefly = {
                    mesh: body,
                    light: light,
                    material: bodyMaterial,
                    colorIndex: colorIndex,
                    velocity: new THREE.Vector3(
                       (Math.random() - 0.5) * 0.005, 
                (Math.random() - 0.5) * 0.005, 
                (Math.random() - 0.5) * 0.005  
                    ),
                    blinkTimer: Math.random() * 5,
                    blinkDuration: 0.3,
                    isBlinking: false,
                    isCaught: false,
                    isInJar: false,
                    wings: {
                        left: leftWing,
                        right: rightWing,
                        angle: 0,
                        speed: 0.2 + Math.random() * 0.3
                    }
                };
                
                fireflies.push(firefly);
            }
        }



// Create elements for swamp environment
function createSwampEnvironment() {
    // Create some reeds/cattails
    for (let i = 0; i < 50; i++) {
        const height = 0.3 + Math.random() * 0.6;
        const reedGeometry = new THREE.CylinderGeometry(0.005, 0.01, height, 5);
        const reedMaterial = new THREE.MeshStandardMaterial({
            color: 0x6B8E23, // Olive green
            roughness: 0.9
        });
        const reed = new THREE.Mesh(reedGeometry, reedMaterial);
        
        // Position randomly around the scene, but avoid the center
        const angle = Math.random() * Math.PI * 2;
        const radius = 1.5 + Math.random() * 8;
        reed.position.set(
            Math.cos(angle) * radius,
            height / 2,
            Math.sin(angle) * radius
        );
        
        // Random slight tilt
        reed.rotation.x = (Math.random() - 0.5) * 0.2;
        reed.rotation.z = (Math.random() - 0.5) * 0.2;
        
        reed.castShadow = true;
        reed.receiveShadow = true;
        scene.add(reed);
    }
    
    // Create some tree stumps
    for (let i = 0; i < 8; i++) {
        const stumpGeometry = new THREE.CylinderGeometry(0.2, 0.25, 0.3, 8);
        const stumpMaterial = new THREE.MeshStandardMaterial({
            color: 0x3D2817, // Dark brown
            roughness: 1.0
        });
        const stump = new THREE.Mesh(stumpGeometry, stumpMaterial);
        
        // Position randomly around the scene
        const angle = Math.random() * Math.PI * 2;
        const radius = 2 + Math.random() * 7;
        stump.position.set(
            Math.cos(angle) * radius,
            0.15,
            Math.sin(angle) * radius
        );
        
        stump.castShadow = true;
        stump.receiveShadow = true;
        scene.add(stump);
    }
    
    // Create some rocks
    for (let i = 0; i < 15; i++) {
        const rockGeometry = new THREE.DodecahedronGeometry(0.1 + Math.random() * 0.15, 0);
        const rockMaterial = new THREE.MeshStandardMaterial({
            color: 0x555555,
            roughness: 0.8
        });
        const rock = new THREE.Mesh(rockGeometry, rockMaterial);
        
        // Position randomly
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 9;
        rock.position.set(
            Math.cos(angle) * radius,
            0.05,
            Math.sin(angle) * radius
        );
        
        // Random rotation
        rock.rotation.set(
            Math.random() * Math.PI,
            Math.random() * Math.PI,
            Math.random() * Math.PI
        );
        
        rock.castShadow = true;
        rock.receiveShadow = true;
        scene.add(rock);
    }
    
    // Add some fog for atmosphere
    scene.fog = new THREE.FogExp2(0x0A1A2A, 0.05);
}

// Create glowing mushrooms
let mushrooms = [];
function createMushrooms(count) {
    for (let i = 0; i < count; i++) {
        // Create stem
        const stemHeight = 0.05 + Math.random() * 0.1;
        const stemRadius = 0.01 + Math.random() * 0.015;
        const stemGeometry = new THREE.CylinderGeometry(stemRadius, stemRadius * 1.2, stemHeight, 8);
        const stemMaterial = new THREE.MeshStandardMaterial({
            color: 0xDDBBDD, // Light purplish
            roughness: 0.7
        });
        const stem = new THREE.Mesh(stemGeometry, stemMaterial);
        
        // Create cap
        const capRadius = stemRadius * 3;
        const capHeight = stemRadius * 2;
        const capGeometry = new THREE.ConeGeometry(capRadius, capHeight, 8, 1, true);
        
        // Random mushroom colors with low initial emissive intensity
        const capColor = new THREE.Color(
            0.3 + Math.random() * 0.7,
            0.2 + Math.random() * 0.3,
            0.5 + Math.random() * 0.5
        );
        
        const capMaterial = new THREE.MeshStandardMaterial({
            color: capColor,
            emissive: capColor,
            emissiveIntensity: 0.05, // Start with low glow
            roughness: 0.7
        });
        const cap = new THREE.Mesh(capGeometry, capMaterial);
        cap.position.y = stemHeight / 2;
        cap.rotation.x = Math.PI; // Flip the cone upside down
        
        // Create mushroom group
        const mushroom = new THREE.Group();
        mushroom.add(stem);
        mushroom.add(cap);
        
        // Position randomly
        const angle = Math.random() * Math.PI * 2;
        const radius = 0.5 + Math.random() * 9;
        mushroom.position.set(
            Math.cos(angle) * radius,
            0,
            Math.sin(angle) * radius
        );
        
        // Random slight tilt
        mushroom.rotation.x = (Math.random() - 0.5) * 0.2;
        mushroom.rotation.z = (Math.random() - 0.5) * 0.2;
        
        mushroom.userData = {
            cap: cap,
            originalIntensity: 0.05,
            maxIntensity: 0.3 + Math.random() * 0.7 // Different max intensity for variation
        };
        
        scene.add(mushroom);
        mushrooms.push(mushroom);
    }
}

// Setup VR controllers with nets
function setupNetControllers() {
    const controllerModelFactory = new XRControllerModelFactory();
    
    // Create controller objects and add them to the scene
    for (let i = 0; i < 2; i++) {
        // Controller
        const controller = renderer.xr.getController(i);
        controller.addEventListener('connected', (event) => {
            controller.userData.gamepad = event.data.gamepad;
        });
        controller.addEventListener('disconnected', () => {
            controller.remove(controller.children[0]);
            controller.userData.gamepad = null;
        });
        scene.add(controller);
        controllers.push(controller);
        
        // Create the net model (handle + cylinder)
        const handleGeometry = new THREE.BoxGeometry(0.01, 0.01, 0.2);
        const handleMaterial = new THREE.MeshStandardMaterial({
            color: 0x8B4513, // Wood color
            roughness: 0.8
        });
        const handle = new THREE.Mesh(handleGeometry, handleMaterial);
        handle.position.z = -0.1; // Position handle behind the net
        
        // Create the net cylinder
        const netGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.02, 16, 1, true);
        const netMaterial = new THREE.MeshStandardMaterial({
            color: 0xCCCCCC,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide,
            wireframe: true
        });
        const net = new THREE.Mesh(netGeometry, netMaterial);
        net.rotation.x = Math.PI / 2; // Rotate to make circular opening face forward
        net.position.z = -0.02; // Position at the end of the handle
        
        // Create a group for the net and handle
        const netTool = new THREE.Group();
        netTool.add(handle);
        netTool.add(net);
        
        // Add to controller
        controller.add(netTool);
        
        // Store the net part for collision detection
        controller.userData.net = net;
        controller.userData.netFlashing = false;
        
        controllers.push(controller);
    }
}



// Catch a firefly
function catchFirefly(firefly, controllerIndex) {
    firefly.isCaught = true;
    
    // Flash the net
    flashNet(controllers[controllerIndex]);
    
    // Trigger haptic feedback
    triggerHapticFeedback(controllerIndex, 0.8, 100);
    
    // Remove the firefly after a brief flash
    setTimeout(() => {
        scene.remove(firefly.mesh);
        
        // Remove from array by setting it to null
        // We'll filter these out later if needed
        const index = fireflies.indexOf(firefly);
        if (index !== -1) {
            fireflies[index] = null;
        }
        
        // Increase the brightness of mushrooms
        increaseMushromBrightness();
        
        // Add points
        score += 10;
    }, 300);
}

// Flash the net when catching a firefly
function flashNet(controller) {
    if (!controller.userData.net || controller.userData.netFlashing) return;
    
    controller.userData.netFlashing = true;
    
    // Store original material
    const originalMaterial = controller.userData.net.material;
    
    // Create a glowing material
    const flashMaterial = new THREE.MeshBasicMaterial({
        color: 0xFFFFFF, 
        transparent: true,
        opacity: 0.7
    });
    
    // Apply flash material
    controller.userData.net.material = flashMaterial;
    
    // Reset after flash
    setTimeout(() => {
        controller.userData.net.material = originalMaterial;
        controller.userData.netFlashing = false;
    }, 300);
}

// Increase mushroom brightness when a firefly is caught
function increaseMushromBrightness() {
    // Count remaining fireflies
    const remainingFireflies = fireflies.filter(f => f !== null).length;
    
    // Calculate global intensity factor based on how many fireflies have been caught
    const intensityFactor = 1 - (remainingFireflies / 25); // Assuming 25 was the initial count
    
    // Apply the new intensity to each mushroom
    for (let i = 0; i < mushrooms.length; i++) {
        const mushroom = mushrooms[i];
        const capMaterial = mushroom.userData.cap.material;
        
        // Calculate new intensity between original and max, based on how many fireflies are caught
        const newIntensity = mushroom.userData.originalIntensity + 
            (mushroom.userData.maxIntensity - mushroom.userData.originalIntensity) * intensityFactor;
        
        capMaterial.emissiveIntensity = newIntensity;
    }
    
    // Also increase the ambient light slightly
    ambientLight.intensity = 0.2 + (0.3 * intensityFactor);
}






        
      
        
        // Create UI elements
      function createUI() {
    // Score and timer display
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 128;
    const context = canvas.getContext('2d');
    
    // Fill with initial content
    context.fillStyle = 'rgba(0, 0, 0, 0.5)';
    context.fillRect(0, 0, canvas.width, canvas.height);
    context.fillStyle = 'white';
    context.font = '32px Arial';
    context.textAlign = 'center';
    context.fillText(`Score: ${score}   Time: ${Math.ceil(timeRemaining)}s`, 256, 64);
    
    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        side: THREE.DoubleSide
    });
    
    const geometry = new THREE.PlaneGeometry(0.25, 0.0625); 
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(0, 0.125, -0.5);
    
    scene.add(mesh);
            
            // Quit button
            const quitGeometry = new THREE.PlaneGeometry(0.1, 0.0375); 
            const quitMaterial = new THREE.MeshStandardMaterial({
    color: 0x400000, // Much darker red
    emissive: 0xff0000, // Red glow
    emissiveIntensity: 0.2, // Very subtle intensity
    transparent: true,
    opacity: 0.6, // Partially transparent
    side: THREE.DoubleSide
});

           const quitButton = new THREE.Mesh(quitGeometry, quitMaterial);
            quitButton.position.set(0, 0.025, -0.5);
            scene.add(quitButton);
            
            // Quit text
            const quitCanvas = document.createElement('canvas');
            quitCanvas.width = 256;
            quitCanvas.height = 128;
            const quitContext = quitCanvas.getContext('2d');
            quitContext.fillStyle = 'white';
            quitContext.font = '48px Arial';
            quitContext.textAlign = 'center';
            quitContext.textBaseline = 'middle';
            quitContext.fillText('QUIT', 128, 64);
            
            const quitTexture = new THREE.CanvasTexture(quitCanvas);
            const quitTextMaterial = new THREE.MeshBasicMaterial({
                map: quitTexture,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const quitTextGeometry = new THREE.PlaneGeometry(0.0875, 0.03); 
            const quitTextMesh = new THREE.Mesh(quitTextGeometry, quitTextMaterial);
            quitTextMesh.position.set(0, 0.025, -0.49);
            scene.add(quitTextMesh);
            
            // Update UI function
            function updateUI() {
                context.clearRect(0, 0, canvas.width, canvas.height);
                context.fillStyle = 'rgba(0, 0, 0, 0.5)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                context.fillStyle = 'white';
                context.font = '32px Arial';
                context.textAlign = 'center';
                context.fillText(`Score: ${score}   Time: ${Math.ceil(timeRemaining)}s`, 256, 64);
                texture.needsUpdate = true;
            }
            
            // Store UI elements for updates
            return {
                update: updateUI,
                quit: {
                    button: quitButton,
                    text: quitTextMesh
                }
            };
        }
        
        // Handle window resizing
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Update firefly positions and behaviors
        function updateFireflies(deltaTime) {
            for (let i = 0; i < fireflies.length; i++) {
                const firefly = fireflies[i];
                
                // Skip updating if the firefly is in a jar
                if (firefly.isInJar) continue;
                
                const mesh = firefly.mesh;
                
                // Update wing animation
                firefly.wings.angle += firefly.wings.speed * deltaTime;
                firefly.wings.left.rotation.z = Math.sin(firefly.wings.angle) * 0.5;
                firefly.wings.right.rotation.z = -Math.sin(firefly.wings.angle) * 0.5;
                
                // Update position if not caught
                if (!firefly.isCaught) {
                    // Add random movement changes
                    if (Math.random() < 0.05) {
                       firefly.velocity.x += (Math.random() - 0.5) * 0.0025; 
                       firefly.velocity.y += (Math.random() - 0.5) * 0.0025; 
                       firefly.velocity.z += (Math.random() - 0.5) * 0.0025; 
                        
                        // Limit velocity
                        const speed = firefly.velocity.length();
                         if (speed > 0.0125) { // Reduced from 0.05
                     firefly.velocity.multiplyScalar(0.0125 / speed);
                        }
                    }
                    
                    // Apply velocity
                    mesh.position.add(firefly.velocity);
                    
                    // Boundary checking - keep fireflies within a certain volume
                 if (mesh.position.x < -2.5 || mesh.position.x > 2.5) firefly.velocity.x *= -1; 
                 if (mesh.position.y < 0.125 || mesh.position.y > 1) firefly.velocity.y *= -1;
                   if (mesh.position.z < -2.5 || mesh.position.z > 2.5) firefly.velocity.z *= -1; 
                
              // Ensure they stay above the ground
               if (mesh.position.y < 0.125) mesh.position.y = 0.125; 
                }
                
                // Handle blinking
                if (!firefly.isBlinking) {
                    firefly.blinkTimer -= deltaTime;
                    if (firefly.blinkTimer <= 0) {
                        // Start blinking
                        firefly.isBlinking = true;
                        firefly.material.emissiveIntensity = 1;
                        firefly.light.intensity = 1;
                        firefly.blinkTimer = firefly.blinkDuration;
                    }
                } else {
                    firefly.blinkTimer -= deltaTime;
                    if (firefly.blinkTimer <= 0) {
                        // Stop blinking
                        firefly.isBlinking = false;
                        firefly.material.emissiveIntensity = 0;
                        firefly.light.intensity = 0;
                        firefly.blinkTimer = 3 + Math.random() * 5; // Random time until next blink
                    }
                }
            }
        }

        
    
// Check for controller collisions with fireflies
function checkCollisions() {
    // Individual controller net collision detection
    for (let c = 0; c < controllers.length; c++) {
        const controller = controllers[c];
        if (!controller.userData.net) continue;
        
        // Get the net's world position
        const netWorldPosition = new THREE.Vector3();
        controller.userData.net.getWorldPosition(netWorldPosition);
        
        // Check each firefly
        for (let i = 0; i < fireflies.length; i++) {
            const firefly = fireflies[i];
            
            // Skip if already caught
            if (firefly.isCaught || firefly === null) continue;
            
            // Get firefly position
            const fireflyPos = new THREE.Vector3();
            firefly.mesh.getWorldPosition(fireflyPos);
            
            // Calculate distance to the net
            const distanceToNet = fireflyPos.distanceTo(netWorldPosition);
            
            // If the firefly is close enough to the net, catch it
            if (distanceToNet < 0.07) {
                catchFirefly(firefly, c);
                break; // Only catch one firefly at a time
            }
        }
    }
    
    // Check for clapping motion to catch fireflies (if we have at least 2 controllers)
    if (controllers.length >= 2) {
        const controller1Pos = new THREE.Vector3();
        const controller2Pos = new THREE.Vector3();
        controllers[0].getWorldPosition(controller1Pos);
        controllers[1].getWorldPosition(controller2Pos);
        
        const controllerDistance = controller1Pos.distanceTo(controller2Pos);
        const clapThreshold = 0.0625;
        
        if (controllerDistance < clapThreshold) {
            // Calculate midpoint between controllers
            const midpoint = new THREE.Vector3().addVectors(controller1Pos, controller2Pos).multiplyScalar(0.5);
            
            // Check each firefly
            for (let i = 0; i < fireflies.length; i++) {
                const firefly = fireflies[i];
                
                // Skip if already caught or null
                if (!firefly || firefly.isCaught) continue;
                
                const fireflyPos = new THREE.Vector3();
                firefly.mesh.getWorldPosition(fireflyPos);
                
                // Calculate distance to midpoint
                const distanceToMidpoint = fireflyPos.distanceTo(midpoint);
                
                // If the firefly is close enough to the midpoint, catch it
                if (distanceToMidpoint < clapThreshold) {
                    catchFirefly(firefly, 0);
                    
                    // Implement haptic feedback if it exists
                    if (typeof triggerHapticFeedback === 'function') {
                        triggerHapticFeedback(0, 0.8, 100);
                        triggerHapticFeedback(1, 0.8, 100);
                    }
                }
            }
        }
    }
}

// Add the missing triggerHapticFeedback function
function triggerHapticFeedback(controllerIndex, intensity, duration) {
    // Only proceed if we have controllers with gamepads that support haptics
    if (controllers[controllerIndex] && 
        controllers[controllerIndex].userData.gamepad && 
        controllers[controllerIndex].userData.gamepad.hapticActuators && 
        controllers[controllerIndex].userData.gamepad.hapticActuators.length > 0) {
        controllers[controllerIndex].userData.gamepad.hapticActuators[0].pulse(intensity, duration);
    }
}








        
        // Victory celebration
        function celebrateVictory() {
            // Create a burst of particles from each jar
            for (let i = 0; i < jars.length; i++) {
                createParticleBurst(jars[i].position, fireflyColors[i]);
            }
            
            // Create text showing "You Win!"
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            context.fillStyle = 'white';
            context.font = 'bold 72px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText('YOU WIN!', 256, 128);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const geometry = new THREE.PlaneGeometry(2, 1);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(0, 2, -2);
            scene.add(mesh);
            
            // Victory animation
            const startTime = Date.now();
            function victoryAnimation() {
                const elapsed = (Date.now() - startTime) / 1000;
                mesh.position.y = 2 + Math.sin(elapsed * 2) * 0.1;
                mesh.rotation.z = Math.sin(elapsed) * 0.1;
                
                if (elapsed < 10) { // Run for 10 seconds
                    requestAnimationFrame(victoryAnimation);
                }
            }
            
            victoryAnimation();
            
            // Trigger haptic pulses on both controllers
            function celebrationHaptics() {
                const elapsed = (Date.now() - startTime) / 1000;
                const intensity = (Math.sin(elapsed * 10) + 1) / 2;
                
                triggerHapticFeedback(0, intensity, 50);
                triggerHapticFeedback(1, intensity, 50);
                
                if (elapsed < 5) { // Haptics for 5 seconds
                    setTimeout(celebrationHaptics, 100);
                }
            }
            
            celebrationHaptics();
        }
        
        // Create particle burst effect
        function createParticleBurst(position, color) {
            const particleCount = 100;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            
            // Initial positions at the center
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                positions[i3] = position.x;
                positions[i3 + 1] = position.y;
                positions[i3 + 2] = position.z;
                
                // Random velocity for each particle
                velocities.push(
                    (Math.random() - 0.5) * 0.1,
                    Math.random() * 0.1,
                    (Math.random() - 0.5) * 0.1
                );
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: color,
                size: 0.05,
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            const particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            // Animation for particles
            const startTime = Date.now();
            function animateParticles() {
                const positions = particles.geometry.attributes.position.array;
                
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    
                    // Update positions based on velocities
                    positions[i3] += velocities[i * 3];
                    positions[i3 + 1] += velocities[i * 3 + 1];
                    positions[i3 + 2] += velocities[i * 3 + 2];
                    
                    // Add gravity effect
                    velocities[i * 3 + 1] -= 0.0005;
                }
                
                particles.geometry.attributes.position.needsUpdate = true;
                
                // Fade out particles
                const elapsed = (Date.now() - startTime) / 1000;
                material.opacity = Math.max(0, 1 - elapsed / 3);
                
                if (elapsed < 3) { // Run for 3 seconds
                    requestAnimationFrame(animateParticles);
                } else {
                    scene.remove(particles);
                    particles.geometry.dispose();
                    material.dispose();
                }
            }
            
            animateParticles();
        }
        
        // Animation loop
       function animate() {
    const deltaTime = clock.getDelta();
    
    if (gameStarted && !gameEnded) {
        // Update game timer
        timeRemaining -= deltaTime;
        if (timeRemaining <= 0) {
            timeRemaining = 0;
            // Game over logic could go here
        }
        
        // Update fireflies
        updateFireflies(deltaTime);
        
        // Check for collisions with the nets
        checkCollisions();
        
        // Update UI
        if (ui) ui.update();
    }
    
    // Render the scene
    renderer.render(scene, camera);
}
        
        // Initialize UI
        let ui = null;
        
        // Initialize the game
        init();
    </script>
</body>
</html>
