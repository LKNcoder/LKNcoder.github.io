<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR NPC Salesperson Demo</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            pointer-events: none;
            z-index: 100;
        }
        #speechBubble {
            position: absolute;
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.8);
            color: black;
            padding: 10px 15px;
            border-radius: 15px;
            font-family: Arial, sans-serif;
            max-width: 80%;
            display: none;
            z-index: 100;
        }
        #micButton {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #ff4444;
            border: none;
            cursor: pointer;
            z-index: 100;
        }
        #micButton.listening {
            background: #44ff44;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(68, 255, 68, 0.7); }
            70% { box-shadow: 0 0 0 15px rgba(68, 255, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(68, 255, 68, 0); }
        }
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 24px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="info">WebXR NPC Salesperson Demo</div>
    <div id="speechBubble"></div>
    <button id="micButton" title="Press to talk"></button>
    <div class="loading" id="loadingScreen">Loading... Please wait</div>

    <!-- Import libraries via CDN -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

        // Global variables
        let camera, scene, renderer, clock;
        let userAvatar, npcAvatar;
        let userMixer, npcMixer;
        let userAnimations = {}, npcAnimations = {};
        let ground;
        let controller1, controller2;
        let userHeight = 1.6; // Average height in meters
        let isListening = false;
        let recognition;
        let npcFollowingUser = true;
        let speechBubble;
        let loadingManager;
        let loadingScreen;
        let npcSpeaking = false;
        
        // Initialize and run the application
        init();
        animate();

        function init() {
            loadingScreen = document.getElementById('loadingScreen');
            speechBubble = document.getElementById('speechBubble');
            
            // Set up loading manager to track asset loading
            loadingManager = new THREE.LoadingManager();
            loadingManager.onLoad = () => {
                loadingScreen.style.display = 'none';
            };
            
            // Initialize scene
            clock = new THREE.Clock();
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            
            // Initialize camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, userHeight, 3);
            
            // Set up renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            // Add VR button
            document.body.appendChild(VRButton.createButton(renderer));
            
            // Set up lighting
            setupLighting();
            
            // Create environment
            createEnvironment();
            
            // Set up controllers
            setupControllers();
            
            // Set up speech recognition
            setupSpeechRecognition();
            
            // Set up microphone button
            setupMicButton();
            
            // Load avatar models
             loadAvatarModels();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }
        
        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            // Directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            scene.add(directionalLight);
        }
        
        function createEnvironment() {
            // Create ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x7CFC00, // Lawn green
                roughness: 0.8,
                metalness: 0.2
            });
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2; // Rotate to be horizontal
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Add simple skybox
            const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
            const skyMaterial = new THREE.MeshBasicMaterial({
                color: 0x87CEEB,
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);
        }
        
        function setupControllers() {
            // Controller setup for VR
            controller1 = renderer.xr.getController(0);
            scene.add(controller1);
            
            controller2 = renderer.xr.getController(1);
            scene.add(controller2);
            
            // Controller models
            const controllerModelFactory = new XRControllerModelFactory();
            
            const controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            scene.add(controllerGrip1);
            
            const controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
            scene.add(controllerGrip2);
        }
        
        
        
    function loadAvatarModels() {
    // Load the NPC avatar model (Ready Player Me GLB)
    const gltfLoader = new GLTFLoader(loadingManager);
    gltfLoader.load(
        'npc-avatar.glb', // Make sure this file is in the same directory as your HTML
        function(gltf) {
            // Remove placeholder
            scene.remove(npcAvatar);
            
            // Add GLB model
            npcAvatar = gltf.scene;
            npcAvatar.position.set(2, 0, 0); // Position at the same place as placeholder
            npcAvatar.scale.set(1, 1, 1);
            npcAvatar.castShadow = true;
            scene.add(npcAvatar);
            
            // Set up animation mixer
            npcMixer = new THREE.AnimationMixer(npcAvatar);
            
            // Now load the FBX animations
            loadNPCAnimations();
        },
        undefined,
        function(error) {
            console.error('Error loading NPC model:', error);
        }
    );
}

function loadNPCAnimations() {
    const fbxLoader = new FBXLoader(loadingManager);
    
    // Load idle animation
    fbxLoader.load(
        'idle.fbx', // Make sure this file is in the same directory
        function(object) {
            const animation = object.animations[0];
            if (animation) {
                // Might need to adjust animation to match the model
                animation.name = 'idle';
                const idleAction = npcMixer.clipAction(animation);
                npcAnimations['idle'] = idleAction;
                idleAction.play();
            }
        },
        undefined,
        function(error) {
            console.error('Error loading idle animation:', error);
        }
    );
    
    // Load talking animation
    fbxLoader.load(
        'talking.fbx', // Make sure this file is in the same directory
        function(object) {
            const animation = object.animations[0];
            if (animation) {
                // Might need to adjust animation to match the model
                animation.name = 'talking';
                const talkingAction = npcMixer.clipAction(animation);
                npcAnimations['talking'] = talkingAction;
                // Don't play it yet, will be triggered when speaking
            }
        },
        undefined,
        function(error) {
            console.error('Error loading talking animation:', error);
        }
    );
}

        
        function setupSpeechRecognition() {
            // Set up Web Speech API if available
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                recognition.continuous = false;
                recognition.interimResults = false;
                recognition.lang = 'en-US';
                
                recognition.onresult = function(event) {
                    const transcript = event.results[0][0].transcript;
                    handleUserSpeech(transcript);
                };
                
                recognition.onend = function() {
                    isListening = false;
                    document.getElementById('micButton').classList.remove('listening');
                };
                
                recognition.onerror = function(event) {
                    console.error('Speech recognition error:', event.error);
                    isListening = false;
                    document.getElementById('micButton').classList.remove('listening');
                };
            } else {
                console.warn('Speech recognition not supported in this browser');
                alert('Speech recognition is not supported in your browser. Please use Chrome or Edge.');
            }
        }
        
        function setupMicButton() {
            const micButton = document.getElementById('micButton');
            micButton.addEventListener('click', () => {
                if (!isListening && recognition) {
                    recognition.start();
                    isListening = true;
                    micButton.classList.add('listening');
                } else if (isListening && recognition) {
                    recognition.stop();
                    isListening = false;
                    micButton.classList.remove('listening');
                }
            });
        }
        
        function handleUserSpeech(text) {
            console.log('User said:', text);
            
            // Show a loading indicator in the speech bubble
            showSpeechBubble('...');
            
            // Call the AI API to get a response
            callChatAPI(text)
                .then(response => {
                    // Show the AI response in the speech bubble
                    showSpeechBubble(response);
                    
                    // Make the NPC speak
                    npcSpeak(response);
                })
                .catch(error => {
                    console.error('Error getting AI response:', error);
                    showSpeechBubble('Sorry, I could not process your request.');
                });
        }
        
        async function callChatAPI(text) {
            // Simulating an API call with a timeout
            // Replace this with an actual API call to Gemini Flash or your preferred service
            return new Promise((resolve) => {
                setTimeout(() => {
                    // Sample responses for testing
                    const responses = [
                        "Hello! How can I help you today?",
                        "I'm a virtual sales assistant. Let me tell you about our products.",
                        "That's an excellent question. Our product has many features including...",
                        "The price starts at $99 with various options available.",
                        "I'd be happy to show you a demo of how it works!"
                    ];
                    const randomResponse = responses[Math.floor(Math.random() * responses.length)];
                    resolve(randomResponse);
                }, 500); // 500ms delay simulates a fast API response
            });
        }
        
        function showSpeechBubble(text) {
            speechBubble.textContent = text;
            speechBubble.style.display = 'block';
            
            // Hide speech bubble after a delay
            setTimeout(() => {
                speechBubble.style.display = 'none';
            }, text.length * 100 + 2000); // Duration based on text length
        }
        
    function npcSpeak(text) {
    npcSpeaking = true;
    
    // If we have a talking animation, use it
    if (npcAnimations['talking']) {
        // Crossfade from idle to talking
        npcAnimations['idle'].fadeOut(0.5);
        npcAnimations['talking'].reset().fadeIn(0.5).play();
    } else {
        // Fall back to simple animation if model/animations aren't loaded
        animateNPCSpeaking();
    }
    
    // End speaking after calculated duration
    setTimeout(() => {
        npcSpeaking = false;
        
        // Return to idle animation
        if (npcAnimations['talking'] && npcAnimations['idle']) {
            npcAnimations['talking'].fadeOut(0.5);
            npcAnimations['idle'].reset().fadeIn(0.5).play();
        }
    }, text.length * 100); // Duration based on text length
}
        
        function animateNPCSpeaking() {
            // Placeholder for lip sync and animation logic
            // This would be replaced with actual animation control for the NPC avatar
            
            // Wiggle the NPC for now
            const intensity = 0.05;
            npcAvatar.position.y = userHeight / 2 + Math.sin(clock.getElapsedTime() * 10) * intensity;
        }
        
        function updateNPCMovement() {
            if (!npcAvatar || !userAvatar) return;
            
            // If NPC should follow the user
            if (npcFollowingUser) {
                // Get direction to user
                const direction = new THREE.Vector3();
                direction.subVectors(userAvatar.position, npcAvatar.position);
                direction.y = 0; // Keep on ground plane
                
                // Calculate distance to user
                const distance = direction.length();
                
                // If not too close, move towards user
                if (distance > 1.5) {
                    direction.normalize();
                    
                    // Move NPC towards user
                    const moveSpeed = 0.02;
                    npcAvatar.position.x += direction.x * moveSpeed;
                    npcAvatar.position.z += direction.z * moveSpeed;
                    
                    // Rotate NPC to face user
                    npcAvatar.lookAt(
                        userAvatar.position.x,
                        npcAvatar.position.y,
                        userAvatar.position.z
                    );
                }
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            renderer.setAnimationLoop(render);
        }
        
        function render() {
            const delta = clock.getDelta();
            
            // Update NPC movement to follow user
            updateNPCMovement();
            
            // Update animation mixers if available
            if (userMixer) userMixer.update(delta);
            if (npcMixer) npcMixer.update(delta);
            
            // Update user avatar position based on camera in VR
            if (renderer.xr.isPresenting) {
                // Position user avatar to match camera
                userAvatar.position.x = camera.position.x;
                userAvatar.position.z = camera.position.z;
            }
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
