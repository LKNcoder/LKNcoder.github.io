<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shield Defender VR</title>
 
    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js",
        "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/"
      }
    }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        #container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        #vrButton {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 22px 60px;
            background: linear-gradient(90deg, #0ff 0%, #09f 100%);
            color: #fff;
            border: 2px solid #0ff;
            border-radius: 18px;
            font-size: 2rem;
            font-family: 'Orbitron', Arial, sans-serif;
            letter-spacing: 2px;
            box-shadow: 0 0 24px #0ff, 0 0 8px #09f inset;
            cursor: pointer;
            z-index: 100;
            transition: all 0.2s cubic-bezier(.4,2,.6,1);
            text-shadow: 0 0 8px #0ff, 0 0 2px #fff;
        }
        #vrButton:hover {
            background: linear-gradient(90deg, #09f 0%, #0ff 100%);
            border-color: #fff;
            box-shadow: 0 0 32px #0ff, 0 0 16px #09f inset;
            color: #000;
            transform: translate(-50%, -50%) scale(1.05);
        }
        #gameUI {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 18px;
            z-index: 100;
            text-align: right;
            font-family: 'Orbitron', Arial, sans-serif;
        }
        #gameOverScreen {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            font-family: 'Orbitron', Arial, sans-serif;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="gameUI">
        <div>TIME: <span id="time">0:00</span></div>
        <div>SHOTS BLOCKED: <span id="blocked">0</span></div>
        <div>ENEMY PANELS: <span id="enemyPanels">9</span></div>
        <div>YOUR PANELS: <span id="playerPanels">9</span></div>
    </div>
    <button id="vrButton">ENTER VR</button>
    <div id="gameOverScreen">
        <h1 id="gameResult">VICTORY!</h1>
        <div id="finalStats"></div>
        <button id="playAgain" style="margin-top: 20px; padding: 10px 20px; font-size: 18px;">Play Again</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { XRControllerModelFactory } from 'three/examples/jsm/webxr/XRControllerModelFactory.js';

        // Game variables
        let scene, camera, renderer, clock;
        let controllers = [];
        let leftShield, rightShield;
        let playerGrid, enemyGrid;
        let enemy;
        let lasers = [];
        let gameStarted = false;
        let gameOver = false;
        let showingVRButton = true;
        
        // Game stats
        let startTime = 0;
        let shotsBlocked = 0;
        let enemyPanelsDestroyed = 0;
        let playerPanelsDestroyed = 0;
        
        // Laser timing
        let lastLaserTime = 0;
        let laserInterval = 2000; // Start at 2 seconds
        const minLaserInterval = 500; // Minimum 0.5 seconds

        // Grid arrays
        let playerPanels = [];
        let enemyPanels = [];

        // Controller state
        const controllerState = {
            left: { position: new THREE.Vector3(), connected: false },
            right: { position: new THREE.Vector3(), connected: false }
        };

        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x001122);

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 0);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            // VR button handler
            const vrButton = document.getElementById('vrButton');
            vrButton.addEventListener('click', async () => {
                showingVRButton = false;
                vrButton.style.display = 'none';
                startGame();
                
                if (navigator.xr) {
                    try {
                        await renderer.xr.setSession(await navigator.xr.requestSession('immersive-vr', { 
                            optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking'] 
                        }));
                    } catch (e) {
                        console.log('VR not available, continuing in desktop mode');
                    }
                }
            });

            // Play again button
            document.getElementById('playAgain').addEventListener('click', () => {
                document.getElementById('gameOverScreen').style.display = 'none';
                resetGame();
            });

            // Create clock
            clock = new THREE.Clock();

            // Create lighting
            createLighting();
            
            // Create environment
            createEnvironment();
            
            // Setup controllers
            setupControllers();
            
            // Create game objects
            createPlayerGrid();
            createEnemyGrid();
            createEnemy();
            createShields();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Start animation loop
            renderer.setAnimationLoop(animate);
        }

        function createLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            // Main directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Blue accent lighting
            const blueLight = new THREE.PointLight(0x0088ff, 0.5, 20);
            blueLight.position.set(-5, 3, -5);
            scene.add(blueLight);

            const orangeLight = new THREE.PointLight(0xff4400, 0.5, 20);
            orangeLight.position.set(5, 3, -5);
            scene.add(orangeLight);
        }

        function createEnvironment() {
            // Floor
            const floorGeometry = new THREE.PlaneGeometry(20, 20);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x222222,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Walls with grid pattern
            createWalls();
        }

        function createWalls() {
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.6,
                metalness: 0.4
            });

            // Back wall
            const backWall = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMaterial);
            backWall.position.set(0, 5, -10);
            scene.add(backWall);

            // Side walls
            const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMaterial);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.position.set(-10, 5, 0);
            scene.add(leftWall);

            const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMaterial);
            rightWall.rotation.y = -Math.PI / 2;
            rightWall.position.set(10, 5, 0);
            scene.add(rightWall);
        }

        function createPlayerGrid() {
            playerGrid = new THREE.Group();
            playerGrid.position.set(0, 1.6, -2);

            // Create 3x3 grid of panels
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const panelGeometry = new THREE.PlaneGeometry(0.4, 0.4);
                    const panelMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x0088ff,
                        transparent: true,
                        opacity: 0.3,
                        side: THREE.DoubleSide
                    });
                    
                    const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                    panel.position.set(
                        (col - 1) * 0.5,
                        (1 - row) * 0.5,
                        0
                    );
                    
                    panel.userData = {
                        isPlayerPanel: true,
                        row: row,
                        col: col,
                        destroyed: false
                    };
                    
                    playerGrid.add(panel);
                    playerPanels.push(panel);

                    // Add border
                    const borderGeometry = new THREE.EdgesGeometry(panelGeometry);
                    const borderMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff });
                    const border = new THREE.LineSegments(borderGeometry, borderMaterial);
                    panel.add(border);
                }
            }

            scene.add(playerGrid);
        }

        function createEnemyGrid() {
            enemyGrid = new THREE.Group();
            enemyGrid.position.set(0, 1.6, -8);

            // Create 3x3 grid of panels
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const panelGeometry = new THREE.PlaneGeometry(0.4, 0.4);
                    const panelMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xff4400,
                        transparent: true,
                        opacity: 0.6,
                        side: THREE.DoubleSide
                    });
                    
                    const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                    panel.position.set(
                        (col - 1) * 0.5,
                        (1 - row) * 0.5,
                        0
                    );
                    
                    panel.userData = {
                        isEnemyPanel: true,
                        row: row,
                        col: col,
                        destroyed: false
                    };
                    
                    enemyGrid.add(panel);
                    enemyPanels.push(panel);

                    // Add border
                    const borderGeometry = new THREE.EdgesGeometry(panelGeometry);
                    const borderMaterial = new THREE.LineBasicMaterial({ color: 0xff8800 });
                    const border = new THREE.LineSegments(borderGeometry, borderMaterial);
                    panel.add(border);
                }
            }

            scene.add(enemyGrid);
        }

        function createEnemy() {
            const enemyGroup = new THREE.Group();
            
            // Enemy body
            const bodyGeometry = new THREE.BoxGeometry(1, 1.5, 0.5);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x660000,
                metalness: 0.7,
                roughness: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            enemyGroup.add(body);

            // Enemy head
            const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x880000,
                metalness: 0.5,
                roughness: 0.4
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1;
            head.castShadow = true;
            enemyGroup.add(head);

            // Enemy eyes (glowing)
            const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.1, 1, 0.25);
            enemyGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.1, 1, 0.25);
            enemyGroup.add(rightEye);

            enemyGroup.position.set(0, 1, -8.5);
            enemy = enemyGroup;
            scene.add(enemy);
        }

        function createShields() {
            // Left shield (disk)
            const shieldGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.05, 16);
            const leftShieldMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00ff00,
                metalness: 0.8,
                roughness: 0.2
            });
            leftShield = new THREE.Mesh(shieldGeometry, leftShieldMaterial);
            leftShield.castShadow = true;
            leftShield.userData = { isShield: true, hand: 'left' };
            scene.add(leftShield);

            // Right shield (disk)
            const rightShieldMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0088ff,
                metalness: 0.8,
                roughness: 0.2
            });
            rightShield = new THREE.Mesh(shieldGeometry, rightShieldMaterial);
            rightShield.castShadow = true;
            rightShield.userData = { isShield: true, hand: 'right' };
            scene.add(rightShield);
        }

        function setupControllers() {
            for (let i = 0; i < 2; i++) {
                const controller = renderer.xr.getController(i);
                controller.addEventListener('connected', (event) => {
                    controller.userData.gamepad = event.data.gamepad;
                    controller.userData.controllerIndex = i;
                    const hand = i === 0 ? 'left' : 'right';
                    controllerState[hand].connected = true;
                });
                
                controller.addEventListener('disconnected', () => {
                    const hand = i === 0 ? 'left' : 'right';
                    controllerState[hand].connected = false;
                });
                
                scene.add(controller);
                controllers.push(controller);
            }
        }

        function updateControllerState() {
            controllers.forEach(controller => {
                if (!controller.userData.gamepad) return;
                
                const index = controller.userData.controllerIndex;
                const hand = index === 0 ? 'left' : 'right';
                
                controllerState[hand].position.copy(controller.position);
                
                // Update shield positions
                if (hand === 'left') {
                    leftShield.position.copy(controller.position);
                    leftShield.quaternion.copy(controller.quaternion);
                    leftShield.visible = gameStarted;
                } else {
                    rightShield.position.copy(controller.position);
                    rightShield.quaternion.copy(controller.quaternion);
                    rightShield.visible = gameStarted;
                }
            });
        }

        function startGame() {
            gameStarted = true;
            gameOver = false;
            startTime = Date.now();
            lastLaserTime = Date.now();
            
            // Reset stats
            shotsBlocked = 0;
            enemyPanelsDestroyed = 0;
            playerPanelsDestroyed = 0;
            
            updateUI();
        }

        function resetGame() {
            // Reset all panels
            playerPanels.forEach(panel => {
                panel.userData.destroyed = false;
                panel.visible = true;
                panel.material.opacity = 0.3;
            });
            
            enemyPanels.forEach(panel => {
                panel.userData.destroyed = false;
                panel.visible = true;
                panel.material.opacity = 0.6;
            });
            
            // Clear lasers
            lasers.forEach(laser => scene.remove(laser));
            lasers = [];
            
            // Reset timing
            laserInterval = 2000;
            
            startGame();
        }

        function fireLaser() {
            if (!gameStarted || gameOver) return;
            
            // Random target on player grid
            const targetRow = Math.floor(Math.random() * 3);
            const targetCol = Math.floor(Math.random() * 3);
            
            const targetPosition = new THREE.Vector3(
                (targetCol - 1) * 0.5,
                (1 - targetRow) * 0.5 + 1.6,
                -2
            );
            
            const startPosition = enemy.position.clone();
            startPosition.y += 1; // From enemy head
            
            const direction = new THREE.Vector3().subVectors(targetPosition, startPosition).normalize();
            
            // Create laser
            const laserGeometry = new THREE.CylinderGeometry(0.02, 0.02, 1, 8);
            const laserMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                transparent: true,
                opacity: 0.8
            });
            
            const laser = new THREE.Mesh(laserGeometry, laserMaterial);
            laser.position.copy(startPosition);
            laser.lookAt(targetPosition);
            laser.rotateX(Math.PI / 2);
            
            laser.userData = {
                isLaser: true,
                direction: direction,
                speed: 8,
                startPos: startPosition.clone(),
                fromEnemy: true,
                reflected: false
            };
            
            scene.add(laser);
            lasers.push(laser);
        }

        function updateLasers(delta) {
            for (let i = lasers.length - 1; i >= 0; i--) {
                const laser = lasers[i];
                const userData = laser.userData;
                
                // Move laser
                laser.position.add(userData.direction.clone().multiplyScalar(userData.speed * delta));
                
                // Check collision with shields (only if not reflected yet)
                if (userData.fromEnemy && !userData.reflected) {
                    if (checkShieldCollision(laser)) {
                        // Reflect laser toward enemy grid
                        userData.reflected = true;
                        userData.fromEnemy = false;
                        shotsBlocked++;
                        
                        // Change color to indicate reflection
                        laser.material.color.setHex(0x00ff00);
                        
                        // Calculate reflection direction toward enemy grid
                        const enemyGridCenter = new THREE.Vector3(0, 1.6, -8);
                        userData.direction = new THREE.Vector3().subVectors(enemyGridCenter, laser.position).normalize();
                        
                        updateUI();
                    }
                }
                
                // Check collision with grids
                if (userData.reflected) {
                    checkEnemyGridCollision(laser, i);
                } else if (userData.fromEnemy) {
                    checkPlayerGridCollision(laser, i);
                }
                
                // Remove laser if it's too far
                if (laser.position.distanceTo(userData.startPos) > 20) {
                    scene.remove(laser);
                    lasers.splice(i, 1);
                }
            }
        }

        function checkShieldCollision(laser) {
            const shields = [leftShield, rightShield];
            
            for (const shield of shields) {
                if (shield.visible && laser.position.distanceTo(shield.position) < 0.3) {
                    return true;
                }
            }
            return false;
        }

        function checkPlayerGridCollision(laser, laserIndex) {
            for (const panel of playerPanels) {
                if (panel.userData.destroyed) continue;
                
                if (laser.position.distanceTo(panel.getWorldPosition(new THREE.Vector3())) < 0.3) {
                    // Destroy panel
                    panel.userData.destroyed = true;
                    panel.visible = false;
                    playerPanelsDestroyed++;
                    
                    // Remove laser
                    scene.remove(laser);
                    lasers.splice(laserIndex, 1);
                    
                    updateUI();
                    checkGameEnd();
                    return;
                }
            }
        }

        function checkEnemyGridCollision(laser, laserIndex) {
            for (const panel of enemyPanels) {
                if (panel.userData.destroyed) continue;
                
                if (laser.position.distanceTo(panel.getWorldPosition(new THREE.Vector3())) < 0.3) {
                    // Destroy panel
                    panel.userData.destroyed = true;
                    panel.visible = false;
                    enemyPanelsDestroyed++;
                    
                    // Remove laser
                    scene.remove(laser);
                    lasers.splice(laserIndex, 1);
                    
                    updateUI();
                    checkGameEnd();
                    return;
                }
            }
        }

        function checkGameEnd() {
            if (enemyPanelsDestroyed >= 9) {
                // Player wins
                endGame(true);
            } else if (playerPanelsDestroyed >= 9) {
                // Player loses
                endGame(false);
            }
        }

        function endGame(victory) {
            gameOver = true;
            
            const endTime = Date.now();
            const gameTime = Math.floor((endTime - startTime) / 1000);
            const minutes = Math.floor(gameTime / 60);
            const seconds = gameTime % 60;
            
            const playerPanelsSaved = 9 - playerPanelsDestroyed;
            let score = 0;
            
            if (victory) {
                score = (playerPanelsSaved * 1000) + (shotsBlocked * 100) + Math.max(0, 300 - gameTime);
                document.getElementById('gameResult').textContent = 'VICTORY!';
                document.getElementById('gameResult').style.color = '#00ff00';
            } else {
                score = (shotsBlocked * 50) + (enemyPanelsDestroyed * 200);
                document.getElementById('gameResult').textContent = 'DEFEAT!';
                document.getElementById('gameResult').style.color = '#ff0000';
            }
            
            document.getElementById('finalStats').innerHTML = `
                <div>Time: ${minutes}:${seconds.toString().padStart(2, '0')}</div>
                <div>Shots Blocked: ${shotsBlocked}</div>
                <div>Enemy Panels Destroyed: ${enemyPanelsDestroyed}/9</div>
                <div>Your Panels Saved: ${playerPanelsSaved}/9</div>
                <div style="font-size: 24px; margin-top: 20px;">FINAL SCORE: ${score}</div>
            `;
            
            document.getElementById('gameOverScreen').style.display = 'flex';
        }

        function updateUI() {
            const currentTime = Date.now();
            const gameTime = Math.floor((currentTime - startTime) / 1000);
            const minutes = Math.floor(gameTime / 60);
            const seconds = gameTime % 60;
            
            document.getElementById('time').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('blocked').textContent = shotsBlocked;
            document.getElementById('enemyPanels').textContent = 9 - enemyPanelsDestroyed;
            document.getElementById('playerPanels').textContent = 9 - playerPanelsDestroyed;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            if (showingVRButton) {
                renderer.render(scene, camera);
                return;
            }
            
            const delta = clock.getDelta();
            
            updateControllerState();
            
            if (gameStarted && !gameOver) {
                updateUI();
                updateLasers(delta);
                
                // Fire lasers at increasing frequency
                const currentTime = Date.now();
                if (currentTime - lastLaserTime > laserInterval) {
                    fireLaser();
                    lastLaserTime = currentTime;
                    
                    // Increase frequency (decrease interval)
                    laserInterval = Math.max(minLaserInterval, laserInterval - 50);
                }
            }
            
            renderer.render(scene, camera);
        }

        // Start the game
        init();
    </script>
</body>
</html>
