<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StarBlast VR</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        #container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        #vrButton {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 16px 32px;
            background: #0066cc;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 20px;
            cursor: pointer;
            z-index: 100;
            transition: all 0.3s ease;
        }
        #vrButton:hover {
            background: #0055aa;
            transform: translateX(-50%) scale(1.05);
        }
        #loadingScreen {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        #loadingBar {
            width: 300px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            margin-top: 20px;
        }
        #loadingBarFill {
            width: 0%;
            height: 100%;
            background: #0066cc;
            border-radius: 10px;
            transition: width 0.3s ease;
        }
        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="score">SCORE: 0</div>
    <button id="vrButton">ENTER VR</button>
    <div id="loadingScreen">
        <h1>LOADING STARBLAST VR</h1>
        <div id="loadingBar">
            <div id="loadingBarFill"></div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js';
        import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/webxr/XRControllerModelFactory.js';

        // Game variables
        let scene, camera, renderer, clock;
        let controllers = [];
        let tunnel, player, enemies = [], turrets = [], lasers = [], explosions = [];
        let tunnelLength = 2000;
        let tunnelRadius = 20;
        let playerSpeed = 0.8;
        let score = 0;
        let gameOver = false;
        let gameStarted = false;
        let rearMirror, rearCamera;
        let frontReticle, rearReticle;
        let cockpit;
        let targetDestroyed = false;
        let showingVRButton = true;

        // Controller state
        const controllerState = {
            left: {
                joystick: { x: 0, y: 0 },
                trigger: false,
                squeeze: false
            },
            right: {
                joystick: { x: 0, y: 0 },
                trigger: false,
                squeeze: false
            }
        };

        // Initialize the game
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.FogExp2(0x000000, 0.005);

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 0;
            camera.rotation.y = Math.PI;

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.xr.enabled = true;
            document.getElementById('container').appendChild(renderer.domElement);

            // VR button
            const vrButton = document.getElementById('vrButton');
            vrButton.addEventListener('click', () => {
                showingVRButton = false;
                vrButton.style.display = 'none';
                document.body.appendChild(VRButton.createButton(renderer));
                renderer.xr.addEventListener('sessionstart', () => {
                    gameStarted = true;
                    resetGame();
                });
            });

            // Create clock
            clock = new THREE.Clock();

            // Create lights
            const ambientLight = new THREE.AmbientLight(0x444444);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 10, 10);
            scene.add(directionalLight);

            // Create tunnel
            createTunnel();
            
            // Create the final target
            createFinalTarget();
            
            // Create cockpit
            createCockpit();
            
            // Setup rear-view mirror
            setupRearViewMirror();
            
            // Setup controllers
            setupControllers();
            
            // Create reticles
            createReticles();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Simulate loading
            simulateLoading();
            
            // Start animation loop
            renderer.setAnimationLoop(animate);
        }

        function simulateLoading() {
            const loadingBarFill = document.getElementById('loadingBarFill');
            let progress = 0;
            const loadingInterval = setInterval(() => {
                progress += 5;
                loadingBarFill.style.width = progress + '%';
                if (progress >= 100) {
                    clearInterval(loadingInterval);
                    document.getElementById('loadingScreen').style.display = 'none';
                }
            }, 100);
        }

        function createTunnel() {
            // Create tunnel geometry
            const tunnelGeometry = new THREE.CylinderGeometry(tunnelRadius, tunnelRadius, tunnelLength, 24, 20, true);
            
            // Rotate and position the tunnel
            tunnelGeometry.rotateX(Math.PI / 2);
            
            // Create tunnel material with internal texture
            const tunnelMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                side: THREE.BackSide,
                roughness: 0.8,
                metalness: 0.2,
            });
            
            // Add details to the tunnel
            const tunnelDetailGeometry = new THREE.BoxGeometry(1, 1, 1);
            const tunnelDetailMaterial = new THREE.MeshStandardMaterial({
                color: 0x666666,
                roughness: 0.7,
                metalness: 0.3
            });
            
            // Create tunnel mesh
            tunnel = new THREE.Mesh(tunnelGeometry, tunnelMaterial);
            tunnel.position.z = -tunnelLength / 2;
            scene.add(tunnel);
            
            // Add tunnel details (pipes, panels, etc.)
            for (let i = 0; i < 200; i++) {
                const detail = new THREE.Mesh(tunnelDetailGeometry, tunnelDetailMaterial);
                const angle = Math.random() * Math.PI * 2;
                const z = -Math.random() * (tunnelLength - 50) - 10;
                const size = 0.5 + Math.random() * 1.5;
                
                detail.position.x = Math.sin(angle) * (tunnelRadius - 1);
                detail.position.y = Math.cos(angle) * (tunnelRadius - 1);
                detail.position.z = z;
                detail.scale.set(size, size, 1 + Math.random() * 5);
                detail.rotation.z = angle;
                tunnel.add(detail);
            }
            
            // Add turrets to the tunnel walls
            for (let i = 0; i < 30; i++) {
                createTurret(-100 - i * 60);
            }
            
            // Create enemy ships throughout the tunnel
            for (let i = 0; i < 20; i++) {
                createEnemy(-100 - i * 80);
            }
        }
        
        function createFinalTarget() {
            // Create the Death Star-like final target
            const targetGeometry = new THREE.SphereGeometry(15, 32, 32);
            const targetMaterial = new THREE.MeshStandardMaterial({
                color: 0x888888,
                roughness: 0.7,
                metalness: 0.3
            });
            
            const target = new THREE.Mesh(targetGeometry, targetMaterial);
            target.position.z = -tunnelLength + 50;
            target.userData = { 
                isTarget: true,
                health: 10
            };
            scene.add(target);
            
            // Add a glow effect
            const targetGlowGeometry = new THREE.SphereGeometry(16, 32, 32);
            const targetGlowMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.3
            });
            
            const targetGlow = new THREE.Mesh(targetGlowGeometry, targetGlowMaterial);
            target.add(targetGlow);
            
            // Add a small thermal exhaust port
            const exhaustPortGeometry = new THREE.CylinderGeometry(2, 2, 4, 16);
            const exhaustPortMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 });
            const exhaustPort = new THREE.Mesh(exhaustPortGeometry, exhaustPortMaterial);
            exhaustPort.position.y = 15;
            exhaustPort.rotation.x = Math.PI / 2;
            target.add(exhaustPort);
        }

        function createCockpit() {
            // Create a simple cockpit using geometric shapes
            cockpit = new THREE.Group();
            
            // Bottom panel
            const bottomPanelGeometry = new THREE.BoxGeometry(2, 0.1, 1);
            const panelMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const bottomPanel = new THREE.Mesh(bottomPanelGeometry, panelMaterial);
            bottomPanel.position.set(0, -0.6, -0.5);
            cockpit.add(bottomPanel);
            
            // Top panel
            const topPanelGeometry = new THREE.BoxGeometry(2, 0.1, 1);
            const topPanel = new THREE.Mesh(topPanelGeometry, panelMaterial);
            topPanel.position.set(0, 0.6, -0.5);
            cockpit.add(topPanel);
            
            // Side panels
            const sidePanelGeometry = new THREE.BoxGeometry(0.1, 1.2, 1);
            const leftPanel = new THREE.Mesh(sidePanelGeometry, panelMaterial);
            leftPanel.position.set(-1, 0, -0.5);
            cockpit.add(leftPanel);
            
            const rightPanel = new THREE.Mesh(sidePanelGeometry, panelMaterial);
            rightPanel.position.set(1, 0, -0.5);
            cockpit.add(rightPanel);
            
            // Controls (joysticks)
            const joystickGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.3, 8);
            const joystickMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const joystickHandleGeometry = new THREE.SphereGeometry(0.07, 8, 8);
            
            const leftJoystick = new THREE.Mesh(joystickGeometry, joystickMaterial);
            leftJoystick.position.set(-0.5, -0.4, -0.3);
            cockpit.add(leftJoystick);
            
            const leftJoystickHandle = new THREE.Mesh(joystickHandleGeometry, joystickMaterial);
            leftJoystickHandle.position.set(0, 0.15, 0);
            leftJoystick.add(leftJoystickHandle);
            
            const rightJoystick = new THREE.Mesh(joystickGeometry, joystickMaterial);
            rightJoystick.position.set(0.5, -0.4, -0.3);
            cockpit.add(rightJoystick);
            
            const rightJoystickHandle = new THREE.Mesh(joystickHandleGeometry, joystickMaterial);
            rightJoystickHandle.position.set(0, 0.15, 0);
            rightJoystick.add(rightJoystickHandle);
            
            // Dashboard indicators
            const indicatorGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.05);
            const indicatorMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            
            for (let i = 0; i < 5; i++) {
                const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial.clone());
                indicator.position.set(-0.8 + i * 0.4, -0.5, -0.2);
                cockpit.add(indicator);
            }
            
            // Position the cockpit in front of the camera
            cockpit.position.set(0, -0.2, -0.4);
            camera.add(cockpit);
        }

        function setupRearViewMirror() {
            // Create a rear-view camera
            rearCamera = new THREE.PerspectiveCamera(60, 1, 0.1, 2000);
            rearCamera.rotation.y = 0; // Looking back
            camera.add(rearCamera);
            
            // Create a render target for the rear view
            const rearRenderTarget = new THREE.WebGLRenderTarget(256, 256);
            
            // Create a plane to display the rear view
            const mirrorGeometry = new THREE.PlaneGeometry(0.3, 0.2);
            const mirrorMaterial = new THREE.MeshBasicMaterial({ map: rearRenderTarget.texture });
            
            rearMirror = new THREE.Mesh(mirrorGeometry, mirrorMaterial);
            rearMirror.position.set(0, 0.3, -0.5);
            camera.add(rearMirror);
            
            // Store the render target for later use
            rearMirror.userData = { renderTarget: rearRenderTarget };
        }
        
        function setupControllers() {
            // Controller model factory
            const controllerModelFactory = new XRControllerModelFactory();
            
            // Setup controllers
            for (let i = 0; i < 2; i++) {
                const controller = renderer.xr.getController(i);
                controller.addEventListener('connected', (event) => {
                    controller.userData.gamepad = event.data.gamepad;
                    controller.userData.controllerIndex = i;
                });
                scene.add(controller);
                
                const grip = renderer.xr.getControllerGrip(i);
                grip.add(controllerModelFactory.createControllerModel(grip));
                scene.add(grip);
                
                controllers.push(controller);
            }
        }
        
        function createReticles() {
            // Create front reticle
            const reticleGeometry = new THREE.RingGeometry(0.01, 0.02, 16);
            const reticleMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
            
            frontReticle = new THREE.Mesh(reticleGeometry, reticleMaterial);
            frontReticle.position.z = -2;
            scene.add(frontReticle);
            
            // Create rear reticle
            rearReticle = new THREE.Mesh(reticleGeometry, reticleMaterial.clone());
            rearReticle.position.z = 2;
            rearReticle.rotation.y = Math.PI;
            scene.add(rearReticle);
        }
        
        function createEnemy(zPosition) {
            const enemyGroup = new THREE.Group();
            
            // Create enemy body
            const bodyGeometry = new THREE.ConeGeometry(0.8, 2, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x666666 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.x = Math.PI / 2;
            enemyGroup.add(body);
            
            // Create enemy wings
            const wingGeometry = new THREE.BoxGeometry(2.5, 0.1, 0.8);
            const wingMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
            const wings = new THREE.Mesh(wingGeometry, wingMaterial);
            enemyGroup.add(wings);
            
            // Position the enemy
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * (tunnelRadius - 5);
            enemyGroup.position.x = Math.sin(angle) * radius;
            enemyGroup.position.y = Math.cos(angle) * radius;
            enemyGroup.position.z = zPosition;
            
            // Set enemy properties
            enemyGroup.userData = {
                isEnemy: true,
                health: 2,
                speed: 0.1 + Math.random() * 0.2,
                direction: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.05,
                    (Math.random() - 0.5) * 0.05,
                    0
                ),
                timeSinceShot: 0
            };
            
            scene.add(enemyGroup);
            enemies.push(enemyGroup);
        }
        
        function createTurret(zPosition) {
            const turretGroup = new THREE.Group();
            
            // Create turret base
            const baseGeometry = new THREE.BoxGeometry(2, 2, 2);
            const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            turretGroup.add(base);
            
            // Create turret cannon
            const cannonGeometry = new THREE.CylinderGeometry(0.3, 0.3, 2, 8);
            const cannonMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const cannon = new THREE.Mesh(cannonGeometry, cannonMaterial);
            cannon.rotation.x = Math.PI / 2;
            cannon.position.z = 1;
            turretGroup.add(cannon);
            
            // Position the turret
            const angle = Math.random() * Math.PI * 2;
            turretGroup.position.x = Math.sin(angle) * (tunnelRadius - 1);
            turretGroup.position.y = Math.cos(angle) * (tunnelRadius - 1);
            turretGroup.position.z = zPosition;
            turretGroup.rotation.z = angle;
            
            // Set turret properties
            turretGroup.userData = {
                isTurret: true,
                health: 3,
                timeToNextShot: 2 + Math.random() * 3,
                angle
            };
            
            scene.add(turretGroup);
            turrets.push(turretGroup);
        }
        
        function fireLaser(position, direction, isFromPlayer, isRear = false) {
            const laserGeometry = new THREE.CylinderGeometry(0.05, 0.05, 4, 8);
            const laserMaterial = new THREE.MeshBasicMaterial({ 
                color: isFromPlayer ? 0x00ff00 : 0xff0000,
                transparent: true,
                opacity: 0.8
            });
            
            const laser = new THREE.Mesh(laserGeometry, laserMaterial);
            laser.position.copy(position);
            
            if (direction.z > 0) {
                laser.rotation.x = Math.PI / 2;
            } else {
                laser.rotation.x = -Math.PI / 2;
            }
            
            laser.userData = {
                isLaser: true,
                direction: direction,
                speed: isFromPlayer ? 3 : 1.5,
                fromPlayer: isFromPlayer,
                isRear
            };
            
            scene.add(laser);
            lasers.push(laser);
            
            // Add a laser sound here if needed
        }
        
        function createExplosion(position, size = 1, particleCount = 100) {
            const explosionGroup = new THREE.Group();
            explosionGroup.position.copy(position);
            
            // Create explosion particles
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1 * size * Math.random());
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: new THREE.Color(
                        0.8 + Math.random() * 0.2,
                        0.3 * Math.random(),
                        0.1 * Math.random()
                    ) 
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // Random position within explosion radius
                const angle1 = Math.random() * Math.PI * 2;
                const angle2 = Math.random() * Math.PI * 2;
                const radius = Math.random() * 0.1 * size;
                
                particle.position.set(
                    radius * Math.cos(angle1) * Math.sin(angle2),
                    radius * Math.sin(angle1) * Math.sin(angle2),
                    radius * Math.cos(angle2)
                );
                
                // Random velocity
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.2 * size,
                        (Math.random() - 0.5) * 0.2 * size,
                        (Math.random() - 0.5) * 0.2 * size
                    ),
                    lifespan: 1 + Math.random()
                };
                
                explosionGroup.add(particle);
            }
            
            explosionGroup.userData = {
                isExplosion: true,
                age: 0
            };
            
            scene.add(explosionGroup);
            explosions.push(explosionGroup);
        }
        
        function resetGame() {
            // Remove all entities
            for (const enemy of enemies) scene.remove(enemy);
            for (const turret of turrets) scene.remove(turret);
            for (const laser of lasers) scene.remove(laser);
            for (const explosion of explosions) scene.remove(explosion);
            
            enemies = [];
            turrets = [];
            lasers = [];
            explosions = [];
            
            // Reset game state
            score = 0;
            gameOver = false;
            targetDestroyed = false;
            
            // Reset player position
            camera.position.set(0, 0, 0);
            camera.rotation.set(0, Math.PI, 0);
            
            // Recreate the tunnel and entities
            scene.remove(tunnel);
            createTunnel();
            createFinalTarget();
            
            // Update score display
            document.getElementById('score').innerText = `SCORE: ${score}`;
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function updateControllerState() {
            controllers.forEach(controller => {
                if (!controller.userData.gamepad) return;
                
                const gamepad = controller.userData.gamepad;
                const index = controller.userData.controllerIndex;
                const hand = index === 0 ? 'left' : 'right';
                
                // Update joystick position (axes)
                if (gamepad.axes.length >= 2) {
                    controllerState[hand].joystick.x = gamepad.axes[2];
                    controllerState[hand].joystick.y = gamepad.axes[3];
                }
                
                // Update trigger state
                if (gamepad.buttons.length > 0) {
                    controllerState[hand].trigger = gamepad.buttons[0].pressed;
                    controllerState[hand].squeeze = gamepad.buttons[1].pressed;
                }
            });
        }
        
        function handleControls(delta) {
            if (!gameStarted) return;
            
            // Flight controls (left joystick)
            const flightX = controllerState.left.joystick.x * 0.05;
            const flightY = -controllerState.left.joystick.y * 0.05;
            
            camera.position.x += flightX;
            camera.position.y += flightY;
            
            // Limit player position to inside the tunnel
            const maxRadius = tunnelRadius - 2;
            const currentRadius = Math.sqrt(camera.position.x ** 2 + camera.position.y ** 2);
            if (currentRadius > maxRadius) {
                const angle = Math.atan2(camera.position.y, camera.position.x);
                camera.position.x = Math.cos(angle) * maxRadius;
                camera.position.y = Math.sin(angle) * maxRadius;
            }
            
            // Aim controls (right joystick)
            const aimX = controllerState.right.joystick.x * 0.05;
            const aimY = -controllerState.right.joystick.y * 0.05;
            
            // Move front reticle
            frontReticle.position.x = camera.position.x + aimX * 20;
            frontReticle.position.y = camera.position.y + aimY * 20;
            frontReticle.position.z = camera.position.z - 2;
            
            // Move rear reticle (opposite direction)
            rearReticle.position.x = camera.position.x - aimX * 20;
            rearReticle.position.y = camera.position.y - aimY * 20;
            rearReticle.position.z = camera.position.z + 2;
            
            // Fire lasers with triggers
            if (controllerState.right.trigger) {
                // Fire forward laser
                const cooldown = 0.2; // 5 shots per second
                if (!camera.userData.lastShotTime || clock.getElapsedTime() - camera.userData.lastShotTime > cooldown) {
                    const laserPosition = new THREE.Vector3(
                        camera.position.x, 
                        camera.position.y, 
                        camera.position.z - 1
                    );
                    
                    const laserDirection = new THREE.Vector3(
                        frontReticle.position.x - camera.position.x,
                        frontReticle.position.y - camera.position.y,
                        frontReticle.position.z - camera.position.z
                    ).normalize();
                    
                    fireLaser(laserPosition, laserDirection, true, false);
                    camera.userData.lastShotTime = clock.getElapsedTime();
                }
            }
            
            if (controllerState.left.trigger) {
                // Fire rear laser
                const cooldown = 0.2; // 5 shots per second
                if (!camera.userData.lastRearShotTime || clock.getElapsedTime() - camera.userData.lastRearShotTime > cooldown) {
                    const laserPosition = new THREE.Vector3(
                        camera.position.x, 
                        camera.position.y, 
                        camera.position.z + 1
                    );
                    
                    const laserDirection = new THREE.Vector3(
                        rearReticle.position.x - camera.position.x,
                        rearReticle.position.y - camera.position.y,
                        rearReticle.position.z - camera.position.z
                    ).normalize();
                    
                    fireLaser(laserPosition, laserDirection, true, true);
                    camera.userData.lastRearShotTime = clock.getElapsedTime();
                }
            }
        }
        
        function updateLasers(delta) {
            for (let i = lasers.length - 1; i >= 0; i--) {
                const laser = lasers[i];
                const direction = laser.userData.direction;
                const speed = laser.userData.speed;
                
                laser.position.x += direction.x * speed;
                laser.position.y += direction.y * speed;
                laser.position.z += direction.z * speed;
                
                // Check if laser is out of bounds
                if (Math.abs(laser.position.z - camera.position.z) > 100) {
                    scene.remove(laser);
                    lasers.splice(i, 1);
                    continue;
                }
                
                // Check for collisions with enemies
                if (laser.userData.fromPlayer) {
                    // Check enemy collisions
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        if (enemy.position.distanceTo(laser.position) < 1.5) {
                            enemy.userData.health--;
                            
                            if (enemy.userData.health <= 0) {
                                createExplosion(enemy.position, 1);
                                scene.remove(enemy);
                                enemies.splice(j, 1);
                                score += 100;
                                document.getElementById('score').innerText = `SCORE: ${score}`;
                            }
                            
                            scene.remove(laser);
                            lasers.splice(i, 1);
                            break;
                        }
                    }
                    
                    // Check turret collisions
                    for (let j = turrets.length - 1; j >= 0; j--) {
                        const turret = turrets[j];
                        if (turret.position.distanceTo(laser.position) < 1.5) {
                            turret.userData.health--;
                            
                            if (turret.userData.health <= 0) {
                                createExplosion(turret.position, 1);
                                scene.remove(turret);
                                turrets.splice(j, 1);
                                score += 150;
                                document.getElementById('score').innerText = `SCORE: ${score}`;
                            }
                            
                            scene.remove(laser);
                            lasers.splice(i, 1);
                            break;
                        }
                    }
                    
                    // Check final target collision
                    const finalTarget = scene.children.find(child => child.userData && child.userData.isTarget);
                    if (finalTarget && laser.position.distanceTo(finalTarget.position) < 16) {
                        finalTarget.userData.health--;
                        
                        scene.remove(laser);
                        lasers.splice(i, 1);
                        
                        if (finalTarget.userData.health <= 0 && !targetDestroyed) {
                            targetDestroyed = true;
                            createExplosion(finalTarget.position, 10, 1000);
                            scene.remove(finalTarget);
                            score += 10000;
                            document.getElementById('score').innerText = `SCORE: ${score}`;
                        }
                    }
                } else {
                    // Laser from enemy or turret hitting player
                    if (laser.position.distanceTo(camera.position) < 1 && !gameOver) {
                        gameOver = true;
                        createExplosion(camera.position, 2);
                        
                        // Reset after short delay
                        setTimeout(() => {
                            resetGame();
                        }, 3000);
                        
                        scene.remove(laser);
                        lasers.splice(i, 1);
                    }
                }
            }
        }
        
        function updateEnemies(delta) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // Move the enemy
                enemy.position.x += enemy.userData.direction.x;
                enemy.position.y += enemy.userData.direction.y;
                
                if (enemy.position.z < camera.position.z + 100) {
                    // Make enemy face player
                    enemy.lookAt(camera.position);
                    
                    // Occasionally shoot at player
                    enemy.userData.timeSinceShot += delta;
                    if (enemy.userData.timeSinceShot > 2) {
                        enemy.userData.timeSinceShot = 0;
                        
                        const laserDirection = new THREE.Vector3(
                            camera.position.x - enemy.position.x,
                            camera.position.y - enemy.position.y,
                            camera.position.z - enemy.position.z
                        ).normalize();
                        
                        fireLaser(enemy.position.clone(), laserDirection, false);
                    }
                }
                
                // Check for collision with player
                if (enemy.position.distanceTo(camera.position) < 1 && !gameOver) {
                    gameOver = true;
                    createExplosion(camera.position, 2);
                    
                    setTimeout(() => {
                        resetGame();
                    }, 3000);
                }
                
                // Remove enemies that are far behind
                if (enemy.position.z > camera.position.z + 50) {
                    scene.remove(enemy);
                    enemies.splice(i, 1);
                }
            }
        }
        
        function updateTurrets(delta) {
            for (let i = turrets.length - 1; i >= 0; i--) {
                const turret = turrets[i];
                
                // Only activate turrets that are close enough
                if (turret.position.z < camera.position.z + 50 && turret.position.z > camera.position.z - 50) {
                    // Make turret face player
                    turret.lookAt(camera.position);
                    
                    // Occasionally shoot at player
                    turret.userData.timeToNextShot -= delta;
                    if (turret.userData.timeToNextShot <= 0) {
                        turret.userData.timeToNextShot = 2 + Math.random() * 2;
                        
                        const laserDirection = new THREE.Vector3(
                            camera.position.x - turret.position.x,
                            camera.position.y - turret.position.y,
                            camera.position.z - turret.position.z
                        ).normalize();
                        
                        fireLaser(turret.position.clone(), laserDirection, false);
                    }
                }
            }
        }
        
        function updateExplosions(delta) {
            for (let i = explosions.length - 1; i >= 0; i--) {
                const explosion = explosions[i];
                explosion.userData.age += delta;
                
                // Update particles in the explosion
                explosion.children.forEach(particle => {
                    particle.position.add(particle.userData.velocity);
                    particle.userData.lifespan -= delta;
                    
                    if (particle.userData.lifespan <= 0) {
                        particle.scale.multiplyScalar(0.9);
                    }
                });
                
                // Remove old explosions
                if (explosion.userData.age > 2) {
                    scene.remove(explosion);
                    explosions.splice(i, 1);
                }
            }
        }
        
        function animate() {
            if (showingVRButton) {
                renderer.render(scene, camera);
                return;
            }
            
            const delta = clock.getDelta();
            
            // Update controller state
            updateControllerState();
            
            // Handle player controls
            handleControls(delta);
            
            // Move player forward
            if (gameStarted && !gameOver) {
                camera.position.z -= playerSpeed;
                
                // Update reticle positions
                frontReticle.position.z = camera.position.z - 2;
                rearReticle.position.z = camera.position.z + 2;
            }
            
            // Update game entities
            updateLasers(delta);
            updateEnemies(delta);
            updateTurrets(delta);
            updateExplosions(delta);
            
            // Update rear-view mirror
            if (renderer.xr.isPresenting) {
                rearCamera.position.copy(camera.position);
                rearCamera.rotation.y = camera.rotation.y + Math.PI;
                
                const currentRenderTarget = renderer.getRenderTarget();
                renderer.setRenderTarget(rearMirror.userData.renderTarget);
                renderer.render(scene, rearCamera);
                renderer.setRenderTarget(currentRenderTarget);
            }
            
            // Render the scene
            renderer.render(scene, camera);
        }
        
        // Initialize the game
        init();
    </script>
</body>
</html>
