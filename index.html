<!doctype html>
<html>
<head>
<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
<meta name='mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<link rel='icon' type='image/png' sizes='32x32' href='favicon-32x32.png'>
<link rel='icon' type='image/png' sizes='96x96' href='favicon-96x96.png'>
<title>Ring Ring</title>
<style>
    
  body { 
  margin: 0; 
  display: flex; 
  flex-direction: column;
  justify-content: center; 
  align-items: center; 
  min-height: 100vh;
  height: auto;
  font-family: Arial, sans-serif;
  color: white;
  overflow: hidden;
  padding: 0;
  background-color: transparent; 
}

canvas { 
  display: block; 
  position: fixed; 
  top: 0;
  left: 0;
  z-index: -1; 
}

#loadingContainer {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center; 
  width: 100%;
  max-width: 800px;
  padding: 20px;
  box-sizing: border-box;
  position: absolute; 
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%); 
}

#monthsContainer {
  width: 100%;
  max-width: 400px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
  margin: 0 auto 40px auto;
}

#titleContainer {
  margin-bottom: 40px;
  text-align: center;
}

#gameTitle {
  font-size: 60px;
  font-weight: bold;
  color: #00ffff;
  text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
  margin: 0;
}

#gameSubtitle {
  font-size: 24px;
  margin-top: 10px;
  color: #ff00ff;
}

.monthButton {
  padding: 20px 40px;
  font-size: 24px;
  background-color: #00468e;
  color: white;
  border: none;
  border-radius: 10px;
  cursor: pointer;
  transition: all 0.3s ease;
  width: 100%;
  max-width: 300px;
  box-sizing: border-box;
  text-align: center;
  display: flex;
  flex-direction: column;
  align-items: center;
  position: relative; 
}

.monthButton:hover { 
  background-color: #005bb5; 
  transform: scale(1.05);
}

.monthButton .monthName {
  font-weight: bold;
  font-size: 28px;
  margin-bottom: 5px;
}

.monthButton .monthTheme {
  font-size: 18px;
  color: #00ffff;
}

.newBadge {
  background-color: #ff00ff;
  color: white;
  font-size: 14px;
  padding: 3px 8px;
  border-radius: 10px;
  position: absolute;
  top: -10px;
  right: -10px;
}

.leaderboardTooltip {
  position: absolute;
  background-color: rgba(0, 60, 120, 0.9);
  border: 2px solid #00ffff;
  border-radius: 10px;
  padding: 15px;
  width: 250px;
  max-height: 300px;
  overflow-y: auto;
  color: white;
  box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
  opacity: 0;
  transform: translateY(10px);
  transition: all 0.3s ease;
  pointer-events: none;
  z-index: 100;
}

.leaderboardTooltip.visible {
  opacity: 1;
  transform: translateY(0);
}

.leaderboardTooltip h3 {
  margin-top: 0;
  margin-bottom: 10px;
  color: #00ffff;
  text-align: center;
  font-size: 18px;
  border-bottom: 1px solid #00ffff;
  padding-bottom: 5px;
}

.leaderboardPlayer {
  display: flex;
  justify-content: space-between;
  margin-bottom: 5px;
}

.leaderboardRank {
  color: #ffff00;
  font-weight: bold;
  width: 30px;
}

.leaderboardName {
  flex-grow: 1;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  padding: 0 5px;
}

.leaderboardTime {
  color: #00ffff;
}

.noRecords {
  text-align: center;
  color: #888888;
  font-style: italic;
  margin: 15px 0;
}


</style>

<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>

</head>
<body>
<!--  Levelsio Vibe Jam link  -->
<a target="_blank" href="https://jam.pieter.com" style="font-family: 'system-ui', sans-serif; position: fixed; bottom: -1px; right: -1px; padding: 7px; font-size: 14px; font-weight: bold; background: #fff; color: #000; text-decoration: none; z-index: 10; border-top-left-radius: 12px; z-index: 10000; border: 1px solid #fff;">üïπÔ∏è Vibe Jam 2025</a>

<div id="loadingContainer">
  <div id="titleContainer">
    <h1 id="gameTitle">RING RING</h1>
    <div id="gameSubtitle">VR GAME</div>
  </div>
  
  <div id="monthsContainer" style="display: flex; flex-direction: column; gap: 20px;">
    <!-- Month buttons will be generated here -->
  </div>
</div>

<script type="importmap">
{
"imports": {
"three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
"three/examples/jsm/webxr/VRButton.js": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/webxr/VRButton.js",
"three/examples/jsm/webxr/XRControllerModelFactory.js": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/webxr/XRControllerModelFactory.js",
"three-mesh-ui": "https://cdn.jsdelivr.net/npm/three-mesh-ui@6.5.4/build/three-mesh-ui.module.js"
}
}
</script>

<script type="module">
import * as THREE from 'three';
import { VRButton } from 'three/examples/jsm/webxr/VRButton.js';

let camera, scene, renderer, controller1, controller2, sphere1, sphere2, ring, textMesh, timerMesh;
let grabbed = false, grabbingController = null, grabOffset = new THREE.Vector3(), grabRotationOffset = new THREE.Quaternion();
let startTime = null, elapsedTime = 0, font, timerFont, wire, wirePoints = [], wireMaterial, victorySound, contactSound;
const ringStartPosition = new THREE.Vector3(0, 1.35, -0.75);
let currentLevel = 1; // Track current level
let levelTimes = []; // Array to store completion times for each level


let explosionFragments = [];
let explosionStartTime = null;
let isExploding = false;
let confettiParticles = [];
let confettiStartTime = null;
let gameCompletionMeshes = [];

let transitionImmunity = false;
let xrInputSources = [];

let levelCompleted = false;
let gameCompleted = false;
let scoreSummaryMeshes = []; 
let keyboardMeshes = [];
let initialsDisplayMesh;
let nameEntered = false;
let playerName = ""; // Empty string to start
let maxNameLength = 10;
let hoveredButton = null;
let keyboardActive = false;
let controllerRays = [];
const keyboardRaycaster = new THREE.Raycaster();
const tempVector = new THREE.Vector3();
let timerCenterOffset = 0;

let applauseSound, longApplauseSound, longHornsSound, hornsSound, chimeSound;
let isFlashing = false;  // wire flash flag
let levelMusic = []; // Array to store music for each level
let currentMusic = null; // Reference to currently playing music
let endGameMusic;

let selectedMonth = null;
let monthlyLevels = [];
let cachedMonths = {};

// Initialize Firebase
const firebaseConfig = {
  apiKey: "AIzaSyCvzAS8zXYraoP-a10eAMFAZX7u1TQNY-M",
  databaseURL: "https://ring-ring-vr-game-default-rtdb.firebaseio.com/",
  projectId: "ring-ring-vr-game"
};
firebase.initializeApp(firebaseConfig);

const levelsRef = firebase.database().ref('levels/months');
const leaderboardRef = firebase.database().ref('leaderboard');

loadAvailableMonths();

function loadAvailableMonths() {
  console.log("Loading available months...");
  
  levelsRef.once('value')
    .then(snapshot => {
      const monthsData = snapshot.val();
      console.log("Received months data:", monthsData ? 
        Object.keys(monthsData).length + " months" : "No months found");
      
      if (!monthsData || Object.keys(monthsData).length === 0) {
        console.log("No months data found, creating default months");
        createDefaultMonths();
        return;
      }
      
      // Container for month buttons
      const monthsContainer = document.getElementById('monthsContainer');
      monthsContainer.innerHTML = ''; // Clear existing content
      
      // Convert object to array and sort by date (newest first)
      const monthsArray = Object.keys(monthsData).map(key => {
        return {
          id: key,
          ...monthsData[key]
        };
      }).sort((a, b) => {
        // Assuming IDs are in YYYY-MM format
        return b.id.localeCompare(a.id);
      });
      
      // Create buttons for each month
      monthsArray.forEach((month, index) => {
        const button = createMonthButton(month, index);
        monthsContainer.appendChild(button);
      });

      // Always add April 2025 "Coming Soon" button if it doesn't exist
      if (!monthsArray.some(month => month.id === "2025-04")) {
        const aprilButton = document.createElement('div');
        aprilButton.className = 'monthButton';
        aprilButton.style.opacity = '0.6';
        aprilButton.style.transform = 'scale(0.9)'; // Make it smaller
        aprilButton.style.pointerEvents = 'none'; // Prevents hover state
        aprilButton.innerHTML = `
          <div class="monthName">April 2025</div>
          <div class="monthTheme">Coming Soon</div>
        `;
        aprilButton.addEventListener('click', () => {
          alert('April levels will be available next month!');
        });
        monthsContainer.appendChild(aprilButton);
      }
    })
    .catch(error => {
      console.error("Error loading months:", error);
      
      // Create default months if there's an error
      createDefaultMonths();
    });
}

function createDefaultMonths() {
  // Create default months in case Firebase doesn't have any yet
  const currentDate = new Date();
  const monthsContainer = document.getElementById('monthsContainer');
  monthsContainer.innerHTML = ''; // Clear existing content
  
 // Create March 2025 button
 const marchMonth = {
    id: "2025-03",
    name: "March 2025",
    theme: "Levels 1-5"
  };
  const marchButton = createMonthButton(marchMonth, 0);
  
  // Create April 2025 button (coming soon)
  const aprilButton = document.createElement('div');
  aprilButton.className = 'monthButton';
  aprilButton.style.opacity = '0.6';
  aprilButton.style.transform = 'scale(0.9)'; // Make it smaller
  aprilButton.style.pointerEvents = 'none'; // Prevents hover state
  aprilButton.innerHTML = `
    <div class="monthName">April 2025</div>
    <div class="monthTheme">Coming Soon</div>
  `;
  // Add a click handler to show a message
  aprilButton.addEventListener('click', () => {
    alert('April levels will be available next month!');
  });
  
  // Add buttons to container
  monthsContainer.appendChild(marchButton);
  monthsContainer.appendChild(aprilButton);
  
  // Create the default monthly data in Firebase
  createDefaultMonthData();
}

function createMonthButton(month, index) {
  const button = document.createElement('div');
  button.className = 'monthButton';
  button.style.position = 'relative'; // For badge positioning
  
  // Create HTML content for button
  button.innerHTML = `
    <div class="monthName">${month.name}</div>
    <div class="monthTheme">${month.theme}</div>
    ${index === 0 ? '<span class="newBadge">NEW</span>' : ''}
  `;
  
  // Add click handler
  button.addEventListener('click', () => {
    selectedMonth = month.id;
    enterVR(month.id);
  });

  // Create tooltip element (initially hidden)
  const tooltip = document.createElement('div');
  tooltip.className = 'leaderboardTooltip';
  tooltip.innerHTML = '<h3>Fastest Times</h3><div class="leaderboardContent">Loading...</div>';
  document.body.appendChild(tooltip);
  
  // Add hover handlers for desktop
  button.addEventListener('mouseenter', (event) => {
    // Position tooltip near the button
    const rect = button.getBoundingClientRect();
    tooltip.style.left = `${rect.right + 10}px`;
    tooltip.style.top = `${rect.top + window.scrollY}px`;
    
    // Show tooltip with loading message
    tooltip.classList.add('visible');
    
    // Fetch leaderboard data
    fetchLeaderboardForTooltip(month.id, tooltip);
  });
  
  button.addEventListener('mouseleave', () => {
    tooltip.classList.remove('visible');
  });
  
  // For mobile, use touch events
  button.addEventListener('touchstart', (event) => {
    // Don't show on mobile - just for touch feedback
    event.preventDefault(); // Prevent default to avoid immediate click
  });
  
  return button;
}

function fetchLeaderboardForTooltip(monthId, tooltipElement) {
  const leaderboardContent = tooltipElement.querySelector('.leaderboardContent');
  
  // Reference to the monthly leaderboard
  const monthLeaderboardRef = firebase.database().ref(`leaderboard/${monthId}`);
  
  monthLeaderboardRef.orderByChild('totalTime').limitToFirst(5).once('value')
    .then(snapshot => {
      const leaderboardData = [];
      
      // Convert Firebase snapshot to array
      snapshot.forEach(childSnapshot => {
        leaderboardData.push({
          name: childSnapshot.val().playerName || 'Anonymous',
          time: childSnapshot.val().totalTime || 0
        });
      });
      
      // Sort by time (lowest first)
      leaderboardData.sort((a, b) => a.time - b.time);
      
      // Update tooltip content
      if (leaderboardData.length > 0) {
        let html = '';
        leaderboardData.forEach((player, index) => {
          html += `
            <div class="leaderboardPlayer">
              <span class="leaderboardRank">#${index + 1}</span>
              <span class="leaderboardName">${player.name}</span>
              <span class="leaderboardTime">${formatTime(player.time)}</span>
            </div>
          `;
        });
        leaderboardContent.innerHTML = html;
      } else {
        leaderboardContent.innerHTML = '<div class="noRecords">No records yet.<br>Be the first!</div>';
      }
    })
    .catch(error => {
      console.error("Error fetching leaderboard:", error);
      leaderboardContent.innerHTML = '<div class="noRecords">Could not load leaderboard</div>';
    });
}

function createDefaultMonthData() {
  // Check if March 2025 exists
  levelsRef.child("2025-03").once("value", snapshot => {
    if (!snapshot.exists()) {
      // If it doesn't exist, create default level data
      levelsRef.child("2025-03").set({
        name: "March 2025",
        theme: "Levels 1-5",
        levels: [
          {
            name: "Gentle Start",
            difficulty: 1,
            params: {
              frequencies: [8, 6, 6],
              amplitudes: [0.05, 0.05, 0.05],
              rotationOffset: 0
            }
          },
          {
            name: "Twisted Path",
            difficulty: 2,
            params: {
              frequencies: [7, 5, 6],
              amplitudes: [0.07, 0.08, 0.07],
              rotationOffset: Math.PI / 5.3,
              heightVar: 0.06,
              radiusVar: 0.1
            }
          },
          {
            name: "Quantum Wave",
            difficulty: 3,
            params: {
              frequencies: [9, 7, 6],
              amplitudes: [0.07, 0.08, 0.07],
              rotationOffset: Math.PI / 1.1,
              sections: [
                {type: "ascent", factor: 0.12},
                {type: "oscillate", factor: 0.06},
                {type: "descent", factor: 0.12},
                {type: "smooth", factor: 0.2}
              ],
              heightFactor: 0.15,
              radiusVariation: 0.1
            }
          },
          {
            name: "Prime Pattern",
            difficulty: 4,
            params: {
              frequencies: [11, 7, 17],
              amplitudes: [0.07, 0.09, 0.06],
              rotationOffset: Math.PI / 6.3,
              sections: [
                {type: "ascent", factor: 0.15},
                {type: "oscillate", factor: 0.07},
                {type: "descent", factor: 0.15},
                {type: "smooth", factor: 0.1}
              ]
            }
          },
          {
            name: "Cosmic Loop",
            difficulty: 5,
            params: {
              frequencies: [10, 8, 12],
              amplitudes: [0.08, 0.08, 0.06],
              rotationOffset: Math.PI / 1.6,
              heightFactor: 0.14,
              radiusVariation: 0.16
            }
          }
        ]
      });
      console.log("Created default month data for March 2025");
    }
  });
}

async function enterVR(monthId) {
    console.log(`Selected month: ${monthId}`);
  
  // Check if WebXR is supported
  if (!navigator.xr) {
    alert('WebXR not supported by your browser. Please try a compatible browser with a VR headset.');
    return;
  }
  
  try {
    // Check if 'immersive-vr' is supported
    const isSessionSupported = await navigator.xr.isSessionSupported('immersive-vr');
    if (!isSessionSupported) {
      alert('VR not supported or no VR headset detected. Please connect a VR headset to play Ring Ring.');
      return;
    }
    
    // Load the level data for this month
    await loadMonthLevels(monthId);
    
    // Request VR session
    const session = await navigator.xr.requestSession('immersive-vr', { 
      optionalFeatures: ['local-floor', 'hand-tracking'] 
    });
    
    // Play chime sound
    if (chimeSound) {
      chimeSound.play().catch(error => console.log('Chime sound play error:', error));
    }
    
    // Initialize or reset the renderer if needed
    if (!renderer) {
      init();
    } else {
      // Reset the game state for the new month
      resetGameForNewMonth();
    }
    
    // Set the VR session
    renderer.xr.setSession(session);
    
    // Hide the UI
    document.getElementById('loadingContainer').style.display = 'none';
    
    // Track first frame rendered
    let firstFrameRendered = false;
    session.requestAnimationFrame(() => {
      console.log('First XR frame rendered');
      if (!firstFrameRendered) {
        firstFrameRendered = true;
        console.log('Waiting for controllers to initialize...');
        setTimeout(() => {
          initControllerHaptics();
        }, 1000);           
      }
    });
    
    // Listen for input source changes
    session.addEventListener('inputsourceschange', (event) => {
      console.log('Input sources changed:', event);
      setTimeout(initControllerHaptics, 500);
    });
    
  } catch (error) {
    console.error('Failed to enter VR:', error);
  }
}

async function loadMonthLevels(monthId) {
  // Check if we already have this month's data cached
  if (cachedMonths[monthId]) {
    monthlyLevels = cachedMonths[monthId];
    console.log(`Loaded cached month data for ${monthId}`);
    return;
  }
  
  // Otherwise, fetch from Firebase
  try {
    const snapshot = await levelsRef.child(monthId).once('value');
    const monthData = snapshot.val();
    
    if (monthData && monthData.levels) {
      // Cache the month data
      cachedMonths[monthId] = monthData.levels;
      monthlyLevels = monthData.levels;
      console.log(`Loaded month data for ${monthId}:`, monthlyLevels);
    } else {
      console.error(`No levels found for month ${monthId}`);
      // Fall back to built-in levels
      monthlyLevels = [];
    }
  } catch (error) {
    console.error(`Error loading levels for month ${monthId}:`, error);
    monthlyLevels = [];
  }
}

function resetGameForNewMonth() {
  // Reset game state for the new month
  currentLevel = 1;
  levelTimes = [];
  startTime = null;
  elapsedTime = 0;
  levelCompleted = false;
  gameCompleted = false;
  
  // Reset position and visibility
  ring.position.copy(ringStartPosition);
  ring.rotation.set(0, Math.PI / 2, 0);
  ring.visible = true;
  
  // Create wire for first level
  wire = createWire(currentLevel);
  
  // Update text displays
  updateLevelText();
  resetTimerDisplay();
}

function updateLevelText() {
  if (textMesh && font) {
    if (textMesh.geometry) textMesh.geometry.dispose();
    
    // Create new text geometry
    const textGeometry = new THREE.TextGeometry(`LEVEL ${currentLevel}/5`, { 
      font: font, 
      size: 0.02, 
      height: 0.005 
    });
    textGeometry.computeBoundingBox();
    
    // Center the geometry properly
    textGeometry.translate(
      -(textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x) / 2,
      -(textGeometry.boundingBox.max.y - textGeometry.boundingBox.min.y) / 2,
      0
    );
    
    // Reuse existing material or create new one
    if (!textMesh.material) {
      textMesh.material = new THREE.MeshStandardMaterial({ color: 0xffffff });
    }
    
    // Update geometry and position
    textMesh.geometry = textGeometry;
    textMesh.position.set(ring.position.x, ring.position.y + 0.2, ring.position.z);
    textMesh.visible = true;
  }
}

function resetTimerDisplay() {
  if (timerMesh && timerFont) {
    timerMesh.geometry.dispose();
    timerMesh.geometry = new THREE.TextGeometry('0:00:000', {
      font: timerFont,
      size: 0.02,
      height: 0.005,
    });
    timerMesh.geometry.computeBoundingBox();
    // Center the geometry itself
    timerMesh.geometry.translate(
      -(timerMesh.geometry.boundingBox.max.x - timerMesh.geometry.boundingBox.min.x) / 2,
      -(timerMesh.geometry.boundingBox.max.y - timerMesh.geometry.boundingBox.min.y) / 2,
      0
    );
    timerMesh.position.set(ring.position.x + timerCenterOffset, ring.position.y + 0.1, ring.position.z);
    timerMesh.visible = true;
  }
}


init();
animate();

function init() {
scene = new THREE.Scene();
camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.xr.enabled = true;
document.body.appendChild(renderer.domElement);

// Reset leaderboard on every game start for testing
 resetLeaderboard();
// console.log("Leaderboard reset for testing");

const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
light.position.set(0.5, 1, 0.25);
scene.add(light);

const ringGeometry = new THREE.TorusGeometry(0.075, 0.00625, 16, 100);
const ringMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 1.0, metalness: 1.0, roughness: 0.0 });
ring = new THREE.Mesh(ringGeometry, ringMaterial);
ring.position.copy(ringStartPosition);
ring.rotation.y = Math.PI / 2;
scene.add(ring);

for (let i = 1; i <= 5; i++) {
  const music = new Audio(`music_${i}.mp3`);
  music.loop = true; // Make music loop
  levelMusic.push(music);
}

const loader = new THREE.FontLoader();
loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (loadedFont) {
font = loadedFont;
console.log('Font loaded successfully!', font);
const textGeometry = new THREE.TextGeometry(`LEVEL ${currentLevel}/5`, { font: font, size: 0.02, height: 0.005 });
textGeometry.computeBoundingBox();
const centerOffset = -0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x);
textGeometry.translate(
  -(textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x) / 2,
  -(textGeometry.boundingBox.max.y - textGeometry.boundingBox.min.y) / 2,
  0
);
const textMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
textMesh = new THREE.Mesh(textGeometry, textMaterial);
textMesh.position.set(centerOffset, 2.0, -0.75);
textMesh.visible = true;
scene.add(textMesh);

// Load a monospaced font for the timer
const timerFontURL = 'https://threejs.org/examples/fonts/gentilis_regular.typeface.json';
loader.load(timerFontURL, function (loadedTimerFont) {
timerFont = loadedTimerFont;

// Use the loaded font for the timer with shorter format
const timerGeometry = new THREE.TextGeometry('0:00:000', { font: timerFont, size: 0.02, height: 0.005 });
timerGeometry.computeBoundingBox();
const timerCenterOffset = -0.5 * (timerGeometry.boundingBox.max.x - timerGeometry.boundingBox.min.x);
// Center the geometry itself
timerGeometry.translate(
  -(timerGeometry.boundingBox.max.x - timerGeometry.boundingBox.min.x) / 2,
  -(timerGeometry.boundingBox.max.y - timerGeometry.boundingBox.min.y) / 2,
  0
);
const timerMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
timerMesh = new THREE.Mesh(timerGeometry, timerMaterial);
timerMesh.position.set(timerCenterOffset, 1.8, -0.75);
timerMesh.visible = true;
scene.add(timerMesh);
});
});


const sphereGeometry = new THREE.SphereGeometry(0.05, 32, 32);
const sphereMaterial = new THREE.MeshStandardMaterial({ color: 0x0078d7, transparent: true, opacity: 0.5 });
sphere1 = new THREE.Mesh(sphereGeometry, sphereMaterial);
scene.add(sphere1);
sphere2 = new THREE.Mesh(sphereGeometry, sphereMaterial);
scene.add(sphere2);

controller1 = renderer.xr.getController(0);
controller1.addEventListener('selectstart', onSelectStart);
controller1.addEventListener('selectend', onSelectEnd);
controller1.addEventListener('squeezestart', onSelectStart);
controller1.addEventListener('squeezeend', onSelectEnd);
scene.add(controller1);

controller2 = renderer.xr.getController(1);
controller2.addEventListener('selectstart', onSelectStart);
controller2.addEventListener('selectend', onSelectEnd);
controller2.addEventListener('squeezestart', onSelectStart);
controller2.addEventListener('squeezeend', onSelectEnd);
scene.add(controller2);

window.addEventListener('resize', onWindowResize, false);

const vrButton = document.getElementById('vrButton');
if (vrButton) {
  vrButton.addEventListener('click', async () => {
try {
chimeSound.play().catch(error => console.log('Chime sound play error:', error));
const session = await navigator.xr.requestSession('immersive-vr', { optionalFeatures: ['local-floor', 'hand-tracking'] });
renderer.xr.setSession(session);
vrButton.style.display = 'none';

    // Set a flag to track first frame
    let firstFrameRendered = false;

     // Initialize haptics after the first frame is rendered
     session.requestAnimationFrame(() => {
      console.log('First XR frame rendered');
      if (!firstFrameRendered) {
        firstFrameRendered = true;
        console.log('Waiting for controllers to initialize...');
        setTimeout(() => {
          initControllerHaptics();
        }, 1000);           
      }
    });
    
    // Also listen for input source changes
    session.addEventListener('inputsourceschange', (event) => {
      console.log('Input sources changed:', event);
      setTimeout(initControllerHaptics, 500); // Small delay after change
    });


} catch (error) {
console.error('Failed to enter VR:', error);
}
});
}

const particlesGeometry = new THREE.BufferGeometry();
const particlesCount = 3000;
const posArray = new Float32Array(particlesCount * 3);
const minDistance = 5.0; // Minimum distance from center to avoid particles near wire
for (let i = 0; i < particlesCount * 3; i += 3) {
let x = (Math.random() - 0.5) * 100;
let y = (Math.random() - 0.5) * 100;
let z = (Math.random() - 0.5) * 100;

 // Calculate distance from center
 const distance = Math.sqrt(x*x + y*y + z*z);

   // If too close, push it outward to minimum distance
   if (distance < minDistance) {
    const scale = minDistance / distance;
    x *= scale;
    y *= scale;
    z *= scale;
  }

posArray[i] = x;
posArray[i + 1] = y;
posArray[i + 2] = z;
}
particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
const particlesMaterial = new THREE.PointsMaterial({ size: 0.2, color: 0x00ffff, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
scene.add(particlesMesh);

wire = createWire(currentLevel);

// Load all sound effects
victorySound = new Audio('short_horns.mp3');
contactSound = new Audio('contact.mp3');
applauseSound = new Audio('short_applause.mp3');
longApplauseSound = new Audio('long_applause.mp3');
longHornsSound = new Audio('long_horns.mp3');
chimeSound = new Audio('chime.mp3');
endGameMusic = new Audio('music_end.mp3');
}

// Function to initialize haptic feedback system using direct XR input sources
function initControllerHaptics() {
  console.log('Initializing haptic feedback system');
  
  // Clear any previous input sources
  xrInputSources = [];
  
  // Get current session
  const session = renderer.xr.getSession();
  if (!session) {
    console.warn('No XR session available for haptics');
    return;
  }

 // Get and store all input sources
 xrInputSources = Array.from(session.inputSources || []);
  console.log('Found input sources:', xrInputSources.length);
  
  // Log details about each input source
  xrInputSources.forEach((inputSource, index) => {
    console.log(`Input source ${index}:`, {
      handedness: inputSource.handedness,
      profiles: inputSource.profiles,
      hasGamepad: !!inputSource.gamepad
    });
  });
  
  // Set up listener for future input source changes
  session.addEventListener('inputsourceschange', (event) => {
    console.log('Input sources changed:', event);
    
    // Update our stored input sources
    xrInputSources = Array.from(session.inputSources || []);
    console.log('Updated input sources count:', xrInputSources.length);
    
    // Test newly added input sources
    if (event.added && event.added.length > 0) {
      event.added.forEach(source => {
        console.log('Testing new input source:', source.handedness);
        setTimeout(() => {
          triggerHapticFeedbackByHandedness(source.handedness, 0.7, 300);
        }, 500);
      });
    }
  });
}

//testing keyboard again
function forceShowKeyboard() {
  // First make sure keyboard is not already visible
  if (keyboardMeshes.length > 0) {
    return; // Keyboard already exists
  }
  
  console.log("Force showing keyboard");
  
  // Reset state variables
  playerName = "";
  nameEntered = false;
  keyboardActive = true;
  
  // Create keyboard
  const keyboard = createImprovedVirtualKeyboard();
  
  // Position keyboard in front of player
  if (keyboard) {
    keyboard.position.set(0, 1.2, -0.75);
    keyboard.visible = true;
    
    // Make sure keyboard is added to appropriate arrays
    gameCompletionMeshes.push(keyboard);
    
    // Ensure controller rays are visible
    createControllerRays();
  }
  return keyboard;
}



//reset leaderboard for testing
function resetLeaderboard() {
  // Clear main leaderboard
  firebase.database().ref('leaderboard').remove()
    .then(() => console.log('Leaderboard cleared!'))
    .catch(err => console.error('Error clearing leaderboard:', err));
  
  // Clear level records
  firebase.database().ref('records').remove()
    .then(() => console.log('Level records cleared!'))
    .catch(err => console.error('Error clearing records:', err));
}



//debug firebase initialization
console.log('Testing Firebase connection...');
leaderboardRef.once('value')
  .then(snapshot => {
    console.log('Firebase connection successful!');
    console.log('Current leaderboard data:', snapshot.val());
  })
  .catch(error => {
    console.error('Firebase connection error:', error);
  });


function createImprovedVirtualKeyboard() {
    keyboardActive = true;
    createControllerRays();

  // Remove any existing keyboard elements
  keyboardMeshes.forEach(mesh => {
    scene.remove(mesh);
    if (mesh.geometry) mesh.geometry.dispose();
    if (mesh.material) mesh.material.dispose();
  });
  keyboardMeshes = [];

  //check for font
  if (!font) {
    console.error("Font not loaded, cannot create keyboard");
    // Try again in a second
    setTimeout(createImprovedVirtualKeyboard, 1000);
    return null;
  }
  
  // Keyboard container to group all elements
  const keyboardContainer = new THREE.Group();
  keyboardContainer.name = "keyboardContainer"; 
  keyboardContainer.position.set(0, 1.3, -0.75);
  keyboardContainer.scale.set(0.4, 0.4, 0.4);
  scene.add(keyboardContainer);
  gameCompletionMeshes.push(keyboardContainer);
  keyboardMeshes.push(keyboardContainer);
  
  // Keyboard background panel
  const panelGeometry = new THREE.BoxGeometry(0.8, 0.65, 0.01);
  const panelMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x222222, 
    transparent: true, 
    opacity: 0.8 
  });
  const panel = new THREE.Mesh(panelGeometry, panelMaterial);
  panel.position.set(0, -0.08, -0.01);
  keyboardContainer.add(panel);
  keyboardMeshes.push(panel);
  
  // Display area for input
  const displayGeometry = new THREE.BoxGeometry(0.7, 0.08, 0.01);
  const displayMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x333333, 
    transparent: true, 
    opacity: 0.9 
  });
  const displayPanel = new THREE.Mesh(displayGeometry, displayMaterial);
  displayPanel.position.set(0, 0.15, 0);
  keyboardContainer.add(displayPanel);
  keyboardMeshes.push(displayPanel);
  
  // Create initial text display
  updateNameDisplay(keyboardContainer);
  
  // Define key rows
  const rows = [
    "1234567890",
    "QWERTYUIOP",
    "ASDFGHJKL",
    "ZXCVBNM"
  ];
  
  // Config
  const keySize = 0.06;
  const keyMargin = 0.01;
  const keyHeight = 0.06;
  const startY = 0.05;
  
  // Create all keys
  rows.forEach((row, rowIndex) => {
    const rowWidth = row.length * (keySize + keyMargin) - keyMargin;
    const startX = -rowWidth / 2;
    
    row.split('').forEach((letter, colIndex) => {
      const x = startX + colIndex * (keySize + keyMargin) + keySize/2;
      const y = startY - rowIndex * (keyHeight + keyMargin);
      
      const keyGeometry = new THREE.BoxGeometry(keySize, keyHeight, 0.01);
      const keyMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x444444,
        emissive: 0x222222,
        emissiveIntensity: 0.2
      });
      const key = new THREE.Mesh(keyGeometry, keyMaterial);
      key.position.set(x, y, 0);
      keyboardContainer.add(key);
      keyboardMeshes.push(key);
      
      // Add letter text
      const textGeometry = new THREE.TextGeometry(letter, { 
        font: font, 
        size: 0.025, 
        height: 0.001 
      });
      const textMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xffffff 
      });
      const textMesh = new THREE.Mesh(textGeometry, textMaterial);
      textGeometry.computeBoundingBox();
      const textOffset = new THREE.Vector3(
        -(textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x) / 2,
        -(textGeometry.boundingBox.max.y - textGeometry.boundingBox.min.y) / 2,
        0
      );
      textMesh.position.copy(textOffset);
      textMesh.position.z = 0.006;
      key.add(textMesh);
      
      // Make key interactive
      key.userData.isButton = true;
      key.userData.buttonType = 'letter';
      key.userData.letter = letter;
      key.userData.defaultColor = 0x444444;
      key.userData.hoverColor = 0x666666;
      key.userData.pressColor = 0x888888;
    });
  });
  
  // Special keys - common row
  const specialRow = [
    { label: "Space", width: 0.25, action: 'space', x: -0.15 },
    { label: "Back", width: 0.15, action: 'backspace', x: 0.15, color: 0x884444 }
  ];
  
  const specialY = startY - 4 * (keyHeight + keyMargin);
  
  specialRow.forEach(key => {
    const keyGeometry = new THREE.BoxGeometry(key.width, keyHeight, 0.01);
    const keyMaterial = new THREE.MeshStandardMaterial({ 
      color: key.color || 0x444444,
      emissive: key.color ? 0x220000 : 0x222222,
      emissiveIntensity: 0.2
    });
    const keyMesh = new THREE.Mesh(keyGeometry, keyMaterial);
    keyMesh.position.set(key.x, specialY, 0);
    keyboardContainer.add(keyMesh);
    keyboardMeshes.push(keyMesh);
    
    // Add text label
    const textGeometry = new THREE.TextGeometry(key.label, { 
      font: font, 
      size: 0.02, 
      height: 0.001 
    });
    const textMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
    const textMesh = new THREE.Mesh(textGeometry, textMaterial);
    textGeometry.computeBoundingBox();
    const textOffset = new THREE.Vector3(
      -(textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x) / 2,
      -(textGeometry.boundingBox.max.y - textGeometry.boundingBox.min.y) / 2,
      0
    );
    textMesh.position.copy(textOffset);
    textMesh.position.z = 0.006;
    keyMesh.add(textMesh);
    
    // Set button data
    keyMesh.userData.isButton = true;
    keyMesh.userData.buttonType = key.action;
    keyMesh.userData.defaultColor = key.color || 0x444444;
    keyMesh.userData.hoverColor = key.color ? 0xbb5555 : 0x666666;
    keyMesh.userData.pressColor = key.color ? 0xff6666 : 0x888888;
  });
  
  // Submit button
  const submitGeometry = new THREE.BoxGeometry(0.7, 0.08, 0.01);
  const submitMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x008800,
    emissive: 0x004400,
    emissiveIntensity: 0.3
  });
  const submitButton = new THREE.Mesh(submitGeometry, submitMaterial);
  submitButton.position.set(0, specialY - keyHeight - keyMargin*2, 0);
  keyboardContainer.add(submitButton);
  keyboardMeshes.push(submitButton);
  
  // Add submit text
  const submitTextGeometry = new THREE.TextGeometry("SUBMIT NAME", { 
    font: font, 
    size: 0.03, 
    height: 0.001 
  });
  const submitTextMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
  const submitTextMesh = new THREE.Mesh(submitTextGeometry, submitTextMaterial);
  submitTextGeometry.computeBoundingBox();
  const submitTextOffset = new THREE.Vector3(
    -(submitTextGeometry.boundingBox.max.x - submitTextGeometry.boundingBox.min.x) / 2,
    -(submitTextGeometry.boundingBox.max.y - submitTextGeometry.boundingBox.min.y) / 2,
    0
  );

  submitTextMesh.userData.isNonInteractive = true;
  submitTextMesh.raycast = function() {}; 
  submitTextMesh.position.copy(submitTextOffset);
  submitTextMesh.position.z = 0.008;
  submitButton.add(submitTextMesh);
  
  submitButton.userData.isButton = true;
  submitButton.userData.buttonType = 'submit';
  submitButton.userData.defaultColor = 0x008800;
  submitButton.userData.hoverColor = 0x00aa00;
  submitButton.userData.pressColor = 0x00cc00;
  
  return keyboardContainer;
}

function updateNameDisplay(container) {
  // Remove existing display elements
  if (initialsDisplayMesh) {
    if (container) {
      container.remove(initialsDisplayMesh);
    } else {
      scene.remove(initialsDisplayMesh);
    }
    
    if (initialsDisplayMesh.geometry) {
      initialsDisplayMesh.geometry.dispose();
    }
  }
  
  // Clear any existing cursor blink interval
  if (initialsDisplayMesh && initialsDisplayMesh.userData.blinkInterval) {
    clearInterval(initialsDisplayMesh.userData.blinkInterval);
  }
  
  // Create a group to hold both name and cursor
  const textGroup = new THREE.Group();
  
  // Create the name text (without cursor)
  const nameGeometry = new THREE.TextGeometry(playerName, { 
    font: font, 
    size: 0.04, 
    height: 0.001 
  });
  
  const nameMesh = new THREE.Mesh(
    nameGeometry, 
    new THREE.MeshStandardMaterial({ color: 0x00ffff })
  );
  
  nameGeometry.computeBoundingBox();
  const nameWidth = nameGeometry.boundingBox.max.x - nameGeometry.boundingBox.min.x;
  
  // Position name text at left side of the centered group
  nameMesh.position.set(0, 0, 0.006);
  textGroup.add(nameMesh);
  
  // Create separate cursor mesh only if we haven't reached max length
  let cursorMesh = null;
  if (playerName.length < maxNameLength) {
    const cursorGeometry = new THREE.TextGeometry("|", { 
      font: font, 
      size: 0.04, 
      height: 0.001 
    });
    
    cursorMesh = new THREE.Mesh(
      cursorGeometry, 
      new THREE.MeshStandardMaterial({ color: 0x00ffff })
    );
    
    // Position cursor right after the name text
    cursorMesh.position.set(nameWidth, 0, 0.006);
    textGroup.add(cursorMesh);
    
    // Set up blinking for cursor only
    const blinkInterval = setInterval(() => {
      if (cursorMesh && cursorMesh.parent) {
        cursorMesh.visible = !cursorMesh.visible;
      } else {
        clearInterval(blinkInterval);
      }
    }, 500);
    
    textGroup.userData.blinkInterval = blinkInterval;
  }
  
  // Center the entire text group
  textGroup.position.set(-nameWidth/2, 0, 0);
  
  // Add the group to the container or scene
  if (container) {
    textGroup.position.y = 0.13;
    container.add(textGroup);
  } else {
    textGroup.position.set(-nameWidth/2, 1.05, -0.75);
    scene.add(textGroup);
    gameCompletionMeshes.push(textGroup);
  }
  
  // Store reference to the text group
  initialsDisplayMesh = textGroup;
}

function updateRecordHolderDisplays() {
  if (!window.recordHolderMeshes || !window.recordHolderMeshes.length) return;
  
  const displayName = playerName || "...";
  
  for (let i = 0; i < window.recordHolderMeshes.length; i++) {
    if (window.recordHolderMeshes[i]) {
      // Remove old geometry
      if (window.recordHolderMeshes[i].geometry) {
        window.recordHolderMeshes[i].geometry.dispose();
      }
      
      // Create new text geometry with current player name - SAME SIZE as original
      const newGeometry = new THREE.TextGeometry(
        `${formatTime(levelTimes[i] || 0)} - ${displayName}`,  
        { font: font, size: 0.018, height: 0.005 }
      );
      
      // Center the text properly
      newGeometry.computeBoundingBox();
      newGeometry.translate(
        -(newGeometry.boundingBox.max.x - newGeometry.boundingBox.min.x) / 2,
        -(newGeometry.boundingBox.max.y - newGeometry.boundingBox.min.y) / 2,
        0
      );
      
      // Store the original position
      const originalPosition = window.recordHolderMeshes[i].position.clone();
      
      // Update the geometry
      window.recordHolderMeshes[i].geometry = newGeometry;
      
      // Ensure material color and position are preserved
      if (window.recordHolderMeshes[i].material) {
        window.recordHolderMeshes[i].material.color.set(0xff8000);
        window.recordHolderMeshes[i].material.emissive.set(0xff8000);
        window.recordHolderMeshes[i].material.emissiveIntensity = 0.3;
      }
    }
  }
}

// Function to trigger haptics by controller handedness
function triggerHapticFeedbackByHandedness(handedness, intensity, duration) {
  // Find the input source for the specified hand
  const inputSource = xrInputSources.find(source => source.handedness === handedness);
  
  if (!inputSource) {
    console.warn(`No input source found for ${handedness} hand`);
    return;
  }
  
  console.log(`Attempting haptic feedback on ${handedness} controller:`, inputSource);
  
  try {
    // Try to use the gamepad haptics
    if (inputSource.gamepad) {
      console.log(`Gamepad found for ${handedness}:`, inputSource.gamepad);
      
      // Method 1: Standard haptic actuators array
      if (inputSource.gamepad.hapticActuators && inputSource.gamepad.hapticActuators.length > 0) {
        console.log(`Using hapticActuators for ${handedness}`);
        return inputSource.gamepad.hapticActuators[0].pulse(intensity, duration);
      } 
      
      // Method 2: Single haptic actuator (some Quest versions)
      if (inputSource.gamepad.hapticActuator) {
        console.log(`Using single hapticActuator for ${handedness}`);
        return inputSource.gamepad.hapticActuator.pulse(intensity, duration);
      }
      
      // Method 3: Vibration actuator (older standard)
      if (inputSource.gamepad.vibrationActuator) {
        console.log(`Using vibrationActuator for ${handedness}`);
        return inputSource.gamepad.vibrationActuator.playEffect('dual-rumble', {
          duration: duration,
          strongMagnitude: intensity,
          weakMagnitude: intensity
        });
      }
      
      // Log all available properties on the gamepad
      console.log(`All gamepad properties for ${handedness}:`);
      for (const prop in inputSource.gamepad) {
        console.log(`- ${prop}:`, inputSource.gamepad[prop]);
      }
    }
    
    console.warn(`No haptic capability found for ${handedness} controller`);
  } catch (error) {
    console.error(`Error triggering haptic on ${handedness} controller:`, error);
  }
}

// Function to trigger haptics on a controller
function triggerHapticFeedback(controller, intensity, duration) {
  // Determine handedness from controller index
  const handedness = controller === controller1 ? 'left' : 'right';
  return triggerHapticFeedbackByHandedness(handedness, intensity, duration);
}

// create visible controller rays while keyboard is active
function createControllerRays() {
  // Clear any existing rays
  controllerRays.forEach(ray => {
    if (ray.parent) ray.parent.remove(ray);
    if (ray.geometry) ray.geometry.dispose();
    if (ray.material) ray.material.dispose();
  });
  controllerRays = [];
  
  // Create a ray for each controller
  [controller1, controller2].forEach((controller, index) => {
    // Create ray geometry (a thin, long cylinder)
    const rayGeometry = new THREE.CylinderGeometry(0.001, 0.001, 3, 8);
    rayGeometry.rotateX(Math.PI / 2); // Point forward
    rayGeometry.translate(0, 0, -1.5); // Center ray with origin at controller
    
    // Create material with appropriate color
    const rayMaterial = new THREE.MeshBasicMaterial({
      color: index === 0 ? 0x0088ff : 0xff8800,
      transparent: true,
      opacity: 0.7
    });
    
    // Create mesh and add to controller
    const rayMesh = new THREE.Mesh(rayGeometry, rayMaterial);
    controller.add(rayMesh);
    controllerRays.push(rayMesh);
  });
}

// Function to remove rays when keyboard is dismissed
function hideControllerRays() {
  controllerRays.forEach(ray => {
    if (ray.parent) ray.parent.remove(ray);
    if (ray.geometry) ray.geometry.dispose();
    if (ray.material) ray.material.dispose();
  });
  controllerRays = [];
  keyboardActive = false;
}

// Function to make the wire flash
function flashWire(times = 3, isGameComplete = false) {
if (isFlashing) return;
isFlashing = true;

let flashCount = 0;
const maxFlashes = times * 2; // Each flash is white->blue, so double the count
const flashDuration = isGameComplete ? 250 : 150; // Slower flashing for game complete

function flash() {
if (flashCount >= maxFlashes) {
isFlashing = false;
return;
}

const colors = wire.geometry.attributes.color.array;
const isWhite = flashCount % 2 === 0;

for (let i = 0; i < colors.length; i += 3) {
colors[i] = isWhite ? 1 : 0;     // R
colors[i + 1] = isWhite ? 1 : 0; // G
colors[i + 2] = 1;               // B (always 1 for white or blue)
}

wire.geometry.attributes.color.needsUpdate = true;
flashCount++;

setTimeout(flash, flashDuration);
}

flash();
}

// decide which wire creation method to use
function createWire(level) {
  // Remove old wire if it exists
  if (wire) {
    scene.remove(wire);
    if (wire.geometry) wire.geometry.dispose();
  }
  
  // Check if we're using monthly levels
  if (selectedMonth && monthlyLevels.length > 0) {
    return createMonthlyWire(level);
  } else {
    // Fall back to original wire patterns
    return createBuiltinWire(level);
  }
}

function createMonthlyWire(level) {
  // Make sure we're not exceeding array bounds
  if (level < 1 || level > monthlyLevels.length) {
    console.error(`Invalid level ${level}, max is ${monthlyLevels.length}`);
    return createBuiltinWire(level); // Fallback
  }
  
  // Get level parameters
  const levelData = monthlyLevels[level - 1];
  const params = levelData.params;
  
  const points = [];
  const segments = 200;
  const radius = 0.75;
  
  // Extract parameters with defaults
  const rotationOffset = params.rotationOffset || 0;
  const frequencies = params.frequencies || [8, 6, 6];
  const amplitudes = params.amplitudes || [0.05, 0.05, 0.05];
  
  for (let i = 0; i <= segments; i++) {
    const t = i / segments;
    const angle = t * Math.PI * 2;
    const rotatedAngle = angle + rotationOffset;
    
    // Base wave components
    let waveX = Math.sin(angle * frequencies[0]) * amplitudes[0];
    let waveY = Math.cos(angle * frequencies[1]) * amplitudes[1];
    let waveZ = Math.sin(angle * frequencies[2]) * amplitudes[2];
    
    // Handle section-specific modifications
    if (params.sections) {
      const section = Math.floor(angle / (Math.PI/2)); // 0-3 sections
      if (section < params.sections.length) {
        const sectionData = params.sections[section];
        const sectionFactor = getSectionFactor(section, t);
        
        // Apply effects based on section type
        switch(sectionData.type) {
          case 'ascent':
            waveY += Math.sin(sectionFactor * Math.PI * 0.5) * sectionData.factor;
            break;
          case 'oscillate': 
            waveX += Math.sin(sectionFactor * Math.PI * 3) * sectionData.factor;
            waveZ += Math.cos(sectionFactor * Math.PI * 3) * sectionData.factor;
            break;
          case 'descent':
            waveY -= Math.sin(sectionFactor * Math.PI * 0.5) * sectionData.factor;
            break;
          case 'smooth':
            waveX *= (1.2 - sectionFactor * sectionData.factor);
            waveZ *= (1.2 - sectionFactor * sectionData.factor);
            break;
        }
      }
    }
    
    // Calculate radius variation if specified
    const radiusVar = params.radiusVariation ? 
      (1 + Math.sin(angle * 2) * params.radiusVariation) : 1.0;
    
    // Calculate height variation
    const heightVar = params.heightFactor ? 
      Math.sin(angle * 2) * params.heightFactor : 0;
    
    // Final position calculation
    const x = (Math.cos(rotatedAngle) * radius * radiusVar) + waveX;
    const y = 1.4 + waveY + heightVar;
    const z = (Math.sin(rotatedAngle) * radius * radiusVar) + waveZ;
    
    points.push(new THREE.Vector3(x, y, z));
  }
  
  // Create the wire geometry and material
  wirePoints = points;
  const geometry = new THREE.BufferGeometry().setFromPoints(points);
  const colors = new Float32Array(points.length * 3);
  for (let i = 0; i < points.length; i++) {
    colors[i * 3] = 1;     // R
    colors[i * 3 + 1] = 0; // G
    colors[i * 3 + 2] = 1; // B
  }
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  wireMaterial = new THREE.LineBasicMaterial({ vertexColors: true, linewidth: 7 });
  
  wire = new THREE.Line(geometry, wireMaterial);
  scene.add(wire);
  
  console.log(`Monthly wire for level ${level} created:`, wire);
  return wire;
}

// Helper for section calculations
function getSectionFactor(section, t) {
  return section === 0 ? t * 4 : 
         section === 1 ? (t - 0.25) * 4 :
         section === 2 ? (t - 0.5) * 4 : 
         (t - 0.75) * 4;
}



function createBuiltinWire(level = 1) {
// Remove old wire if it exists
if (wire) {
scene.remove(wire);
if (wire.geometry) wire.geometry.dispose();
}

const points = [];
const segments = 200;
const radius = 0.75;

// Add rotation offset for different levels
const rotationOffset = level === 2 ? Math.PI / 5.3 : 
level === 3 ? Math.PI / 1.1 : 
level === 4 ? Math.PI / 6.3 : 
level === 5 ? Math.PI / 1.6 : 0;

for (let i = 0; i <= segments; i++) {
const t = i / segments;
const angle = t * Math.PI * 2;

let waveX, waveY, waveZ, x, y, z;

/* smooth testing wire
if (level === 0) {
      // Test level - perfectly smooth circular wire
      x = Math.cos(angle) * radius;
      y = 1.4; // Fixed height
      z = Math.sin(angle) * radius;
    }
  */

if (level === 1) {
// Level 1 wire pattern
waveX = Math.sin(angle * 8) * 0.05;
waveY = Math.cos(angle * 6) * 0.05;
x = (Math.cos(angle) * radius) + waveX;
y = 1.4 + waveY;
z = (Math.sin(angle) * radius) + waveX;
} 
else if (level === 2) {
// Level 2 wire pattern 
waveX = Math.sin(angle * 7) * 0.07 + Math.cos(angle * 3) * 0.04;
waveY = Math.cos(angle * 5) * 0.08 + Math.sin(angle * 9) * 0.03;
waveZ = Math.sin(angle * 6) * 0.07 + Math.cos(angle * 4) * 0.05;

// Create gentle undulations in height
const heightVar = Math.sin(angle * 3) * 0.06;

const rotatedAngle = angle + rotationOffset;
// Create an elliptical path 
x = (Math.cos(rotatedAngle) * radius * (1 + Math.sin(angle * 2) * 0.1)) + waveX;
y = 1.4 + waveY + heightVar;
z = (Math.sin(rotatedAngle) * radius * (1 + Math.cos(angle * 2) * 0.08)) + waveZ;
}
else if (level === 5) {
// Level 3 wire pattern
waveX = Math.sin(angle * 10) * 0.08;
waveY = Math.cos(angle * 8) * 0.08 + Math.sin(angle * 16) * 0.03;
waveZ = Math.sin(angle * 12) * 0.06;

const rotatedAngle = angle + rotationOffset;
x = (Math.cos(rotatedAngle) * radius) + waveX;
y = 1.4 + waveY;
z = (Math.sin(rotatedAngle) * radius) + waveZ;
}
else if (level === 4) {
// Level 4 wire pattern - most complex but still navigable

// Use prime number frequencies for less predictable patterns
waveX = Math.sin(angle * 11) * 0.07 + Math.cos(angle * 5) * 0.05;
waveY = Math.cos(angle * 7) * 0.09 + Math.sin(angle * 13) * 0.04;
waveZ = Math.sin(angle * 17) * 0.06 + Math.cos(angle * 3) * 0.07;

// Add some controlled chaos with sectional variations
// Divide the wire into sections with different behaviors
const section = Math.floor(angle / (Math.PI/2)); // 0-3 sections

// Base Y position that's consistent across all sections
y = 1.4 + waveY + Math.sin(angle * 2) * 0.07;

// Apply section-specific modifications to y-coordinate
const sectionFactor = section === 0 ? t * 4 : 
section === 1 ? (t - 0.25) * 4 :
section === 2 ? (t - 0.5) * 4 :
(t - 0.75) * 4;

if (section === 0) {
// First quarter - spiral up - add to base y
y += (sectionFactor * 0.15);
} else if (section === 3) {
// Fourth quarter - smooth transition back
// Use a sine curve for smooth transition
y += Math.sin(sectionFactor * Math.PI) * 0.08;
}

// Create smooth transition variations in radius
const radiusVar = 1 + 0.15 * Math.sin(angle * 2) - 0.05 * Math.cos(angle * 5);

const rotatedAngle = angle + rotationOffset;
x = (Math.cos(rotatedAngle) * radius * radiusVar) + waveX;
// y is already set above
z = (Math.sin(rotatedAngle) * radius * radiusVar) + waveZ;
}

else if (level === 3) {
  // Level 5 - challenging but navigable
  // Use moderate frequency combinations
  waveX = Math.sin(angle * 9) * 0.07 + Math.cos(angle * 5) * 0.05;
  waveY = Math.cos(angle * 7) * 0.08 + Math.sin(angle * 4) * 0.06;
  waveZ = Math.sin(angle * 6) * 0.07 + Math.cos(angle * 3) * 0.05;

  // Create gentle undulation with variable height
  const heightFactor = Math.sin(angle * 2) * 0.15;
  y = 1.4 + waveY + heightFactor;
  
  // Create interesting path with 4 distinct sections
  const section = Math.floor(angle / (Math.PI/2)); // 0-3 sections
  const sectionFactor = section === 0 ? t * 4 : 
                        section === 1 ? (t - 0.25) * 4 :
                        section === 2 ? (t - 0.5) * 4 : 
                        (t - 0.75) * 4;
  
  // Section-specific modifications
  if (section === 0) {
    // First quarter - gradual ascent
    y += Math.sin(sectionFactor * Math.PI * 0.5) * 0.12;
  } else if (section === 1) {
    // Second quarter - oscillating path
    waveX += Math.sin(sectionFactor * Math.PI * 3) * 0.06;
    waveZ += Math.cos(sectionFactor * Math.PI * 3) * 0.06;
  } else if (section === 2) {
    // Third quarter - gentle descent with wider radius
    y -= Math.sin(sectionFactor * Math.PI * 0.5) * 0.12;
    waveX *= 1.2;
    waveZ *= 1.2;
  } else {
    // Fourth quarter - smooth transition back to start
    waveX *= (1.2 - sectionFactor * 0.2);
    waveZ *= (1.2 - sectionFactor * 0.2);
  }

  // Add some controlled radius variation
  const radiusVar = 1 + Math.sin(angle * 2) * 0.1;
  
  const rotatedAngle = angle + rotationOffset;
  x = (Math.cos(rotatedAngle) * radius * radiusVar) + waveX;
  // y is already set above
  z = (Math.sin(rotatedAngle) * radius * radiusVar) + waveZ;
}

points.push(new THREE.Vector3(x, y, z));
}

wirePoints = points;
const geometry = new THREE.BufferGeometry().setFromPoints(points);
const colors = new Float32Array(points.length * 3);
for (let i = 0; i < points.length; i++) {
colors[i * 3] = 1; // R
colors[i * 3 + 1] = 0; // G
colors[i * 3 + 2] = 1; // B
}
geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
wireMaterial = new THREE.LineBasicMaterial({ vertexColors: true, linewidth: 7 });

wire = new THREE.Line(geometry, wireMaterial);
scene.add(wire);

console.log(`Wire for level ${level} created:`, wire);
return wire;
}

function explodeRing() {
  if (isExploding) return; // Prevent multiple explosions
  isExploding = true;
  explosionStartTime = Date.now();
  
  // Hide the original ring
  ring.visible = false;
  
  // Create fragments
  const segments = 20;
  for (let i = 0; i < segments; i++) {
    // Create fragment geometry (smaller than the original ring)
    const fragGeometry = new THREE.TorusGeometry(0.075, 0.00625, 8, 6, Math.PI * 2 / segments);
    const fragMaterial = new THREE.MeshStandardMaterial({ 
      color: 0x00ff00, 
      emissive: 0x00ff00, 
      emissiveIntensity: 1.0, 
      metalness: 1.0, 
      roughness: 0.0 
    });
    const fragment = new THREE.Mesh(fragGeometry, fragMaterial);
    
    // Position and rotate to match the original ring
    fragment.position.copy(ring.position);
    fragment.rotation.copy(ring.rotation);
    
    // Rotate fragment to correct position in the ring
    fragment.rotateOnAxis(new THREE.Vector3(0, 1, 0), (i / segments) * Math.PI * 2);
    
    // Add explosion velocity - direction slightly outward from the center
    const angle = (i / segments) * Math.PI * 2;
    const direction = new THREE.Vector3(Math.cos(angle), 0.2, Math.sin(angle));
    direction.normalize();
    
    fragment.userData.velocity = direction.multiplyScalar(0.02 + Math.random() * 0.02);
    fragment.userData.rotationSpeed = {
      x: (Math.random() - 0.5) * 0.2,
      y: (Math.random() - 0.5) * 0.2,
      z: (Math.random() - 0.5) * 0.2
    };
    
    // Add to scene and array
    scene.add(fragment);
    explosionFragments.push(fragment);
  }
}

function onWindowResize() {
camera.aspect = window.innerWidth / window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth, window.innerHeight);
}

function checkCollision() {
if (!ring.visible) return false;

const ringVertices = ring.geometry.attributes.position.array;
const ringMatrixWorld = ring.matrixWorld;
const thresholdDistance = 0.01; // Adjust this value as needed

for (let i = 0; i < ringVertices.length; i += 3) {
const vertex = new THREE.Vector3(ringVertices[i], ringVertices[i + 1], ringVertices[i + 2]);
vertex.applyMatrix4(ringMatrixWorld);

for (let j = 0; j < wirePoints.length; j++) {
const distance = vertex.distanceTo(wirePoints[j]);
if (distance < thresholdDistance) {
console.log('Collision detected');
return true;
}
}
}

return false;
}

function onSelectStart(event) {
  const controllerPosition = event.target.position;
  
  // Check for button interactions first if game is completed OR keyboard is active
  if (gameCompletionMeshes.length > 0 || keyboardActive) {
    console.log('Checking for UI interactions, keyboard active:', keyboardActive);
    
    const raycaster = new THREE.Raycaster();
    const direction = new THREE.Vector3(0, 0, -1);
    direction.applyQuaternion(event.target.quaternion);
    raycaster.set(controllerPosition, direction);
    
    // Use recursive intersection to properly detect buttons in hierarchies
    const buttonIntersects = raycaster.intersectObjects(gameCompletionMeshes, true);
    console.log('Button intersects:', buttonIntersects.length);
    
    if (buttonIntersects.length > 0) {
      // Find the actual button - either the intersected object or one of its parents
      let intersectedObj = buttonIntersects[0].object;
  
  // Skip non-interactive elements (like text on buttons)
  if (intersectedObj.userData && intersectedObj.userData.isNonInteractive) {
    // Try next intersection if available
    if (buttonIntersects.length > 1) {
      intersectedObj = buttonIntersects[1].object;
    } else {
      // Check if parent of non-interactive element is a button
      let parent = intersectedObj.parent;
      if (parent && parent.userData && parent.userData.isButton) {
        // Use the parent button instead
        intersectedObj = parent;
      }
    }
  }
  
  let button = null;
  
  // Check if the object itself is a button
  if (intersectedObj.userData && intersectedObj.userData.isButton) {
    button = intersectedObj;
  } else {
    // Check parent hierarchy for a button
    let parent = intersectedObj.parent;
    while (parent && !button) {
      if (parent.userData && parent.userData.isButton) {
        button = parent;
      }
      parent = parent.parent;
    }
  }
      
      if (button) {
        console.log('Button interaction:', button.userData.buttonType);
        
        if (button.userData.buttonType === 'letter' || 
            button.userData.buttonType === 'space' || 
            button.userData.buttonType === 'backspace' || 
            button.userData.buttonType === 'submit') {
          // Use the centralized handler for keyboard buttons
          handleKeyPress(button);
          triggerHapticFeedbackByHandedness(event.target === controller1 ? 'left' : 'right', 0.3, 50);
          return;
        }
        else if (button.userData.buttonType === 'restart') {
          console.log('Restarting game...');
           // Stop end game music
  if (endGameMusic) {
    endGameMusic.pause();
  }
          restartGame();
          triggerHapticFeedbackByHandedness('left', 0.4, 100);
          triggerHapticFeedbackByHandedness('right', 0.4, 100);
          return;
        }
        else if (button.userData.buttonType === 'quit') {
  console.log('Quitting game...');
  // Stop end game music
  if (endGameMusic) {
    endGameMusic.pause();
  }
  
  // Play collision sound for feedback
  contactSound.play().catch(error => console.log('Sound play error:', error));
  
  // Stronger haptic feedback
  triggerHapticFeedbackByHandedness('left', 0.8, 200);
  triggerHapticFeedbackByHandedness('right', 0.8, 200);
  
  // Exit VR session after a short delay to let sound finish
  setTimeout(() => {
    if (renderer.xr.isPresenting) {
      renderer.xr.getSession().end();
    }
  }, 300); // 300ms delay
  
  return;
}
      }
    }
  }

  // Only handle ring grabbing if game is not completed
  if (!gameCompleted) {
    const ringBox = new THREE.Box3().setFromObject(ring);
    const sphereBox1 = new THREE.Sphere(sphere1.position, 0.05);
    const sphereBox2 = new THREE.Sphere(sphere2.position, 0.05);

    if (ringBox.intersectsSphere(sphereBox1) && event.target === controller1) {
      grabbed = true;
      if (grabbed) {
    // Only start music if it's not already playing this level's music
    const levelMusicTrack = levelMusic[currentLevel - 1];
    if (!currentMusic || currentMusic !== levelMusicTrack) {
      // Stop any previous music
      if (currentMusic) currentMusic.pause();
      // Set and play the current level's music
      currentMusic = levelMusicTrack;
  currentMusic.currentTime = 0; // Start from beginning
  currentMusic.play().catch(error => console.log('Music play error:', error));
}
}
      grabbingController = controller1;
      grabOffset.copy(ring.position).sub(controller1.position);
      grabRotationOffset.copy(controller1.quaternion).invert().multiply(ring.quaternion);
      if (startTime === null) {
        startTime = Date.now() - elapsedTime;
      }
    } else if (ringBox.intersectsSphere(sphereBox2) && event.target === controller2) {
      grabbed = true;
      if (grabbed) {
    // Only start music if it's not already playing this level's music
    const levelMusicTrack = levelMusic[currentLevel - 1];
    if (!currentMusic || currentMusic !== levelMusicTrack) {
      // Stop any previous music
      if (currentMusic) currentMusic.pause();
      // Set and play the current level's music
      currentMusic = levelMusicTrack;
  currentMusic.currentTime = 0; // Start from beginning
  currentMusic.play().catch(error => console.log('Music play error:', error));
}
}
      grabbingController = controller2;
      grabOffset.copy(ring.position).sub(controller2.position);
      grabRotationOffset.copy(controller2.quaternion).invert().multiply(ring.quaternion);
      if (startTime === null) {
        startTime = Date.now() - elapsedTime;
      }
    }
  }
}

function onSelectEnd(event) {
if (event.target === grabbingController) {
grabbed = false;
grabbingController = null;
}
}

// restart Game 
function restartGame() {
  levelCompleted = false;
  // Clean up game completion meshes
  gameCompletionMeshes.forEach(mesh => {
    scene.remove(mesh);
    if (mesh.geometry) mesh.geometry.dispose();
    if (mesh.material) mesh.material.dispose();
  });
  gameCompletionMeshes = [];

  // Remove controller rays 
  hideControllerRays();

  // Reset game state
  currentLevel = 1;
  levelTimes = [];
  startTime = null;
  elapsedTime = 0;
  
  // Show ring and reset position
  gameCompleted = false;
  ring.position.copy(ringStartPosition);
  ring.rotation.set(0, Math.PI / 2, 0);
  ring.visible = true;
  
  // Create new wire for level 1
  wire = createWire(currentLevel);
  wire.visible = true;
  
   // Update level text and timer
   updateLevelText();
   resetTimerDisplay();
  
  // Play chime sound to indicate restart
  chimeSound.play().catch(error => console.log('Sound play error:', error));
}

function animate() {
renderer.setAnimationLoop(render);
}
 
  function handleKeyPress(button) {
  // Visual feedback
  if (button.material && button.userData.pressColor) {
    const originalColor = button.material.color.getHex();
    button.material.color.setHex(button.userData.pressColor);
    
    // Reset color after short delay
    setTimeout(() => {
      if (button.material) {
        button.material.color.setHex(button.userData.hoverColor || button.userData.defaultColor);
      }
    }, 150);
  }
  
  // Process button action
  if (button.userData.buttonType === 'letter' && !nameEntered) {
    // Add letter if under max length
    if (playerName.length < maxNameLength) {
      playerName += button.userData.letter;
      updateNameDisplay(button.parent);
     // Also update record holder meshes if they exist
     if (window.recordHolderMeshes) {
        updateRecordHolderDisplays();
      }    
      triggerHapticFeedbackByHandedness('left', 0.3, 50);
      triggerHapticFeedbackByHandedness('right', 0.3, 50);
    } else {
      // Character limit reached - provide feedback
      contactSound.play().catch(error => console.log('Error sound play error:', error));
      triggerHapticFeedbackByHandedness('left', 0.8, 80);
      triggerHapticFeedbackByHandedness('right', 0.8, 80);
    }
  }
 
  else if (button.userData.buttonType === 'space' && !nameEntered) {
  // Add space if under max length
  if (playerName.length < maxNameLength) {
    playerName += ' ';
    updateNameDisplay(button.parent);
    // Also update record holder meshes if they exist
    if (window.recordHolderMeshes) {
      updateRecordHolderDisplays();
    }
    triggerHapticFeedbackByHandedness('left', 0.3, 50);
    triggerHapticFeedbackByHandedness('right', 0.3, 50);
  } else {
    // Character limit reached - provide feedback
    contactSound.play().catch(error => console.log('Error sound play error:', error));
    triggerHapticFeedbackByHandedness('left', 0.8, 80);
    triggerHapticFeedbackByHandedness('right', 0.8, 80);
  }
}

  else if (button.userData.buttonType === 'backspace' && !nameEntered) {
    // Remove the last letter
    if (playerName.length > 0) {
      playerName = playerName.slice(0, -1);
      updateNameDisplay(button.parent);
         // Also update record holder meshes if they exist
         if (window.recordHolderMeshes) {
        updateRecordHolderDisplays();
      }
      triggerHapticFeedbackByHandedness('left', 0.2, 40);
      triggerHapticFeedbackByHandedness('right', 0.2, 40);
    }
  }

  else if (button.userData.buttonType === 'submit' && !nameEntered && playerName.length > 0) {
    // Submit score to leaderboard
    nameEntered = true;
    
    if (gameCompleted) {
      // If game is complete, submit full game score
      submitScore(playerName, levelTimes);
      // Check and save records for all levels
  for (let i = 0; i < 5; i++) {
    // Check if this level was a new record
    if (window.recordHolderMeshes && window.recordHolderMeshes[i]) {
      saveLevelRecord(i+1, levelTimes[i], playerName);
    }
  }

      // Remove the "New Record" prompt meshes
      gameCompletionMeshes.forEach(mesh => {
      if (mesh.userData && mesh.userData.isNotification) {
        scene.remove(mesh);
      }
    });
    
    // Now fetch best times and show the full score summary
     fetchBestTimes(bestTimes => {
      showGameCompletionScores(bestTimes);
      addGameControlButtons();
    });

          } else {
      // If individual level, save just that level record
      saveLevelRecord(currentLevel, levelTimes[currentLevel-1], playerName);
    }
        
    // Clear any cursor blink interval
    if (initialsDisplayMesh && initialsDisplayMesh.userData.blinkInterval) {
      clearInterval(initialsDisplayMesh.userData.blinkInterval);
      initialsDisplayMesh.userData.blinkInterval = null;
    }
    window.pendingRecords = null; // Clear pending records
    
    triggerHapticFeedbackByHandedness('left', 0.5, 100);
    triggerHapticFeedbackByHandedness('right', 0.5, 100);
    
    // Hide keyboard after submission
    button.parent.visible = false;
    hideControllerRays();
    keyboardActive = false;
    
    // If mid-game, continue to next level
    if (!gameCompleted) {
      proceedToNextLevel();
    } else {
      // If game is completed, now show the control buttons
      addGameControlButtons();
    }
  }
}

// Function to check if a level time is a record
function checkIfNewRecord(levelIndex, levelTime, callback) {
  try {
    // Get current best time from database
    const levelRef = firebase.database().ref(`records/level${levelIndex + 1}`);
    levelRef.once('value', 
      // Success handler
      snapshot => {
        const record = snapshot.val();
        // If no record exists or new time is better, it's a record
        const isRecord = !record || levelTime < record.time;
        console.log(`Level ${levelIndex + 1} time: ${levelTime}ms, Record: ${record ? record.time : 'none'}, Is new record: ${isRecord}`);
        callback(isRecord);
      }, 
      // Error handler
      error => {
        console.error('Error checking for record:', error);
        // If there's an error, we'll assume it's not a record and proceed normally
        callback(false);
      }
    );
  } catch (error) {
    console.error('Exception in checkIfNewRecord:', error);
    // If there's an exception, assume it's not a record and proceed
    callback(false);
  }
}

// Function to proceed to next level 
function proceedToNextLevel() {
  // Clean up any notification meshes
  gameCompletionMeshes.forEach(mesh => {
    if (mesh.userData && mesh.userData.isNotification) {
      scene.remove(mesh);
    }
  });
  
  ring.visible = false;
  transitionImmunity = true;
  setTimeout(() => {
    currentLevel++;
    levelCompleted = false;
    // Update the level text
    if (textMesh && font) {
      textMesh.geometry.dispose();
      textMesh.geometry = new THREE.TextGeometry(`LEVEL ${currentLevel}/5`, 
        { font: font, size: 0.02, height: 0.005 });
      textMesh.geometry.computeBoundingBox();
      const centerOffset = -0.5 * (textMesh.geometry.boundingBox.max.x - textMesh.geometry.boundingBox.min.x);
        // center the geometry itself
  textMesh.geometry.translate(
    -(textMesh.geometry.boundingBox.max.x - textMesh.geometry.boundingBox.min.x) / 2,
    -(textMesh.geometry.boundingBox.max.y - textMesh.geometry.boundingBox.min.y) / 2,
    0
  );
      
      textMesh.position.set(centerOffset, 2.0, -0.75);
      textMesh.visible = true;
    }

    // Create the new wire
    wire = createWire(currentLevel);

    // Reset the ring position
    ring.position.copy(ringStartPosition);
    ring.rotation.set(0, Math.PI / 2, 0);

    // Keep ring invisible until we're sure it's safe
    setTimeout(() => {
      ring.visible = true;
      transitionImmunity = false;
    }, 100);

    // Reset timer for next level
    elapsedTime = 0;
    startTime = null;
    grabbed = false;
    grabbingController = null;

    // Reset timer display
    if (timerMesh && timerFont) {
    timerMesh.geometry.dispose();
    timerMesh.geometry = new THREE.TextGeometry('0:00:000', {
      font: timerFont, size: 0.02, height: 0.005,
    });
    timerMesh.geometry.computeBoundingBox();
    timerCenterOffset = -0.5 * (timerMesh.geometry.boundingBox.max.x - timerMesh.geometry.boundingBox.min.x);
    // center the geometry 
    timerMesh.geometry.translate(
      -(timerMesh.geometry.boundingBox.max.x - timerMesh.geometry.boundingBox.min.x) / 2,
      -(timerMesh.geometry.boundingBox.max.y - timerMesh.geometry.boundingBox.min.y) / 2,
      0
    );
    timerMesh.position.set(ring.position.x + timerCenterOffset, ring.position.y + 0.1, ring.position.z);
    timerMesh.visible = true; 
  }
  }, 500);
}


// implement keyboard hover effects
function updateKeyboardHoverState() {
  // Only check if keyboard is active
  if (!keyboardActive && !gameCompleted) return;
  
  // Reset previously hovered button
  if (hoveredButton) {
    if (hoveredButton.material && hoveredButton.userData.defaultColor) {
      hoveredButton.material.color.setHex(hoveredButton.userData.defaultColor);
    }
    hoveredButton = null;
  }

  // Check both controllers
  [controller1, controller2].forEach(controller => {
    if (!controller) return;
    
    const raycaster = new THREE.Raycaster();
    const direction = new THREE.Vector3(0, 0, -1);
    direction.applyQuaternion(controller.quaternion);
    raycaster.set(controller.position, direction);
    
    let allInteractableObjects = [...gameCompletionMeshes];
    if (keyboardActive) {
      allInteractableObjects = [...allInteractableObjects, ...keyboardMeshes];
    }
    
    // Use recursive intersection to check all child objects too
    const intersects = raycaster.intersectObjects(allInteractableObjects, true);
    
    if (intersects.length > 0) {
      // Get the actual button (might be a child of a group)
      let intersectedObj = intersects[0].object;
      let button = null;
         // Check if it's a non-interactive element (like text on a button)
      if (intersectedObj.userData && intersectedObj.userData.isNonInteractive) {
        // If it's text, check its parent for a button
        let parent = intersectedObj.parent;
        if (parent && parent.userData && parent.userData.isButton) {
          button = parent;
        }
      } else if (intersectedObj.userData && intersectedObj.userData.isButton) {
        // It's directly a button
        button = intersectedObj;
      } else {
        // Check parent hierarchy for a button
        button = findButtonParent(intersectedObj);
      }
      
      if (button && button.material) {
        // Apply hover color based on userData
        if (button.userData.hoverColor) {
          button.material.color.setHex(button.userData.hoverColor);
        } else {
          // Default hover color
          button.material.color.set(0x4477ff);
        }
        hoveredButton = button;
      }
    }
  });
}

// Helper function to find button parent
function findButtonParent(obj) {
  let current = obj;
  while (current && !current.userData.isButton) {
    current = current.parent;
  }
  return current;
}

function render() {
// Update sphere positions to match controller positions
if (controller1 && controller2) {
sphere1.position.copy(controller1.position);
sphere2.position.copy(controller2.position);
}

// Check for collisions
if (!isExploding && !transitionImmunity && !gameCompleted && checkCollision()) {
    handleCollision();
  }

// Move ring with the grabbing controller while maintaining the offset
if (grabbed && grabbingController) {
ring.position.copy(grabbingController.position).add(grabOffset);
ring.quaternion.copy(grabbingController.quaternion).multiply(grabRotationOffset); // Update ring rotation to match controller rotation

// Hide the spheres when the ring is grabbed
sphere1.visible = false;
sphere2.visible = false;
} else {
// Show the spheres when the ring is not grabbed
sphere1.visible = true;
sphere2.visible = true;
}

if (!gameCompleted) {
// Keep the text and timer above the ring and billboarded to face the player
if (textMesh) {
textMesh.position.set(ring.position.x, ring.position.y + 0.2, ring.position.z);
textMesh.lookAt(camera.position);
}

// Update timer with seconds:milliseconds format and check time limit
if (startTime !== null && timerFont) {
elapsedTime = Date.now() - startTime;

const minutes = Math.floor(elapsedTime / 60000);
const seconds = Math.floor((elapsedTime % 60000) / 1000);
const milliseconds = Math.floor(elapsedTime % 1000);
const timerText = `${minutes}:${seconds.toString().padStart(2, '0')}:${milliseconds.toString().padStart(3, '0')}`;

// Update timer text
if (timerMesh && timerMesh.geometry) {
timerMesh.geometry.dispose();
timerMesh.geometry = new THREE.TextGeometry(timerText, {
font: timerFont,
size: 0.02,
height: 0.005,
});
timerMesh.geometry.computeBoundingBox();
timerMesh.geometry.translate(
    -(timerMesh.geometry.boundingBox.max.x - timerMesh.geometry.boundingBox.min.x) / 2,
    -(timerMesh.geometry.boundingBox.max.y - timerMesh.geometry.boundingBox.min.y) / 2,
    0
  );
}
}

// Ensure timer text stays attached to the ring and faces the player
if (timerMesh) {
timerMesh.position.set(ring.position.x, ring.position.y + 0.15, ring.position.z);
timerMesh.lookAt(camera.position);
}
}
// Check for wire collision and update wire color
updateWireColor();

if (confettiStartTime !== null) {
  const elapsed = Date.now() - confettiStartTime;
  
  if (elapsed < 10000) { // 10 seconds of confetti
    for (let i = 0; i < confettiParticles.length; i++) {
      const confetti = confettiParticles[i];
      
      // Add gravity and update position
      confetti.userData.velocity.y -= 0.0003;
      confetti.position.add(confetti.userData.velocity);
      
      // Update rotation
      confetti.rotation.x += confetti.userData.rotationSpeed.x;
      confetti.rotation.y += confetti.userData.rotationSpeed.y;
      confetti.rotation.z += confetti.userData.rotationSpeed.z;
      
      // Add fluttering effect
      confetti.userData.velocity.x += Math.sin(elapsed * 0.01 + confetti.userData.flutter) * 0.0001;
      confetti.userData.velocity.z += Math.cos(elapsed * 0.01 + confetti.userData.flutter) * 0.0001;
    }
  } else {
    // Clean up confetti
    for (let i = 0; i < confettiParticles.length; i++) {
      scene.remove(confettiParticles[i]);
      confettiParticles[i].material.dispose();
    }
    confettiParticles = [];
    confettiStartTime = null;
  }
}

if (isExploding) {
    const explosionElapsed = Date.now() - explosionStartTime;
    const explosionDuration = 2000; // 2 seconds
    
    if (explosionElapsed < explosionDuration) {
      // Update fragment positions and rotations
      for (let i = 0; i < explosionFragments.length; i++) {
        const fragment = explosionFragments[i];
        fragment.position.add(fragment.userData.velocity);
        fragment.rotation.x += fragment.userData.rotationSpeed.x;
        fragment.rotation.y += fragment.userData.rotationSpeed.y;
        fragment.rotation.z += fragment.userData.rotationSpeed.z;
        
        // Add gravity effect
        fragment.userData.velocity.y -= 0.0005;
      }
    } else {
      // Clean up explosion
      for (let i = 0; i < explosionFragments.length; i++) {
        const fragment = explosionFragments[i];
        scene.remove(fragment);
        if (fragment.geometry) fragment.geometry.dispose();
        if (fragment.material) fragment.material.dispose();
      }
      
      // Reset
      explosionFragments = [];
      isExploding = false;
      
      // Show and reset ring
      if (!gameCompleted) {
      ring.visible = true;
      ring.position.copy(ringStartPosition);
      ring.rotation.set(0, Math.PI / 2, 0);
      
        // Reset timer display to 0:00:000
    if (timerMesh && timerFont) {
      timerMesh.geometry.dispose();
      timerMesh.geometry = new THREE.TextGeometry('0:00:000', {
        font: timerFont,
        size: 0.02,
        height: 0.005,
      });
      timerMesh.geometry.computeBoundingBox();
      // Center the geometry itself
      timerMesh.geometry.translate(
    -(timerMesh.geometry.boundingBox.max.x - timerMesh.geometry.boundingBox.min.x) / 2,
    -(timerMesh.geometry.boundingBox.max.y - timerMesh.geometry.boundingBox.min.y) / 2,
    0
  );
      timerMesh.position.set(ring.position.x + timerCenterOffset, ring.position.y + 0.1, ring.position.z);
      timerMesh.lookAt(camera.position);
    }
    }
  }
  }
  // Check for keyboard button hover states
if (gameCompleted) {
  updateKeyboardHoverState();
}

if (keyboardActive) {
  updateKeyboardHoverState();
}

renderer.render(scene, camera);
}

function updateWireColor() {
if (levelCompleted) return;
const ringBox = new THREE.Box3().setFromObject(ring);
const colors = wire.geometry.attributes.color.array;

// Calculate a dynamic pointBox size based on the ring's scale
const ringScale = ring.scale.x; // Assuming uniform scale
const pointBoxSize = 0.01 * ringScale; // Adjust the multiplier as needed

for (let i = 0; i < wirePoints.length; i++) {
const point = wirePoints[i];
const pointBox = new THREE.Box3().setFromCenterAndSize(point, new THREE.Vector3(pointBoxSize, pointBoxSize, pointBoxSize));

if (ringBox.intersectsBox(pointBox)) {
// Color this segment blue
colors[i * 3] = 0;     // R
colors[i * 3 + 1] = 0; // G
colors[i * 3 + 2] = 1; // B
}
//No ELSE, so color will remain unless reset
}

wire.geometry.attributes.color.needsUpdate = true;

// Check if the entire wire is blue (victory condition)
let allBlue = true;
for (let i = 0; i < wirePoints.length; i++) {
if (colors[i * 3] !== 0 || colors[i * 3 + 1] !== 0 || colors[i * 3 + 2] !== 1) {
allBlue = false;
break;
}
}
if (allBlue && !gameCompleted) {
victory();
}
}

function handleCollision() {
  // Stop any playing music
  if (currentMusic) {
    currentMusic.pause();
    currentMusic = null;
  }
explodeRing(); // Add explosion effect
contactSound.play().catch(error => console.log('Sound play error:', error)); // Play contact sound
resetWireColor(); // Reset wire color to pink
triggerHapticFeedbackByHandedness('left', 1.0, 80); // haptic feedback
triggerHapticFeedbackByHandedness('right', 1.0, 80);  // haptic feedback
grabbed = false; // Override the grab
grabbingController = null; // Clear the grabbing controller

// Reset timer but don't change level
elapsedTime = 0;
startTime = null;
}

function resetWireColor() {
const colors = wire.geometry.attributes.color.array;
for (let i = 0; i < colors.length; i += 3) {
colors[i] = 1; // R
colors[i + 1] = 0; // G
colors[i + 2] = 1; // B
}
wire.geometry.attributes.color.needsUpdate = true;
}

// Helper function to format time as SS:MMM
function formatTime(ms) {
const minutes = Math.floor(ms / 60000);  
const seconds = Math.floor((ms % 60000) / 1000);
const milliseconds = Math.floor(ms % 1000);
return `${minutes}:${seconds.toString().padStart(2, '0')}:${milliseconds.toString().padStart(3, '0')}`;
}

function createConfetti() {
  confettiStartTime = Date.now();
  const confettiGeometry = new THREE.PlaneGeometry(0.015, 0.015);
  const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
  
  // Create 3000 confetti particles
  for (let i = 0; i < 1000; i++) {
    const material = new THREE.MeshBasicMaterial({ 
      color: colors[Math.floor(Math.random() * colors.length)], 
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.9
    });
    
    const confetti = new THREE.Mesh(confettiGeometry, material);
    // Position around center with slight spread
    confetti.position.set(
      ring.position.x + (Math.random() - 0.5) * 2,
      ring.position.y + Math.random() * 1.5,
      ring.position.z + (Math.random() - 0.5) * 2
    );
    
    confetti.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
    
    // Physics properties
    confetti.userData.velocity = new THREE.Vector3(
      (Math.random() - 0.5) * 0.03,
      Math.random() * 0.03,
      (Math.random() - 0.5) * 0.03
    );
    confetti.userData.rotationSpeed = new THREE.Vector3(
      (Math.random() - 0.5) * 0.15,
      (Math.random() - 0.5) * 0.15,
      (Math.random() - 0.5) * 0.15
    );
    confetti.userData.flutter = Math.random() * 10;
    
    scene.add(confetti);
    confettiParticles.push(confetti);
  }
}

function showNewRecordNotification(recordTime) {
  // Create record notification text
  const recordGeometry = new THREE.TextGeometry('NEW RECORD!', { 
    font: font, 
    size: 0.05, // Slightly larger
    height: 0.008 
  });
  const recordMaterial = new THREE.MeshStandardMaterial({ 
    color: 0xffff00,
    emissive: 0xffff00,
    emissiveIntensity: 0.7 // Brighter
  });
  const recordMesh = new THREE.Mesh(recordGeometry, recordMaterial);
  recordGeometry.computeBoundingBox();
  const recordOffset = -0.5 * (recordGeometry.boundingBox.max.x - recordGeometry.boundingBox.min.x);
  recordMesh.position.set(recordOffset, 1.5, -0.75);
  scene.add(recordMesh);
  
  // Show the time
  const timeGeometry = new THREE.TextGeometry(`Time: ${formatTime(recordTime)}`, { 
    font: font, 
    size: 0.035, 
    height: 0.005 
  });
  const timeMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x00ffff,
    emissive: 0x00ffff, 
    emissiveIntensity: 0.3 
  });
  const timeMesh = new THREE.Mesh(timeGeometry, timeMaterial);
  timeGeometry.computeBoundingBox();
  const timeOffset = -0.5 * (timeGeometry.boundingBox.max.x - timeGeometry.boundingBox.min.x);
  timeMesh.position.set(timeOffset, 1.4, -0.75);
  scene.add(timeMesh);
  
  // Add "Enter your name:" text
  const promptGeometry = new THREE.TextGeometry('Enter your name:', { 
    font: font, 
    size: 0.03, 
    height: 0.005 
  });
  const promptMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
  const promptMesh = new THREE.Mesh(promptGeometry, promptMaterial);
  promptGeometry.computeBoundingBox();
  const promptOffset = -0.5 * (promptGeometry.boundingBox.max.x - promptGeometry.boundingBox.min.x);
  promptMesh.position.set(promptOffset, 1.3, -0.75);
  scene.add(promptMesh);
  
  // Store these for later cleanup and mark them as notifications
  recordMesh.userData.isNotification = true;
  timeMesh.userData.isNotification = true;
  promptMesh.userData.isNotification = true;
  gameCompletionMeshes.push(recordMesh, timeMesh, promptMesh);
  
  // Make the record text blink
  let blinkCount = 0;
  const blinkInterval = setInterval(() => {
    recordMesh.visible = !recordMesh.visible;
    blinkCount++;
    if (blinkCount >= 10) {
      clearInterval(blinkInterval);
      recordMesh.visible = true;
    }
  }, 250);
}

// Submit score to Leaderboard 
function submitScore(playerName, levelTimes) {
  const totalTime = levelTimes.reduce((total, time) => total + time, 0);

  // Reference to the monthly leaderboard
  const monthLeaderboardRef = selectedMonth ? 
    firebase.database().ref(`leaderboard/${selectedMonth}`) : 
    leaderboardRef;
  
  // Add to leaderboard
  monthLeaderboardRef.push({
    playerName: playerName || 'Anonymous Player',
    totalTime: totalTime,
    levelTimes: levelTimes,
    date: Date.now()
  });
}

// fetch best times for each level
function fetchBestTimes(callback) {
  // Structure to store best times
  const bestTimes = {
    level1: { time: Number.MAX_VALUE, name: "" },
    level2: { time: Number.MAX_VALUE, name: "" },
    level3: { time: Number.MAX_VALUE, name: "" },
    level4: { time: Number.MAX_VALUE, name: "" },
    level5: { time: Number.MAX_VALUE, name: "" },
    total: { time: Number.MAX_VALUE, name: "" }
  };
  
  // Use the monthly leaderboard if available
  const monthLeaderboardRef = selectedMonth ? 
    firebase.database().ref(`leaderboard/${selectedMonth}`) : 
    leaderboardRef;

  try {
    // Get all leaderboard entries with timeout protection
    const timeoutId = setTimeout(() => {
      console.warn("Firebase query timed out, using default values");
      // Make sure we call the callback even if Firebase times out
      if (callback) callback(bestTimes);
      // Set callback to null to prevent multiple calls
      callback = null;
    }, 5000);
    
    monthleaderboardRef.once('value', 
      // Success handler
      snapshot => {
        clearTimeout(timeoutId); // Clear the timeout
        
        // Process the data...
        snapshot.forEach(child => {
          const entry = child.val();
          
          // Check for total time record
          if (entry.totalTime && entry.totalTime < bestTimes.total.time) {
            bestTimes.total.time = entry.totalTime;
            bestTimes.total.name = entry.playerName || "Anonymous";
          }
          
          // Check each level time
          if (entry.levelTimes) {
            for (let i = 0; i < 5; i++) {
              if (entry.levelTimes[i] && entry.levelTimes[i] < bestTimes[`level${i+1}`].time) {
                bestTimes[`level${i+1}`].time = entry.levelTimes[i];
                bestTimes[`level${i+1}`].name = entry.playerName || "Anonymous";
              }
            }
          }
        });
        
        // Replace MAX_VALUE with null for any levels without records
        for (const key in bestTimes) {
          if (bestTimes[key].time === Number.MAX_VALUE) {
            bestTimes[key].time = null;
            bestTimes[key].name = "N/A";
          }
        }
        
        if (callback) callback(bestTimes);
      },
      // Error handler
      error => {
        clearTimeout(timeoutId); // Clear the timeout
        console.error("Error fetching best times:", error);
        // Still call the callback with default values
        if (callback) callback(bestTimes);
      }
    );
  } catch (e) {
    console.error("Exception in fetchBestTimes:", e);
    // Call callback even if there's an exception
    if (callback) callback(bestTimes);
  }
}

function saveLevelRecord(levelNumber, levelTime, playerName) {
  // Reference to the specific level record
  const levelRef = firebase.database().ref(`records/level${levelNumber}`);
  
  // First check if this is a record
  levelRef.once('value', snapshot => {
    const currentRecord = snapshot.val();
    
    // If no record exists or the new time is better
    if (!currentRecord || levelTime < currentRecord.time) {
      // Save the new record
      levelRef.set({
        time: levelTime,
        name: playerName || 'Anonymous Player',
        date: Date.now()
      });
      console.log(`New record for level ${levelNumber} saved!`);
    } else {
      console.log(`Not a new record for level ${levelNumber}`);
    }
  });
}

// create restart and quit buttons
function addGameControlButtons() {
  // Create button container to help with positioning
  const buttonContainer = new THREE.Group();
  buttonContainer.position.set(0, 1.2, -0.75);
  scene.add(buttonContainer);
  gameCompletionMeshes.push(buttonContainer);
  
  // Add Restart button with background
  const restartBgGeometry = new THREE.BoxGeometry(0.2, 0.07, 0.01);
  const restartBgMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x00aa00,
    emissive: 0x005500,
    emissiveIntensity: 0.3
  });
  const restartBg = new THREE.Mesh(restartBgGeometry, restartBgMaterial);
  restartBg.position.set(-0.15, 0, 0);
  buttonContainer.add(restartBg);
  gameCompletionMeshes.push(restartBg);

  const restartGeometry = new THREE.TextGeometry('RESTART', { 
    font: font, 
    size: 0.025, 
    height: 0.005 
  });
  const restartMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
  const restartMesh = new THREE.Mesh(restartGeometry, restartMaterial);
  restartGeometry.computeBoundingBox();
  const restartWidth = restartGeometry.boundingBox.max.x - restartGeometry.boundingBox.min.x;
  const restartOffset = -0.5 * restartWidth;
  restartMesh.userData.isNonInteractive = true;
  restartMesh.raycast = function() {};
  restartMesh.position.set(restartOffset - 0.15, -0.01, 0.005);
  buttonContainer.add(restartMesh);
  
  // Make the background button interactive
  restartBg.userData.isButton = true;
  restartBg.userData.buttonType = 'restart';
  restartBg.userData.defaultColor = 0x00aa00;
  restartBg.userData.hoverColor = 0x00cc00;
  restartBg.userData.pressColor = 0x00ff00;
  
  // Add Quit button with background
  const quitBgGeometry = new THREE.BoxGeometry(0.2, 0.07, 0.01);
  const quitBgMaterial = new THREE.MeshStandardMaterial({ 
    color: 0xaa0000,
    emissive: 0x550000,
    emissiveIntensity: 0.3
  });
  const quitBg = new THREE.Mesh(quitBgGeometry, quitBgMaterial);
  quitBg.position.set(0.15, 0, 0);
  buttonContainer.add(quitBg);
  gameCompletionMeshes.push(quitBg);
  
  const quitGeometry = new THREE.TextGeometry('QUIT', { 
    font: font, 
    size: 0.025, 
    height: 0.005 
  });
  const quitMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
  const quitMesh = new THREE.Mesh(quitGeometry, quitMaterial);
  quitGeometry.computeBoundingBox();
  const quitWidth = quitGeometry.boundingBox.max.x - quitGeometry.boundingBox.min.x;
  const quitOffset = -0.5 * quitWidth;
  quitMesh.userData.isNonInteractive = true; 
  quitMesh.raycast = function() {};
  quitMesh.position.set(quitOffset + 0.15, -0.01, 0.005);
  buttonContainer.add(quitMesh);
  
  // Make the background button interactive
  quitBg.userData.isButton = true;
  quitBg.userData.buttonType = 'quit';
  quitBg.userData.defaultColor = 0xaa0000;
  quitBg.userData.hoverColor = 0xcc0000;
  quitBg.userData.pressColor = 0xff0000;
  
  // Ensure controller rays are visible
  if (controllerRays.length === 0) {
    createControllerRays();
  }
  
  return buttonContainer;
}

function victory() {
  if (levelCompleted) return;
  levelCompleted = true;

   // Stop the music
   if (currentMusic) {
    currentMusic.pause();
    currentMusic = null;
  }

  // First, always record the completion time for the current level
  if (startTime !== null) {
    const levelTime = Date.now() - startTime;
    levelTimes[currentLevel - 1] = levelTime;
    startTime = null;
    console.log(`Level ${currentLevel} completed in ${levelTime}ms`);
  // Check if this is a new record
checkIfNewRecord(currentLevel - 1, levelTime, (isRecord) => {
  if (isRecord) {
    // Show notification that user beat the record for this level
    showNewRecordNotification(levelTime);
    // Wait for name entry and save later when submitted
  }
});
  }

  if (currentLevel < 5) {
    // Handle regular level completion
    if (textMesh) textMesh.visible = false; 
    if (timerMesh) timerMesh.visible = false;

    // Play victory sounds
    victorySound.play().catch(error => console.log('Sound play error:', error));
    applauseSound.play().catch(error => console.log('Sound play error:', error));
    triggerHapticFeedbackByHandedness('left', 0.5, 500); 
    triggerHapticFeedbackByHandedness('right', 0.5, 500);

    // Flash the wire white and blue
    flashWire(3, false);

    // Add confetti 
    createConfetti();

    setTimeout(() => {
      proceedToNextLevel();
    }, 3000);
  } 
  else {
    // Game complete! But don't show scores yet
    gameCompleted = true;
    const totalTime = levelTimes.reduce((total, time) => total + time, 0);
    console.log("Game completed! Total time:", totalTime);

    // Hide the ring and wire
    ring.visible = false;
    wire.visible = false;
    if (textMesh) textMesh.visible = false;
    if (timerMesh) timerMesh.visible = false;

    // Play grand finale sounds
    longHornsSound.play().catch(error => console.log('Sound play error:', error));
    longApplauseSound.play().catch(error => console.log('Sound play error:', error));

    // Create haptic feedback pattern
    const celebratePulses = () => {
      let count = 0;
      const interval = setInterval(() => {
        triggerHapticFeedbackByHandedness('left', 0.7, 100);
        triggerHapticFeedbackByHandedness('right', 0.7, 100);
        count++;
        if (count >= 5) clearInterval(interval);
      }, 300);
    };
    celebratePulses();

    createConfetti(); // Add confetti effect
    flashWire(6, true);  // Flash the wire more dramatically

    // First check if there's a new record before proceeding
    fetchBestTimes(bestTimes => {
      const totalRecordTime = bestTimes.total;
      const isNewTotalRecord = totalTime > 0 && (!totalRecordTime || !totalRecordTime.time || totalTime <= totalRecordTime.time);
      
      // Also check if level 5 specifically was a record
      const level5Time = levelTimes[4];
      const level5Record = bestTimes.level5;
      const isLevel5Record = level5Time > 0 && (!level5Record || !level5Record.time || level5Time <= level5Record.time);
      
      // If either is a new record, show keyboard first
      if (isNewTotalRecord || isLevel5Record) {
        // Store record info for later use
        window.pendingRecords = {
          totalGame: isNewTotalRecord,
          level5: isLevel5Record
        };
        
        // Show "New Record" prompt with keyboard
        showNewRecordPrompt(isNewTotalRecord);
      } else {
        // No new records, show scores immediately
        showGameCompletionScores(bestTimes);
        addGameControlButtons();
      }
    });
  }
}

function showNewRecordPrompt(isNewTotalRecord) {
  // Create "New Record!" header text
  const recordGeometry = new THREE.TextGeometry('NEW RECORD SET!', { 
    font: font, 
    size: 0.03,
    height: 0.008 
  });
  const recordMaterial = new THREE.MeshStandardMaterial({ 
    color: 0xffff00,
    emissive: 0xffff00,
    emissiveIntensity: 0.7
  });
  const recordMesh = new THREE.Mesh(recordGeometry, recordMaterial);
  recordGeometry.computeBoundingBox();
  const recordOffset = -0.5 * (recordGeometry.boundingBox.max.x - recordGeometry.boundingBox.min.x);
  recordMesh.position.set(recordOffset, 1.5, -0.75);
  scene.add(recordMesh);
  
  // Add "Enter your name:" text
  const promptGeometry = new THREE.TextGeometry('Enter your name:', { 
    font: font, 
    size: 0.02, 
    height: 0.005 
  });
  const promptMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
  const promptMesh = new THREE.Mesh(promptGeometry, promptMaterial);
  promptGeometry.computeBoundingBox();
  const promptOffset = -0.5 * (promptGeometry.boundingBox.max.x - promptGeometry.boundingBox.min.x);
  promptMesh.position.set(promptOffset, 1.45, -0.75);
  scene.add(promptMesh);
  
  // Store these for later cleanup
  recordMesh.userData.isNotification = true;
  promptMesh.userData.isNotification = true;
  gameCompletionMeshes.push(recordMesh, promptMesh);
  
  // Make the record text blink
  let blinkCount = 0;
  const blinkInterval = setInterval(() => {
    recordMesh.visible = !recordMesh.visible;
    blinkCount++;
    if (blinkCount >= 10) {
      clearInterval(blinkInterval);
      recordMesh.visible = true;
    }
  }, 250);
  
  // Show keyboard with short delay
  setTimeout(() => {
    keyboardActive = true;
    playerName = ""; 
    nameEntered = false;
    createImprovedVirtualKeyboard();
  }, 1000);
}

// Extract the score display code into its own function
function showGameCompletionScores(bestTimes) {
 // Play end game music
 if (endGameMusic) {
    endGameMusic.currentTime = 0; // Start from beginning
    endGameMusic.play().catch(error => console.log('End game music play error:', error));
  }

  // Create "GAME COMPLETE!" header at the top
  const gameCompleteGeometry = new THREE.TextGeometry('GAME COMPLETE!', { 
    font: font, 
    size: 0.03, 
    height: 0.005 
  });
  const gameCompleteMaterial = new THREE.MeshStandardMaterial({ 
    color: 0xffff00, 
    emissive: 0xffff00,
    emissiveIntensity: 0.3
  });
  const gameCompleteMesh = new THREE.Mesh(gameCompleteGeometry, gameCompleteMaterial);
  gameCompleteGeometry.computeBoundingBox();
  const gameCompleteOffset = -0.5 * (gameCompleteGeometry.boundingBox.max.x - gameCompleteGeometry.boundingBox.min.x);
  gameCompleteMesh.position.set(gameCompleteOffset, 1.6, -0.75);
  scene.add(gameCompleteMesh);
  gameCompletionMeshes.push(gameCompleteMesh);
  
  // Create column headers
  const yourTimesGeometry = new THREE.TextGeometry('YOUR TIMES', { 
    font: font, 
    size: 0.02, 
    height: 0.005 
  });
  const yourTimesMesh = new THREE.Mesh(yourTimesGeometry, new THREE.MeshStandardMaterial({ color: 0x00ffff }));
  yourTimesMesh.position.set(-0.07, 1.51, -0.75);
  scene.add(yourTimesMesh);
  gameCompletionMeshes.push(yourTimesMesh);
  
  const recordsGeometry = new THREE.TextGeometry('RECORDS', { 
    font: font, 
    size: 0.02, 
    height: 0.005 
  });
  const recordsMesh = new THREE.Mesh(recordsGeometry, new THREE.MeshStandardMaterial({ color: 0xff8000, emissive: 0xff8000,
    emissiveIntensity: 0.3  }));
  recordsMesh.position.set(0.13, 1.51, -0.75);
  scene.add(recordsMesh);
  gameCompletionMeshes.push(recordsMesh);


// Level rows
for (let i = 0; i < 5; i++) {
  const levelTime = levelTimes[i] || 0;
  const recordTime = bestTimes[`level${i+1}`];
  const recordHolder = bestTimes[`level${i+1}`].name;
  
  // Create level number label
  const levelLabelGeometry = new THREE.TextGeometry(`Level ${i+1}:`, { 
    font: font, 
    size: 0.018, 
    height: 0.005 
  });
  const levelLabelMesh = new THREE.Mesh(
    levelLabelGeometry, 
    new THREE.MeshStandardMaterial({ color: 0xffffff })
  );
  levelLabelMesh.position.set(-0.25, 1.46 - (i * 0.035), -0.75);
  scene.add(levelLabelMesh);
  gameCompletionMeshes.push(levelLabelMesh);


  scoreSummaryMeshes.push(levelLabelMesh);
  
  // Format player's time
  const playerTimeText = formatTime(levelTime);
  
  // Player time - left column
  const isNewLevelRecord = (levelTime > 0 && recordTime && recordTime.time && levelTime <= recordTime.time);
  const playerTextColor = isNewLevelRecord ? 0x00ff00 : 0x00ffff;
  const playerTimeGeometry = new THREE.TextGeometry(playerTimeText, { 
    font: font, 
    size: 0.018, 
    height: 0.005 
  });
  const playerTimeMesh = new THREE.Mesh(
    playerTimeGeometry, 
    new THREE.MeshStandardMaterial({ 
      color: 0x00ffff,
      emissive: 0x00ffff,
      emissiveIntensity: 0.3
    })
  );
  playerTimeMesh.position.set(-0.05, 1.46 - (i * 0.035), -0.75);
  scene.add(playerTimeMesh);
  gameCompletionMeshes.push(playerTimeMesh);
  scoreSummaryMeshes.push(playerTimeMesh);
  
  // Combined record time and holder with hyphenated format
  const recordTimeFormatted = recordTime && recordTime.time ? formatTime(recordTime.time) : "N/A";
  const displayName = recordHolder ? 
    (recordHolder.length > 10 ? recordHolder.substring(0, 10) : recordHolder) : "N/A";
  
  // Format combined record: "1:23:456 - PLAYER" or "N/A" if no record exists
  const combinedRecordText = recordTime && recordTime.time ? 
    `${recordTimeFormatted} - ${displayName}` : "N/A";
  
  // Combined record - right column
  const combinedRecordGeometry = new THREE.TextGeometry(
    isNewLevelRecord ? `${formatTime(levelTime)} - ${playerName || "..."}` : combinedRecordText, {  
    font: font, 
    size: 0.018, 
    height: 0.005 
  });
  const combinedRecordMesh = new THREE.Mesh(
    combinedRecordGeometry, 
    new THREE.MeshStandardMaterial({ 
      color: 0xff8000, 
      emissive: 0xff8000,
      emissiveIntensity: 0.3
    })
  );
  combinedRecordMesh.position.set(0.15, 1.46 - (i * 0.035), -0.75);
  scene.add(combinedRecordMesh);
  gameCompletionMeshes.push(combinedRecordMesh);
  scoreSummaryMeshes.push(combinedRecordMesh);

  if (isNewLevelRecord) {
    // Store in global array for later updates as player types
    if (!window.recordHolderMeshes) window.recordHolderMeshes = [];
    window.recordHolderMeshes[i] = combinedRecordMesh;
  }
}

const totalTime = levelTimes.reduce((total, time) => total + time, 0);
const totalRecordTime = bestTimes.total;
const totalRecordHolder = bestTimes.total.name;
const isNewRecord = totalTime > 0 && (!totalRecordTime || !totalRecordTime.time || totalTime <= totalRecordTime.time);

// Total label
const totalLabelGeometry = new THREE.TextGeometry("Total:", { 
  font: font, 
  size: 0.018, 
  height: 0.005 
});
const totalLabelMesh = new THREE.Mesh(
  totalLabelGeometry, 
  new THREE.MeshStandardMaterial({ color: 0xffffff })
);
totalLabelMesh.position.set(-0.25, 1.46 - (5 * 0.035), -0.75);
scene.add(totalLabelMesh);
gameCompletionMeshes.push(totalLabelMesh);
scoreSummaryMeshes.push(totalLabelMesh);

// Player total time
const playerTotalTimeGeometry = new THREE.TextGeometry(formatTime(totalTime), { 
  font: font, 
  size: 0.018, 
  height: 0.005 
});
const playerTotalMesh = new THREE.Mesh(
  playerTotalTimeGeometry, 
  new THREE.MeshStandardMaterial({ 
    color: 0x00ffff,
    emissive: 0x00ffff,
    emissiveIntensity: 0.3
  })
);
playerTotalMesh.position.set(-0.05, 1.46 - (5 * 0.035), -0.75);
scene.add(playerTotalMesh);
gameCompletionMeshes.push(playerTotalMesh);
scoreSummaryMeshes.push(playerTotalMesh);

// Format combined total record
const totalRecordTimeFormatted = totalRecordTime && totalRecordTime.time ? 
  formatTime(totalRecordTime.time) : "N/A";
const displayTotalHolder = totalRecordHolder ? 
  (totalRecordHolder.length > 10 ? totalRecordHolder.substring(0, 10) : totalRecordHolder) : "N/A";
const combinedTotalRecordText = totalRecordTime && totalRecordTime.time ? 
  `${totalRecordTimeFormatted} - ${displayTotalHolder}` : "N/A";

const combinedTotalRecordGeometry = new THREE.TextGeometry(
  isNewRecord ? `${formatTime(totalTime)} - ${playerName || "..."}` : combinedTotalRecordText, { 
  font: font, 
  size: 0.018, 
  height: 0.005 
});
const combinedTotalRecordMesh = new THREE.Mesh(
  combinedTotalRecordGeometry, 
  new THREE.MeshStandardMaterial({ 
    color: 0xff8000,
    emissive: 0xff8000,
    emissiveIntensity: 0.3
  })
);
combinedTotalRecordMesh.position.set(0.15, 1.46 - (5 * 0.035), -0.75);
scene.add(combinedTotalRecordMesh);
gameCompletionMeshes.push(combinedTotalRecordMesh);
scoreSummaryMeshes.push(combinedTotalRecordMesh);

if (isNewRecord) {
  // Store in global array for later updates as player types
  if (!window.recordHolderMeshes) window.recordHolderMeshes = [];
  window.recordHolderMeshes[5] = combinedTotalRecordMesh; // Use index 5 for total row
}

// Only show keyboard if it's a new record
if (!isNewRecord) {
    // Just show the restart/quit buttons without any additional text
    createControllerRays();
    
    // add restart and quit buttons
    addGameControlButtons();
}
}
 
// Function to make new record meshes blink
function blinkNewRecords(meshes, times = 5) {
  if (!meshes || meshes.length === 0) return;
  
  let count = 0;
  const interval = setInterval(function() {
    // Toggle visibility using traditional for loop instead of forEach
    for (let i = 0; i < meshes.length; i++) {
      if (meshes[i] && meshes[i].material) {
        meshes[i].visible = !meshes[i].visible;
      }
    }
    
    count++;
    if (count >= times * 2) {
      clearInterval(interval);
      // Make sure all are visible at the end
      for (let i = 0; i < meshes.length; i++) {
        if (meshes[i] && meshes[i].material) {
          meshes[i].visible = true;
        }
      }
    }
  }, 250);
}

</script>
</body>
</html>
