<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StarBlast VR</title>
 
    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js",
        "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/"
      }
    }
    </script>

    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        #container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        #vrButton {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 16px 32px;
            background: #0066cc;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 20px;
            cursor: pointer;
            z-index: 100;
            transition: all 0.3s ease;
        }
        #vrButton:hover {
            background: #0055aa;
            transform: translateX(-50%) scale(1.05);
        }
        #loadingScreen {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        #loadingBar {
            width: 300px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            margin-top: 20px;
        }
        #loadingBarFill {
            width: 0%;
            height: 100%;
            background: #0066cc;
            border-radius: 10px;
            transition: width 0.3s ease;
        }
        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="score">SCORE: 0</div>
    <button id="vrButton">ENTER VR</button>
    <div id="loadingScreen">
        <h1>LOADING STARBLAST VR</h1>
        <div id="loadingBar">
            <div id="loadingBarFill"></div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/examples/jsm/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/examples/jsm/webxr/XRControllerModelFactory.js';

        // Game variables
        let scene, camera, renderer, clock;
        let controllers = [];
        let tunnel, player, enemies = [], turrets = [], lasers = [], explosions = [];
        let speedParticles = [];
        let tunnelLength = 2000;
        let tunnelRadius = 20;
        let playerSpeed = 0.8;
        let score = 0;
        let gameOver = false;
        let gameStarted = false;
        let leftReticle, rightReticle;
        let cockpit;
        let targetDestroyed = false;
        let showingVRButton = true;
        let playerHitbox;
        let initialHeadPosition = new THREE.Vector3();
        let headTrackingEnabled = false;

        // Reticle positions (persistent)
        let leftReticlePos = { x: 0, y: 0 };
        let rightReticlePos = { x: 0, y: 0 };

        // Controller state
        const controllerState = {
            left: {
                joystick: { x: 0, y: 0 },
                trigger: false,
                squeeze: false
            },
            right: {
                joystick: { x: 0, y: 0 },
                trigger: false,
                squeeze: false
            }
        };

        // Initialize the game
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000011);
            scene.fog = new THREE.FogExp2(0x000011, 0.003);

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 0;
            camera.rotation.y = Math.PI;

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.xr.enabled = true;
            document.getElementById('container').appendChild(renderer.domElement);

            // VR button
            const vrButton = document.getElementById('vrButton');
            vrButton.addEventListener('click', () => {
                showingVRButton = false;
                vrButton.style.display = 'none';
                document.body.appendChild(VRButton.createButton(renderer));
                renderer.xr.addEventListener('sessionstart', () => {
                    gameStarted = true;
                    headTrackingEnabled = true;
                    // Store initial head position after a short delay
                    setTimeout(() => {
                        initialHeadPosition.copy(camera.position);
                    }, 1000);
                    resetGame();
                });
            });

            // Create clock
            clock = new THREE.Clock();

            // Create lights (increased ambient lighting)
            const ambientLight = new THREE.AmbientLight(0x666666, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0, 10, 10);
            scene.add(directionalLight);

            // Create tunnel
            createTunnel();
            
            // Create the final target
            createFinalTarget();
            
            // Create cockpit
            createCockpit();
            
            // Setup controllers
            setupControllers();
            
            // Create reticles
            createReticles();
            
            // Create speed particles
            createSpeedParticles();
            
            // Create player hitbox
            createPlayerHitbox();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Simulate loading
            simulateLoading();
            
            // Start animation loop
            renderer.setAnimationLoop(animate);
        }

        function simulateLoading() {
            const loadingBarFill = document.getElementById('loadingBarFill');
            let progress = 0;
            const loadingInterval = setInterval(() => {
                progress += 5;
                loadingBarFill.style.width = progress + '%';
                if (progress >= 100) {
                    clearInterval(loadingInterval);
                    document.getElementById('loadingScreen').style.display = 'none';
                }
            }, 100);
        }

        function createPlayerHitbox() {
            // Invisible sphere representing player hitbox
            const hitboxGeometry = new THREE.SphereGeometry(0.8, 8, 8);
            const hitboxMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff0000, 
                transparent: true, 
                opacity: 0.0 // Invisible
            });
            playerHitbox = new THREE.Mesh(hitboxGeometry, hitboxMaterial);
            scene.add(playerHitbox);
        }

        function createSpeedParticles() {
            const particleCount = 500;
            const particleGeometry = new THREE.SphereGeometry(0.02, 4, 4);
            const particleMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.6
            });

            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // Random position in tunnel
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * (tunnelRadius - 1);
                particle.position.x = Math.sin(angle) * radius;
                particle.position.y = Math.cos(angle) * radius;
                particle.position.z = Math.random() * tunnelLength - tunnelLength/2;
                
                particle.userData = {
                    isSpeedParticle: true,
                    speed: 2 + Math.random() * 3
                };
                
                scene.add(particle);
                speedParticles.push(particle);
            }
        }

        function createTunnel() {
            // Create tunnel geometry
            const tunnelGeometry = new THREE.CylinderGeometry(tunnelRadius, tunnelRadius, tunnelLength, 24, 20, true);
            
            // Rotate and position the tunnel
            tunnelGeometry.rotateX(Math.PI / 2);
            
            // Create tunnel material with internal texture
            const tunnelMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444,
                side: THREE.BackSide,
                roughness: 0.8,
                metalness: 0.2,
            });
            
            // Add details to the tunnel
            const tunnelDetailGeometry = new THREE.BoxGeometry(1, 1, 1);
            const tunnelDetailMaterial = new THREE.MeshStandardMaterial({
                color: 0x777777,
                roughness: 0.7,
                metalness: 0.3
            });
            
            // Create tunnel mesh
            tunnel = new THREE.Mesh(tunnelGeometry, tunnelMaterial);
            tunnel.position.z = -tunnelLength / 2;
            scene.add(tunnel);
            
            // Add tunnel details (pipes, panels, etc.)
            for (let i = 0; i < 200; i++) {
                const detail = new THREE.Mesh(tunnelDetailGeometry, tunnelDetailMaterial);
                const angle = Math.random() * Math.PI * 2;
                const z = -Math.random() * (tunnelLength - 50) - 10;
                const size = 0.5 + Math.random() * 1.5;
                
                detail.position.x = Math.sin(angle) * (tunnelRadius - 1);
                detail.position.y = Math.cos(angle) * (tunnelRadius - 1);
                detail.position.z = z;
                detail.scale.set(size, size, 1 + Math.random() * 5);
                detail.rotation.z = angle;
                tunnel.add(detail);
            }
            
            // Add turrets to the tunnel walls
            for (let i = 0; i < 30; i++) {
                createTurret(-100 - i * 60);
            }
            
            // Create enemy ships throughout the tunnel (all ahead of player)
            for (let i = 0; i < 20; i++) {
                createEnemy(-100 - i * 80);
            }
        }
        
        function createFinalTarget() {
            // Create the Death Star-like final target
            const targetGeometry = new THREE.SphereGeometry(15, 32, 32);
            const targetMaterial = new THREE.MeshStandardMaterial({
                color: 0x888888,
                roughness: 0.7,
                metalness: 0.3
            });
            
            const target = new THREE.Mesh(targetGeometry, targetMaterial);
            target.position.z = -tunnelLength + 50;
            target.userData = { 
                isTarget: true,
                health: 10
            };
            scene.add(target);
            
            // Add a glow effect
            const targetGlowGeometry = new THREE.SphereGeometry(16, 32, 32);
            const targetGlowMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.3
            });
            
            const targetGlow = new THREE.Mesh(targetGlowGeometry, targetGlowMaterial);
            target.add(targetGlow);
            
            // Add a small thermal exhaust port
            const exhaustPortGeometry = new THREE.CylinderGeometry(2, 2, 4, 16);
            const exhaustPortMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 });
            const exhaustPort = new THREE.Mesh(exhaustPortGeometry, exhaustPortMaterial);
            exhaustPort.position.y = 15;
            exhaustPort.rotation.x = Math.PI / 2;
            target.add(exhaustPort);
        }

        function createCockpit() {
            // Create a simple cockpit using geometric shapes
            cockpit = new THREE.Group();
            
            // Bottom panel
            const bottomPanelGeometry = new THREE.BoxGeometry(2, 0.1, 1);
            const panelMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const bottomPanel = new THREE.Mesh(bottomPanelGeometry, panelMaterial);
            bottomPanel.position.set(0, -0.6, -0.5);
            cockpit.add(bottomPanel);
            
            // Top panel
            const topPanelGeometry = new THREE.BoxGeometry(2, 0.1, 1);
            const topPanel = new THREE.Mesh(topPanelGeometry, panelMaterial);
            topPanel.position.set(0, 0.6, -0.5);
            cockpit.add(topPanel);
            
            // Side panels
            const sidePanelGeometry = new THREE.BoxGeometry(0.1, 1.2, 1);
            const leftPanel = new THREE.Mesh(sidePanelGeometry, panelMaterial);
            leftPanel.position.set(-1, 0, -0.5);
            cockpit.add(leftPanel);
            
            const rightPanel = new THREE.Mesh(sidePanelGeometry, panelMaterial);
            rightPanel.position.set(1, 0, -0.5);
            cockpit.add(rightPanel);
            
            // Dashboard indicators
            const indicatorGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.05);
            const indicatorMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            
            for (let i = 0; i < 5; i++) {
                const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial.clone());
                indicator.position.set(-0.8 + i * 0.4, -0.5, -0.2);
                cockpit.add(indicator);
            }
            
            // Position the cockpit in front of the camera
            cockpit.position.set(0, -0.2, -0.4);
            camera.add(cockpit);
        }
        
        function setupControllers() {
            // Controller model factory
            const controllerModelFactory = new XRControllerModelFactory();
            
            // Setup controllers
            for (let i = 0; i < 2; i++) {
                const controller = renderer.xr.getController(i);
                controller.addEventListener('connected', (event) => {
                    controller.userData.gamepad = event.data.gamepad;
                    controller.userData.controllerIndex = i;
                });
                scene.add(controller);
                
                const grip = renderer.xr.getControllerGrip(i);
                grip.add(controllerModelFactory.createControllerModel(grip));
                scene.add(grip);
                
                controllers.push(controller);
            }
        }
        
        function createReticles() {
            // Create left reticle (green)
            const leftReticleGeometry = new THREE.RingGeometry(0.015, 0.025, 16);
            const leftReticleMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });
            
            leftReticle = new THREE.Mesh(leftReticleGeometry, leftReticleMaterial);
            leftReticle.position.z = -5;
            scene.add(leftReticle);
            
            // Create right reticle (green)
            const rightReticleGeometry = new THREE.RingGeometry(0.015, 0.025, 16);
            const rightReticleMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });
            
            rightReticle = new THREE.Mesh(rightReticleGeometry, rightReticleMaterial);
            rightReticle.position.z = -5;
            scene.add(rightReticle);
        }
        
        function createEnemy(zPosition) {
            const enemyGroup = new THREE.Group();
            
            // Create enemy body
            const bodyGeometry = new THREE.ConeGeometry(0.8, 2, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x666666 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.x = Math.PI / 2;
            enemyGroup.add(body);
            
            // Create enemy wings
            const wingGeometry = new THREE.BoxGeometry(2.5, 0.1, 0.8);
            const wingMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
            const wings = new THREE.Mesh(wingGeometry, wingMaterial);
            enemyGroup.add(wings);
            
            // Position the enemy ahead of the player
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * (tunnelRadius - 5);
            enemyGroup.position.x = Math.sin(angle) * radius;
            enemyGroup.position.y = Math.cos(angle) * radius;
            enemyGroup.position.z = zPosition;
            
            // Set enemy properties
            enemyGroup.userData = {
                isEnemy: true,
                health: 2,
                speed: 0.05 + Math.random() * 0.1, // Slower approach speed
                direction: new THREE.Vector3(0, 0, 1), // Move towards player
                timeSinceShot: Math.random() * 2 // Random initial delay
            };
            
            scene.add(enemyGroup);
            enemies.push(enemyGroup);
        }
        
        function createTurret(zPosition) {
            const turretGroup = new THREE.Group();
            
            // Create turret base
            const baseGeometry = new THREE.BoxGeometry(2, 2, 2);
            const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            turretGroup.add(base);
            
            // Create turret cannon
            const cannonGeometry = new THREE.CylinderGeometry(0.3, 0.3, 2, 8);
            const cannonMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const cannon = new THREE.Mesh(cannonGeometry, cannonMaterial);
            cannon.rotation.x = Math.PI / 2;
            cannon.position.z = 1;
            turretGroup.add(cannon);
            
            // Position the turret
            const angle = Math.random() * Math.PI * 2;
            turretGroup.position.x = Math.sin(angle) * (tunnelRadius - 1);
            turretGroup.position.y = Math.cos(angle) * (tunnelRadius - 1);
            turretGroup.position.z = zPosition;
            turretGroup.rotation.z = angle;
            
            // Set turret properties
            turretGroup.userData = {
                isTurret: true,
                health: 3,
                timeToNextShot: 2 + Math.random() * 3,
                angle
            };
            
            scene.add(turretGroup);
            turrets.push(turretGroup);
        }
        
        function fireLaser(position, direction, isFromPlayer, controller = 'left') {
            const laserGeometry = new THREE.CylinderGeometry(0.05, 0.05, 4, 8);
            const laserMaterial = new THREE.MeshBasicMaterial({ 
                color: isFromPlayer ? 0x00ff00 : 0xff4444,
                transparent: true,
                opacity: 0.8
            });
            
            const laser = new THREE.Mesh(laserGeometry, laserMaterial);
            laser.position.copy(position);
            
            // Properly orient the laser beam to point in the direction of travel
            const up = new THREE.Vector3(0, 1, 0);
            laser.lookAt(position.clone().add(direction));
            laser.rotateX(Math.PI / 2); // Cylinder's default orientation
            
            laser.userData = {
                isLaser: true,
                direction: direction,
                speed: isFromPlayer ? 4 : 1.5,
                fromPlayer: isFromPlayer,
                controller
            };
            
            scene.add(laser);
            lasers.push(laser);
        }
        
        function createExplosion(position, size = 1, particleCount = 100) {
            const explosionGroup = new THREE.Group();
            explosionGroup.position.copy(position);
            
            // Create explosion particles
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1 * size * Math.random());
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: new THREE.Color(
                        0.8 + Math.random() * 0.2,
                        0.3 * Math.random(),
                        0.1 * Math.random()
                    ) 
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // Random position within explosion radius
                const angle1 = Math.random() * Math.PI * 2;
                const angle2 = Math.random() * Math.PI * 2;
                const radius = Math.random() * 0.1 * size;
                
                particle.position.set(
                    radius * Math.cos(angle1) * Math.sin(angle2),
                    radius * Math.sin(angle1) * Math.sin(angle2),
                    radius * Math.cos(angle2)
                );
                
                // Random velocity
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.2 * size,
                        (Math.random() - 0.5) * 0.2 * size,
                        (Math.random() - 0.5) * 0.2 * size
                    ),
                    lifespan: 1 + Math.random()
                };
                
                explosionGroup.add(particle);
            }
            
            explosionGroup.userData = {
                isExplosion: true,
                age: 0
            };
            
            scene.add(explosionGroup);
            explosions.push(explosionGroup);
        }
        
        function resetGame() {
            // Remove all entities
            for (const enemy of enemies) scene.remove(enemy);
            for (const turret of turrets) scene.remove(turret);
            for (const laser of lasers) scene.remove(laser);
            for (const explosion of explosions) scene.remove(explosion);
            
            enemies = [];
            turrets = [];
            lasers = [];
            explosions = [];
            
            // Reset game state
            score = 0;
            gameOver = false;
            targetDestroyed = false;
            
            // Reset reticle positions
            leftReticlePos = { x: 0, y: 0 };
            rightReticlePos = { x: 0, y: 0 };
            
            // Reset player position
            camera.position.set(0, 0, 0);
            camera.rotation.set(0, Math.PI, 0);
            
            // Recreate the tunnel and entities
            scene.remove(tunnel);
            createTunnel();
            createFinalTarget();
            
            // Update score display
            document.getElementById('score').innerText = `SCORE: ${score}`;
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function updateControllerState() {
            controllers.forEach(controller => {
                if (!controller.userData.gamepad) return;
                
                const gamepad = controller.userData.gamepad;
                const index = controller.userData.controllerIndex;
                const hand = index === 0 ? 'left' : 'right';
                
                // Update joystick position (axes) - improved sensitivity
                if (gamepad.axes.length >= 4) {
                    controllerState[hand].joystick.x = gamepad.axes[2] || 0;
                    controllerState[hand].joystick.y = gamepad.axes[3] || 0;
                }
                
                // Update trigger state
                if (gamepad.buttons.length > 0) {
                    controllerState[hand].trigger = gamepad.buttons[0].pressed;
                    controllerState[hand].squeeze = gamepad.buttons[1].pressed;
                }
            });
        }
        
        function handleControls(delta) {
            if (!gameStarted) return;
            
            // Head tracking for ship movement (dampened)
            if (headTrackingEnabled && initialHeadPosition) {
                const headOffset = new THREE.Vector3().subVectors(camera.position, initialHeadPosition);
                const dampingFactor = 0.3;
                
                // Apply dampened head movement to ship position
                camera.position.x = initialHeadPosition.x + headOffset.x * dampingFactor;
                camera.position.y = initialHeadPosition.y + headOffset.y * dampingFactor;
                
                // Update player hitbox position
                playerHitbox.position.copy(camera.position);
                
                // Limit player position to inside the tunnel
                const maxRadius = tunnelRadius - 2;
                const currentRadius = Math.sqrt(camera.position.x ** 2 + camera.position.y ** 2);
                if (currentRadius > maxRadius) {
                    const angle = Math.atan2(camera.position.y, camera.position.x);
                    camera.position.x = Math.cos(angle) * maxRadius;
                    camera.position.y = Math.sin(angle) * maxRadius;
                    playerHitbox.position.copy(camera.position);
                }
            }
            
            // Left controller aiming (higher fidelity, no snap-back)
            const leftAimX = controllerState.left.joystick.x * 0.008; // Much finer control
            const leftAimY = -controllerState.left.joystick.y * 0.008;
            
            // Accumulate reticle position changes
            leftReticlePos.x += leftAimX;
            leftReticlePos.y += leftAimY;
            
            // Limit reticle range
            const maxReticleRange = 15;
            leftReticlePos.x = Math.max(-maxReticleRange, Math.min(maxReticleRange, leftReticlePos.x));
            leftReticlePos.y = Math.max(-maxReticleRange, Math.min(maxReticleRange, leftReticlePos.y));
            
            // Update left reticle position
            leftReticle.position.x = camera.position.x + leftReticlePos.x;
            leftReticle.position.y = camera.position.y + leftReticlePos.y;
            leftReticle.position.z = camera.position.z - 5;
            
            // Right controller aiming (higher fidelity, no snap-back)
            const rightAimX = controllerState.right.joystick.x * 0.008; // Much finer control
            const rightAimY = -controllerState.right.joystick.y * 0.008;
            
            // Accumulate reticle position changes
            rightReticlePos.x += rightAimX;
            rightReticlePos.y += rightAimY;
            
            // Limit reticle range
            rightReticlePos.x = Math.max(-maxReticleRange, Math.min(maxReticleRange, rightReticlePos.x));
            rightReticlePos.y = Math.max(-maxReticleRange, Math.min(maxReticleRange, rightReticlePos.y));
            
            // Update right reticle position
            rightReticle.position.x = camera.position.x + rightReticlePos.x;
            rightReticle.position.y = camera.position.y + rightReticlePos.y;
            rightReticle.position.z = camera.position.z - 5;
            
            // Fire lasers with triggers
            if (controllerState.left.trigger) {
                // Fire left laser
                const cooldown = 0.15;
                if (!camera.userData.lastLeftShotTime || clock.getElapsedTime() - camera.userData.lastLeftShotTime > cooldown) {
                    const laserPosition = new THREE.Vector3(
                        camera.position.x - 0.3, 
                        camera.position.y, 
                        camera.position.z - 1
                    );
                    
                    const laserDirection = new THREE.Vector3(
                        leftReticle.position.x - camera.position.x,
                        leftReticle.position.y - camera.position.y,
                        leftReticle.position.z - camera.position.z
                    ).normalize();
                    
                    fireLaser(laserPosition, laserDirection, true, 'left');
                    camera.userData.lastLeftShotTime = clock.getElapsedTime();
                }
            }
            
            if (controllerState.right.trigger) {
                // Fire right laser
                const cooldown = 0.15;
                if (!camera.userData.lastRightShotTime || clock.getElapsedTime() - camera.userData.lastRightShotTime > cooldown) {
                    const laserPosition = new THREE.Vector3(
                        camera.position.x + 0.3, 
                        camera.position.y, 
                        camera.position.z - 1
                    );
                    
                    const laserDirection = new THREE.Vector3(
                        rightReticle.position.x - camera.position.x,
                        rightReticle.position.y - camera.position.y,
                        rightReticle.position.z - camera.position.z
                    ).normalize();
                    
                    fireLaser(laserPosition, laserDirection, true, 'right');
                    camera.userData.lastRightShotTime = clock.getElapsedTime();
                }
            }
        }
        
        function updateSpeedParticles(delta) {
            for (let i = speedParticles.length - 1; i >= 0; i--) {
                const particle = speedParticles[i];
                
                // Move particle forward
                particle.position.z += particle.userData.speed;
                
                // Reset particle when it goes behind the camera
                if (particle.position.z > camera.position.z + 10) {
                    particle.position.z = camera.position.z - 100;
                    
                    // Randomize position again
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * (tunnelRadius - 1);
                    particle.position.x = Math.sin(angle) * radius;
                    particle.position.y = Math.cos(angle) * radius;
                }
            }
        }
        
        function updateLasers(delta) {
            for (let i = lasers.length - 1; i >= 0; i--) {
                const laser = lasers[i];
                const direction = laser.userData.direction;
                const speed = laser.userData.speed;
                
                laser.position.x += direction.x * speed;
                laser.position.y += direction.y * speed;
                laser.position.z += direction.z * speed;
                
                // Check if laser is out of bounds
                if (Math.abs(laser.position.z - camera.position.z) > 100) {
                    scene.remove(laser);
                    lasers.splice(i, 1);
                    continue;
                }
                
                // Check for collisions with enemies
                if (laser.userData.fromPlayer) {
                    // Check enemy collisions
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        if (enemy.position.distanceTo(laser.position) < 1.5) {
                            enemy.userData.health--;
                            
                            if (enemy.userData.health <= 0) {
                                createExplosion(enemy.position, 1);
                                scene.remove(enemy);
                                enemies.splice(j, 1);
                                score += 100;
                                document.getElementById('score').innerText = `SCORE: ${score}`;
                            }
                            
                            scene.remove(laser);
                            lasers.splice(i, 1);
                            break;
                        }
                    }
                    
                    // Check turret collisions
                    for (let j = turrets.length - 1; j >= 0; j--) {
                        const turret = turrets[j];
                        if (turret.position.distanceTo(laser.position) < 1.5) {
                            turret.userData.health--;
                            
                            if (turret.userData.health <= 0) {
                                createExplosion(turret.position, 1);
                                scene.remove(turret);
                                turrets.splice(j, 1);
                                score += 150;
                                document.getElementById('score').innerText = `SCORE: ${score}`;
                            }
                            
                            scene.remove(laser);
                            lasers.splice(i, 1);
                            break;
                        }
                    }
                    
                    // Check final target collision
                    const finalTarget = scene.children.find(child => child.userData && child.userData.isTarget);
                    if (finalTarget && laser.position.distanceTo(finalTarget.position) < 16) {
                        finalTarget.userData.health--;
                        
                        scene.remove(laser);
                        lasers.splice(i, 1);
                        
                        if (finalTarget.userData.health <= 0 && !targetDestroyed) {
                            targetDestroyed = true;
                            createExplosion(finalTarget.position, 10, 1000);
                            scene.remove(finalTarget);
                            score += 10000;
                            document.getElementById('score').innerText = `SCORE: ${score}`;
                        }
                    }
                } else {
                    // Laser from enemy or turret hitting player
                    if (laser.position.distanceTo(playerHitbox.position) < 1.2 && !gameOver) {
                        gameOver = true;
                        createExplosion(playerHitbox.position, 2);
                        
                        // Reset after short delay
                        setTimeout(() => {
                            resetGame();
                        }, 3000);
                        
                        scene.remove(laser);
                        lasers.splice(i, 1);
                    }
                }
            }
        }
        
        function updateEnemies(delta) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // Move enemy towards player gradually
                enemy.position.z += enemy.userData.speed;
                
                // Make enemy gradually approach player's position
                const approachSpeed = 0.02;
                const targetX = playerHitbox.position.x;
                const targetY = playerHitbox.position.y;
                
                enemy.position.x += (targetX - enemy.position.x) * approachSpeed;
                enemy.position.y += (targetY - enemy.position.y) * approachSpeed;
                
                if (enemy.position.z < camera.position.z + 100) {
                    // Make enemy face player
                    enemy.lookAt(playerHitbox.position);
                    
                    // Occasionally shoot at player
                    enemy.userData.timeSinceShot += delta;
                    if (enemy.userData.timeSinceShot > 3) {
                        enemy.userData.timeSinceShot = 0;
                        
                        const laserDirection = new THREE.Vector3(
                            playerHitbox.position.x - enemy.position.x,
                            playerHitbox.position.y - enemy.position.y,
                            playerHitbox.position.z - enemy.position.z
                        ).normalize();
                        
                        fireLaser(enemy.position.clone(), laserDirection, false);
                    }
                }
                
                // Check for collision with player
                if (enemy.position.distanceTo(playerHitbox.position) < 1.5 && !gameOver) {
                    gameOver = true;
                    createExplosion(playerHitbox.position, 2);
                    
                    setTimeout(() => {
                        resetGame();
                    }, 3000);
                }
                
                // Remove enemies that have passed the player
                if (enemy.position.z > camera.position.z + 50) {
                    scene.remove(enemy);
                    enemies.splice(i, 1);
                }
            }
        }
        
        function updateTurrets(delta) {
            for (let i = turrets.length - 1; i >= 0; i--) {
                const turret = turrets[i];
                
                // Only activate turrets that are close enough
                if (turret.position.z < camera.position.z + 50 && turret.position.z > camera.position.z - 50) {
                    // Make turret face player
                    turret.lookAt(playerHitbox.position);
                    
                    // Occasionally shoot at player
                    turret.userData.timeToNextShot -= delta;
                    if (turret.userData.timeToNextShot <= 0) {
                        turret.userData.timeToNextShot = 2 + Math.random() * 2;
                        
                        const laserDirection = new THREE.Vector3(
                            playerHitbox.position.x - turret.position.x,
                            playerHitbox.position.y - turret.position.y,
                            playerHitbox.position.z - turret.position.z
                        ).normalize();
                        
                        fireLaser(turret.position.clone(), laserDirection, false);
                    }
                }
            }
        }
        
        function updateExplosions(delta) {
            for (let i = explosions.length - 1; i >= 0; i--) {
                const explosion = explosions[i];
                explosion.userData.age += delta;
                
                // Update particles in the explosion
                explosion.children.forEach(particle => {
                    particle.position.add(particle.userData.velocity);
                    particle.userData.lifespan -= delta;
                    
                    if (particle.userData.lifespan <= 0) {
                        particle.scale.multiplyScalar(0.9);
                    }
                });
                
                // Remove old explosions
                if (explosion.userData.age > 2) {
                    scene.remove(explosion);
                    explosions.splice(i, 1);
                }
            }
        }
        
        function animate() {
            if (showingVRButton) {
                renderer.render(scene, camera);
                return;
            }
            
            const delta = clock.getDelta();
            
            // Update controller state
            updateControllerState();
            
            // Handle player controls
            handleControls(delta);
            
            // Move player forward
            if (gameStarted && !gameOver) {
                camera.position.z -= playerSpeed;
                
                // Update reticle positions
                leftReticle.position.z = camera.position.z - 5;
                rightReticle.position.z = camera.position.z - 5;
                
                // Update player hitbox
                playerHitbox.position.z = camera.position.z;
            }
            
            // Update game entities
            updateSpeedParticles(delta);
            updateLasers(delta);
            updateEnemies(delta);
            updateTurrets(delta);
            updateExplosions(delta);
            
            // Render the scene
            renderer.render(scene, camera);
        }
        
        // Initialize the game
        init();
    </script>
</body>
</html>
