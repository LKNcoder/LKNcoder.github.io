<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ring Game</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/dat.gui.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/vr/WebXR.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/vr/VRButton.js"></script>
<script>
  let scene, camera, renderer;
  let ring, ringStartPosition, wirePoints, wireMaterial, textMesh, timerMesh, font;
  let sphere1, sphere2, controller1, controller2;
  let grabbed = false, grabbingController = null, grabOffset, grabRotationOffset;
  let startTime = null, elapsedTime = 0;
  const contactSound = new Audio('contact.mp3');

  init();
  animate();

  function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 3);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    document.body.appendChild(THREE.VRButton.createButton(renderer));

    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(1, 1, 1).normalize();
    scene.add(light);

    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);

    // Define wirePoints with some example points
    wirePoints = [
      new THREE.Vector3(-0.5, 1.6, 0),
      new THREE.Vector3(0, 1.6, 0),
      new THREE.Vector3(0.5, 1.6, 0)
    ];

    const wireGeometry = new THREE.BufferGeometry().setFromPoints(wirePoints);
    wireMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
    const wire = new THREE.Line(wireGeometry, wireMaterial);
    scene.add(wire);

    const ringGeometry = new THREE.TorusGeometry(0.075, 0.00625, 16, 100);
    const ringMaterial = new THREE.MeshStandardMaterial({
      color: 0x00ff00,
      emissive: 0x00ff00,
      emissiveIntensity: 1.0,
      metalness: 1.0,
      roughness: 0.0
    });
    ring = new THREE.Mesh(ringGeometry, ringMaterial);
    ringStartPosition = new THREE.Vector3(0, 1.6, 0);
    ring.position.copy(ringStartPosition);
    ring.rotation.y = Math.PI / 2;
    scene.add(ring);

    const ringColliderGeometry = new THREE.TorusGeometry(0.075, 0.00625, 16, 100);
    const ringColliderMaterial = new THREE.MeshBasicMaterial({ visible: false });
    const ringCollider = new THREE.Mesh(ringColliderGeometry, ringColliderMaterial);
    ringCollider.position.copy(ringStartPosition);
    ringCollider.rotation.y = Math.PI / 2;
    scene.add(ringCollider);

    const fontLoader = new THREE.FontLoader();
    fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (loadedFont) {
      font = loadedFont;

      const textGeometry = new THREE.TextGeometry('Ring Game', {
        font: font,
        size: 0.1,
        height: 0.02,
      });
      const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
      textMesh = new THREE.Mesh(textGeometry, textMaterial);
      textMesh.position.set(-0.5, 2, 0);
      scene.add(textMesh);

      const timerGeometry = new THREE.TextGeometry('00:000', {
        font: font,
        size: 0.02,
        height: 0.005,
      });
      const timerMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
      timerMesh = new THREE.Mesh(timerGeometry, timerMaterial);
      timerMesh.position.set(-0.5, 1.8, 0);
      scene.add(timerMesh);
    });

    const sphereGeometry = new THREE.SphereGeometry(0.02, 32, 32);
    const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    sphere1 = new THREE.Mesh(sphereGeometry, sphereMaterial);
    sphere2 = new THREE.Mesh(sphereGeometry, sphereMaterial);
    scene.add(sphere1);
    scene.add(sphere2);

    controller1 = new THREE.Group();
    controller2 = new THREE.Group();
    scene.add(controller1);
    scene.add(controller2);

    window.addEventListener('resize', onWindowResize, false);
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function createShatterEffect(position) {
    const shatterPieces = 50;
    const shatterGeometry = new THREE.BoxGeometry(0.01, 0.01, 0.01);
    const shatterMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });

    const shatterMesh = new THREE.InstancedMesh(shatterGeometry, shatterMaterial, shatterPieces);
    const dummy = new THREE.Object3D();

    for (let i = 0; i < shatterPieces; i++) {
      dummy.position.set(
        position.x + (Math.random() - 0.5) * 0.1,
        position.y + (Math.random() - 0.5) * 0.1,
        position.z + (Math.random() - 0.5) * 0.1
      );
      dummy.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
      dummy.updateMatrix();
      shatterMesh.setMatrixAt(i, dummy.matrix);
    }

    scene.add(shatterMesh);

    const shatterDuration = 500;
    const startTime = Date.now();

    function animateShatter() {
      const elapsedTime = Date.now() - startTime;
      const progress = elapsedTime / shatterDuration;

      for (let i = 0; i < shatterPieces; i++) {
        shatterMesh.getMatrixAt(i, dummy.matrix);
        dummy.position.multiplyScalar(1 + progress);
        dummy.updateMatrix();
        shatterMesh.setMatrixAt(i, dummy.matrix);
      }

      shatterMesh.instanceMatrix.needsUpdate = true;

      if (progress < 1) {
        requestAnimationFrame(animateShatter);
      } else {
        scene.remove(shatterMesh);
      }
    }

    animateShatter();
  }

  function resetWireColor() {
    wireMaterial.color.set(0x00ff00);
  }

  function updateWireColor() {
    const ringPosition = ring.position;
    let closestPointIndex = 0;
    let closestDistance = Infinity;

    for (let i = 0; i < wirePoints.length; i++) {
      const distance = ringPosition.distanceTo(wirePoints[i]);
      if (distance < closestDistance) {
        closestDistance = distance;
        closestPointIndex = i;
      }
    }

    const progress = closestPointIndex / wirePoints.length;
    for (let i = 0; i <= closestPointIndex; i++) {
      wireMaterial.color.set(0xff00ff);
    }

    if (progress >= 1.0) {
      victory();
    }
  }

  function handleCollision() {
    createShatterEffect(ring.position);
    ring.position.copy(ringStartPosition);
    ring.rotation.set(0, Math.PI / 2, 0);
    contactSound.play();
    resetWireColor();
  }

  function updateBoundingBoxes() {
    // Define the bounding boxes for collision detection
    sphere1.updateMatrixWorld();
    sphere2.updateMatrixWorld();
    ring.updateMatrixWorld();
  }

  function checkCollision() {
    // Implement collision detection logic here
    // Return true if a collision is detected, otherwise return false
    return false;
  }

  function render() {
    sphere1.position.copy(controller1.position);
    sphere2.position.copy(controller2.position);

    updateBoundingBoxes();
    if (checkCollision()) {
      handleCollision();
    }

    if (grabbed && grabbingController) {
      ring.position.copy(grabbingController.position).add(grabOffset);
      ring.quaternion.copy(grabbingController.quaternion).multiply(grabRotationOffset);

      sphere1.visible = false;
      sphere2.visible = false;
    } else {
      sphere1.visible = true;
      sphere2.visible = true;
    }

    textMesh.position.set(ring.position.x, ring.position.y + 0.2, ring.position.z);
    textMesh.geometry.computeBoundingBox();
    const centerOffset = -0.5 * (textMesh.geometry.boundingBox.max.x - textMesh.geometry.boundingBox.min.x);
    textMesh.position.x += centerOffset;
    textMesh.lookAt(camera.position);

    if (startTime !== null) {
      elapsedTime = Date.now() - startTime;
      const milliseconds = Math.floor(elapsedTime % 1000);
      const seconds = Math.floor((elapsedTime / 1000) % 60);
      const timerText = `${seconds.toString().padStart(2, '0')}:${milliseconds.toString().padStart(3, '0')}`;

      const timerGeometry = new THREE.TextGeometry(timerText, {
        font: font,
        size: 0.02,
        height: 0.005,
      });
      timerMesh.geometry.dispose();
      timerMesh.geometry = timerGeometry;
      timerMesh.geometry.computeBoundingBox();
      const timerCenterOffset = -0.5 * (timerMesh.geometry.boundingBox.max.x - timerMesh.geometry.boundingBox.min.x);
      timerMesh.position.set(ring.position.x + timerCenterOffset, ring.position.y + 0.1, ring.position.z);
      timerMesh.lookAt(camera.position);
    }

    timerMesh.position.set(ring.position.x, ring.position.y + 0.15, ring.position.z);
    const timerCenterOffset = -0.5 * (timerMesh.geometry.boundingBox.max.x - timerMesh.geometry.boundingBox.min.x);
    timerMesh.position.x += timerCenterOffset;
    timerMesh.lookAt(camera.position);

    updateWireColor();

    renderer.render(scene, camera);
  }

  function animate() {
    renderer.setAnimationLoop(render);
  }
</script>
</body>
</html>
