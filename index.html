<!doctype html>
<html>
<head>
<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
<meta name='mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<link rel='icon' type='image/png' sizes='32x32' href='favicon-32x32.png'>
<link rel='icon' type='image/png' sizes='96x96' href='favicon-96x96.png'>
<title>Ring Ring</title>
<style>
body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #f0f0f0; }
canvas { display: block; }
#vrButton {
padding: 20px 40px;
font-size: 24px;
background-color: #0078d7;
color: white;
border: none;
border-radius: 10px;
cursor: pointer;
transition: background-color 0.3s ease;
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
}
#vrButton:hover { background-color: #005bb5; }
</style>
</head>
<body>
<button id="vrButton">Enter VR</button>
<script type="importmap">
{
"imports": {
"three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
"three/examples/jsm/webxr/VRButton.js": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/webxr/VRButton.js",
"three/examples/jsm/webxr/XRControllerModelFactory.js": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/webxr/XRControllerModelFactory.js"
}
}
</script>
<script type="module">
import * as THREE from 'three';
import { VRButton } from 'three/examples/jsm/webxr/VRButton.js';

let camera, scene, renderer, controller1, controller2, sphere1, sphere2, ring, textMesh, timerMesh;
let grabbed = false, grabbingController = null, grabOffset = new THREE.Vector3(), grabRotationOffset = new THREE.Quaternion();
let startTime = null, elapsedTime = 0, font, timerFont, wire, wirePoints = [], wireMaterial, victorySound, contactSound;
const ringStartPosition = new THREE.Vector3(0, 1.35, -0.75);
let currentLevel = 1; // Track current level
let levelTimes = []; // Array to store completion times for each level
let explosionFragments = [];
let explosionStartTime = null;
let isExploding = false;
let confettiParticles = [];
let confettiStartTime = null;
let gameCompletionMeshes = [];
let transitionImmunity = false;

// Sound effects and flashing state
let applauseSound, longApplauseSound, longHornsSound, hornsSound, chimeSound;
let isFlashing = false;

init();
animate();

function init() {
scene = new THREE.Scene();
camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.xr.enabled = true;
document.body.appendChild(renderer.domElement);

const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
light.position.set(0.5, 1, 0.25);
scene.add(light);

const ringGeometry = new THREE.TorusGeometry(0.075, 0.00625, 16, 100);
const ringMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 1.0, metalness: 1.0, roughness: 0.0 });
ring = new THREE.Mesh(ringGeometry, ringMaterial);
ring.position.copy(ringStartPosition);
ring.rotation.y = Math.PI / 2;
scene.add(ring);

const loader = new THREE.FontLoader();
loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (loadedFont) {
font = loadedFont;
const textGeometry = new THREE.TextGeometry(`LEVEL ${currentLevel}/5`, { font: font, size: 0.02, height: 0.005 });
const textMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
textMesh = new THREE.Mesh(textGeometry, textMaterial);
textGeometry.computeBoundingBox();
const centerOffset = -0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x);
textMesh.position.set(centerOffset, 2.0, -0.75);
scene.add(textMesh);

// Load a monospaced font for the timer
const timerFontURL = 'https://threejs.org/examples/fonts/gentilis_regular.typeface.json';
loader.load(timerFontURL, function (loadedTimerFont) {
timerFont = loadedTimerFont;
// Use the loaded font for the timer with shorter format
const timerGeometry = new THREE.TextGeometry('0:00:000', { font: timerFont, size: 0.02, height: 0.005 });
const timerMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
timerMesh = new THREE.Mesh(timerGeometry, timerMaterial);
timerGeometry.computeBoundingBox();
const timerCenterOffset = -0.5 * (timerGeometry.boundingBox.max.x - timerGeometry.boundingBox.min.x);
timerMesh.position.set(timerCenterOffset, 1.8, -0.75);
scene.add(timerMesh);
});
});

const sphereGeometry = new THREE.SphereGeometry(0.05, 32, 32);
const sphereMaterial = new THREE.MeshStandardMaterial({ color: 0x0078d7, transparent: true, opacity: 0.5 });
sphere1 = new THREE.Mesh(sphereGeometry, sphereMaterial);
scene.add(sphere1);
sphere2 = new THREE.Mesh(sphereGeometry, sphereMaterial);
scene.add(sphere2);

controller1 = renderer.xr.getController(0);
controller1.addEventListener('selectstart', onSelectStart);
controller1.addEventListener('selectend', onSelectEnd);
controller1.addEventListener('squeezestart', onSelectStart);
controller1.addEventListener('squeezeend', onSelectEnd);
scene.add(controller1);

controller2 = renderer.xr.getController(1);
controller2.addEventListener('selectstart', onSelectStart);
controller2.addEventListener('selectend', onSelectEnd);
controller2.addEventListener('squeezestart', onSelectStart);
controller2.addEventListener('squeezeend', onSelectEnd);
scene.add(controller2);

window.addEventListener('resize', onWindowResize, false);

const vrButton = document.getElementById('vrButton');
vrButton.addEventListener('click', async () => {
try {
chimeSound.play().catch(error => console.log('Chime sound play error:', error));
const session = await navigator.xr.requestSession('immersive-vr', { optionalFeatures: ['local-floor', 'hand-tracking'] });
renderer.xr.setSession(session);
vrButton.style.display = 'none';

  // Initialize haptics after the session starts
  session.addEventListener('inputsourceschange', () => {
      console.log('XR input sources changed, initializing haptics');
      initControllerHaptics();
    });
    
    // Also try initializing after a delay as a backup approach
    setTimeout(initControllerHaptics, 2000);

} catch (error) {
console.error('Failed to enter VR:', error);
}
});

const particlesGeometry = new THREE.BufferGeometry();
const particlesCount = 3000;
const posArray = new Float32Array(particlesCount * 3);
const minDistance = 5.0; // Minimum distance from center to avoid particles near wire
for (let i = 0; i < particlesCount * 3; i += 3) {
let x = (Math.random() - 0.5) * 100;
let y = (Math.random() - 0.5) * 100;
let z = (Math.random() - 0.5) * 100;

 // Calculate distance from center
 const distance = Math.sqrt(x*x + y*y + z*z);

   // If too close, push it outward to minimum distance
   if (distance < minDistance) {
    const scale = minDistance / distance;
    x *= scale;
    y *= scale;
    z *= scale;
  }

posArray[i] = x;
posArray[i + 1] = y;
posArray[i + 2] = z;
}
particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
const particlesMaterial = new THREE.PointsMaterial({ size: 0.2, color: 0x00ffff, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
scene.add(particlesMesh);

wire = createWire(currentLevel);

// Load all sound effects
victorySound = new Audio('short_horns.mp3');
contactSound = new Audio('contact.mp3');
applauseSound = new Audio('short_applause.mp3');
longApplauseSound = new Audio('long_applause.mp3');
longHornsSound = new Audio('long_horns.mp3');
chimeSound = new Audio('chime.mp3');
}

// helper function for haptic feedback
function triggerHapticFeedback(controller, intensity, duration) {
  const gamepad = controller ? controller.gamepad : null;
  
  if (gamepad) {
    try {
      console.log('Controller index:', controller.userData ? controller.userData.index : 'unknown');
      
      // Specific handling for Oculus/Meta Quest controllers
      // Quest controllers are typically identified by "Oculus Touch" in their id
      if (gamepad.id && gamepad.id.includes("Oculus Touch")) {
        console.log('Quest controller detected, using appropriate haptic method');
        
        if (gamepad.hapticActuators && gamepad.hapticActuators.length > 0) {
          return gamepad.hapticActuators[0].pulse(intensity, duration);
        } else if (gamepad.vibrationActuator) {
          return gamepad.vibrationActuator.playEffect('dual-rumble', {
            duration: duration,
            strongMagnitude: intensity,
            weakMagnitude: intensity
          });
        }
      } 
      // Standard WebXR method as fallback
      else if (gamepad.hapticActuators && gamepad.hapticActuators.length > 0) {
        return gamepad.hapticActuators[0].pulse(intensity, duration);
      }
      else {
        console.warn('No haptic actuators found on gamepad:', gamepad.id || 'unknown gamepad');
      }
    } catch (error) {
      console.error('Haptic feedback error:', error);
    }
  } else {
    console.warn('No gamepad available on controller');
  }
}

function initControllerHaptics() {
  // Store controller indexes for better debugging and access
  if (controller1) controller1.userData = { index: 0 };
  if (controller2) controller2.userData = { index: 1 };
  
  console.log('Controller haptics initialized');
  
  // Test haptic feedback after a moment to ensure everything is ready
  setTimeout(() => {
    console.log('Testing haptic feedback...');
    console.log('Controller1 gamepad:', controller1.gamepad);
    console.log('Controller2 gamepad:', controller2.gamepad);
    
    triggerHapticFeedback(controller1, 0.5, 300);
    setTimeout(() => triggerHapticFeedback(controller2, 0.5, 300), 500);
  }, 1000);
}

// Function to make the wire flash
function flashWire(times = 3, isGameComplete = false) {
if (isFlashing) return;
isFlashing = true;

let flashCount = 0;
const maxFlashes = times * 2; // Each flash is white->blue, so double the count
const flashDuration = isGameComplete ? 250 : 150; // Slower flashing for game complete

function flash() {
if (flashCount >= maxFlashes) {
isFlashing = false;
return;
}

const colors = wire.geometry.attributes.color.array;
const isWhite = flashCount % 2 === 0;

for (let i = 0; i < colors.length; i += 3) {
colors[i] = isWhite ? 1 : 0;     // R
colors[i + 1] = isWhite ? 1 : 0; // G
colors[i + 2] = 1;               // B (always 1 for white or blue)
}

wire.geometry.attributes.color.needsUpdate = true;
flashCount++;

setTimeout(flash, flashDuration);
}

flash();
}

function createWire(level = 1) {
// Remove old wire if it exists
if (wire) {
scene.remove(wire);
if (wire.geometry) wire.geometry.dispose();
}

const points = [];
const segments = 200;
const radius = 0.75;

// Add rotation offset for different levels
const rotationOffset = level === 2 ? Math.PI / 5.3 : 
level === 3 ? Math.PI / 1.6 : 
level === 4 ? Math.PI / 6.3 : 
level === 5 ? Math.PI / 1.1 : 0;

for (let i = 0; i <= segments; i++) {
const t = i / segments;
const angle = t * Math.PI * 2;

let waveX, waveY, waveZ, x, y, z;

if (level === 1) {
// Level 1 wire pattern
waveX = Math.sin(angle * 8) * 0.05;
waveY = Math.cos(angle * 6) * 0.05;
x = (Math.cos(angle) * radius) + waveX;
y = 1.4 + waveY;
z = (Math.sin(angle) * radius) + waveX;
} 
else if (level === 2) {
// Level 2 wire pattern 
waveX = Math.sin(angle * 7) * 0.07 + Math.cos(angle * 3) * 0.04;
waveY = Math.cos(angle * 5) * 0.08 + Math.sin(angle * 9) * 0.03;
waveZ = Math.sin(angle * 6) * 0.07 + Math.cos(angle * 4) * 0.05;

// Create gentle undulations in height
const heightVar = Math.sin(angle * 3) * 0.06;

const rotatedAngle = angle + rotationOffset;
// Create an elliptical path 
x = (Math.cos(rotatedAngle) * radius * (1 + Math.sin(angle * 2) * 0.1)) + waveX;
y = 1.4 + waveY + heightVar;
z = (Math.sin(rotatedAngle) * radius * (1 + Math.cos(angle * 2) * 0.08)) + waveZ;
}
else if (level === 3) {
// Level 3 wire pattern
waveX = Math.sin(angle * 10) * 0.08;
waveY = Math.cos(angle * 8) * 0.08 + Math.sin(angle * 16) * 0.03;
waveZ = Math.sin(angle * 12) * 0.06;

const rotatedAngle = angle + rotationOffset;
x = (Math.cos(rotatedAngle) * radius) + waveX;
y = 1.4 + waveY;
z = (Math.sin(rotatedAngle) * radius) + waveZ;
}
else if (level === 4) {
// Level 4 wire pattern - most complex but still navigable

// Use prime number frequencies for less predictable patterns
waveX = Math.sin(angle * 11) * 0.07 + Math.cos(angle * 5) * 0.05;
waveY = Math.cos(angle * 7) * 0.09 + Math.sin(angle * 13) * 0.04;
waveZ = Math.sin(angle * 17) * 0.06 + Math.cos(angle * 3) * 0.07;

// Add some controlled chaos with sectional variations
// Divide the wire into sections with different behaviors
const section = Math.floor(angle / (Math.PI/2)); // 0-3 sections

// Base Y position that's consistent across all sections
y = 1.4 + waveY + Math.sin(angle * 2) * 0.07;

// Apply section-specific modifications to y-coordinate
const sectionFactor = section === 0 ? t * 4 : 
section === 1 ? (t - 0.25) * 4 :
section === 2 ? (t - 0.5) * 4 :
(t - 0.75) * 4;

if (section === 0) {
// First quarter - spiral up - add to base y
y += (sectionFactor * 0.15);
} else if (section === 3) {
// Fourth quarter - smooth transition back
// Use a sine curve for smooth transition
y += Math.sin(sectionFactor * Math.PI) * 0.08;
}

// Create smooth transition variations in radius
const radiusVar = 1 + 0.15 * Math.sin(angle * 2) - 0.05 * Math.cos(angle * 5);

const rotatedAngle = angle + rotationOffset;
x = (Math.cos(rotatedAngle) * radius * radiusVar) + waveX;
// y is already set above
z = (Math.sin(rotatedAngle) * radius * radiusVar) + waveZ;
}

else if (level === 5) {
  // Level 5 - challenging but navigable
  // Use moderate frequency combinations
  waveX = Math.sin(angle * 9) * 0.07 + Math.cos(angle * 5) * 0.05;
  waveY = Math.cos(angle * 7) * 0.08 + Math.sin(angle * 4) * 0.06;
  waveZ = Math.sin(angle * 6) * 0.07 + Math.cos(angle * 3) * 0.05;

  // Create gentle undulation with variable height
  const heightFactor = Math.sin(angle * 2) * 0.15;
  y = 1.4 + waveY + heightFactor;
  
  // Create interesting path with 4 distinct sections
  const section = Math.floor(angle / (Math.PI/2)); // 0-3 sections
  const sectionFactor = section === 0 ? t * 4 : 
                        section === 1 ? (t - 0.25) * 4 :
                        section === 2 ? (t - 0.5) * 4 : 
                        (t - 0.75) * 4;
  
  // Section-specific modifications
  if (section === 0) {
    // First quarter - gradual ascent
    y += Math.sin(sectionFactor * Math.PI * 0.5) * 0.12;
  } else if (section === 1) {
    // Second quarter - oscillating path
    waveX += Math.sin(sectionFactor * Math.PI * 3) * 0.06;
    waveZ += Math.cos(sectionFactor * Math.PI * 3) * 0.06;
  } else if (section === 2) {
    // Third quarter - gentle descent with wider radius
    y -= Math.sin(sectionFactor * Math.PI * 0.5) * 0.12;
    waveX *= 1.2;
    waveZ *= 1.2;
  } else {
    // Fourth quarter - smooth transition back to start
    waveX *= (1.2 - sectionFactor * 0.2);
    waveZ *= (1.2 - sectionFactor * 0.2);
  }

  // Add some controlled radius variation
  const radiusVar = 1 + Math.sin(angle * 2) * 0.1;
  
  const rotatedAngle = angle + rotationOffset;
  x = (Math.cos(rotatedAngle) * radius * radiusVar) + waveX;
  // y is already set above
  z = (Math.sin(rotatedAngle) * radius * radiusVar) + waveZ;
}

points.push(new THREE.Vector3(x, y, z));
}

wirePoints = points;
const geometry = new THREE.BufferGeometry().setFromPoints(points);
const colors = new Float32Array(points.length * 3);
for (let i = 0; i < points.length; i++) {
colors[i * 3] = 1; // R
colors[i * 3 + 1] = 0; // G
colors[i * 3 + 2] = 1; // B
}
geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
wireMaterial = new THREE.LineBasicMaterial({ vertexColors: true, linewidth: 7 });

wire = new THREE.Line(geometry, wireMaterial);
scene.add(wire);

console.log(`Wire for level ${level} created:`, wire);
return wire;
}

function explodeRing() {
  if (isExploding) return; // Prevent multiple explosions
  isExploding = true;
  explosionStartTime = Date.now();
  
  // Hide the original ring
  ring.visible = false;
  
  // Create fragments
  const segments = 20;
  for (let i = 0; i < segments; i++) {
    // Create fragment geometry (smaller than the original ring)
    const fragGeometry = new THREE.TorusGeometry(0.075, 0.00625, 8, 6, Math.PI * 2 / segments);
    const fragMaterial = new THREE.MeshStandardMaterial({ 
      color: 0x00ff00, 
      emissive: 0x00ff00, 
      emissiveIntensity: 1.0, 
      metalness: 1.0, 
      roughness: 0.0 
    });
    const fragment = new THREE.Mesh(fragGeometry, fragMaterial);
    
    // Position and rotate to match the original ring
    fragment.position.copy(ring.position);
    fragment.rotation.copy(ring.rotation);
    
    // Rotate fragment to correct position in the ring
    fragment.rotateOnAxis(new THREE.Vector3(0, 1, 0), (i / segments) * Math.PI * 2);
    
    // Add explosion velocity - direction slightly outward from the center
    const angle = (i / segments) * Math.PI * 2;
    const direction = new THREE.Vector3(Math.cos(angle), 0.2, Math.sin(angle));
    direction.normalize();
    
    fragment.userData.velocity = direction.multiplyScalar(0.02 + Math.random() * 0.02);
    fragment.userData.rotationSpeed = {
      x: (Math.random() - 0.5) * 0.2,
      y: (Math.random() - 0.5) * 0.2,
      z: (Math.random() - 0.5) * 0.2
    };
    
    // Add to scene and array
    scene.add(fragment);
    explosionFragments.push(fragment);
  }
}

function onWindowResize() {
camera.aspect = window.innerWidth / window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth, window.innerHeight);
}

function checkCollision() {
const ringVertices = ring.geometry.attributes.position.array;
const ringMatrixWorld = ring.matrixWorld;
const thresholdDistance = 0.01; // Adjust this value as needed

for (let i = 0; i < ringVertices.length; i += 3) {
const vertex = new THREE.Vector3(ringVertices[i], ringVertices[i + 1], ringVertices[i + 2]);
vertex.applyMatrix4(ringMatrixWorld);

for (let j = 0; j < wirePoints.length; j++) {
const distance = vertex.distanceTo(wirePoints[j]);
if (distance < thresholdDistance) {
console.log('Collision detected');
return true;
}
}
}

return false;
}

function onSelectStart(event) {
const ringBox = new THREE.Box3().setFromObject(ring);
const sphereBox1 = new THREE.Sphere(sphere1.position, 0.05);
const sphereBox2 = new THREE.Sphere(sphere2.position, 0.05);

// Check for button interactions first
if (gameCompletionMeshes.length > 0) {
    const controllerPosition = event.target.position;
    const raycaster = new THREE.Raycaster();
    const direction = new THREE.Vector3(0, 0, -1);
    direction.applyQuaternion(event.target.quaternion);
    raycaster.set(controllerPosition, direction);
    
    const buttonIntersects = raycaster.intersectObjects(gameCompletionMeshes.filter(mesh => mesh.userData && mesh.userData.isButton));
    
    if (buttonIntersects.length > 0) {
      const button = buttonIntersects[0].object;
      
      if (button.userData.buttonType === 'restart') {
        // Reset game state
        restartGame();
        return;
      } else if (button.userData.buttonType === 'quit') {
        // Exit VR session if active
        if (renderer.xr.isPresenting) {
          renderer.xr.getSession().end();
        }
        // Show "Thanks for playing" message
        alert("Thanks for playing!");
        return;
      }
    }
  }

if (ringBox.intersectsSphere(sphereBox1) && event.target === controller1) {
grabbed = true;
grabbingController = controller1;
grabOffset.copy(ring.position).sub(controller1.position);
grabRotationOffset.copy(controller1.quaternion).invert().multiply(ring.quaternion);
if (startTime === null) {
startTime = Date.now() - elapsedTime;
}
} else if (ringBox.intersectsSphere(sphereBox2) && event.target === controller2) {
grabbed = true;
grabbingController = controller2;
grabOffset.copy(ring.position).sub(controller2.position);
grabRotationOffset.copy(controller2.quaternion).invert().multiply(ring.quaternion);
if (startTime === null) {
startTime = Date.now() - elapsedTime;
}
}
}

function onSelectEnd(event) {
if (event.target === grabbingController) {
grabbed = false;
grabbingController = null;
}
}

// Add the restartGame function
function restartGame() {
  // Clean up game completion meshes
  gameCompletionMeshes.forEach(mesh => {
    scene.remove(mesh);
    if (mesh.geometry) mesh.geometry.dispose();
    if (mesh.material) mesh.material.dispose();
  });
  gameCompletionMeshes = [];
  
  // Reset game state
  currentLevel = 1;
  levelTimes = [];
  startTime = null;
  elapsedTime = 0;
  
  // Show ring and reset position
  ring.visible = true;
  ring.position.copy(ringStartPosition);
  ring.rotation.set(0, Math.PI / 2, 0);
  
  // Create new wire for level 1
  wire = createWire(currentLevel);
  wire.visible = true;
  
  // Reset the level text
  if (textMesh && font) {
    textMesh.geometry.dispose();
    textMesh.geometry = new THREE.TextGeometry(`LEVEL ${currentLevel}/5`, { font: font, size: 0.02, height: 0.005 });
    textMesh.geometry.computeBoundingBox();
    const centerOffset = -0.5 * (textMesh.geometry.boundingBox.max.x - textMesh.geometry.boundingBox.min.x);
    textMesh.position.set(centerOffset, 2.0, -0.75);
    scene.add(textMesh);
  }
  
  // Reset and show timer
  if (timerMesh && timerFont) {
    timerMesh.geometry.dispose();
    timerMesh.geometry = new THREE.TextGeometry('0:00:000', {
      font: timerFont,
      size: 0.02,
      height: 0.005,
    });
    timerMesh.visible = true;
    timerMesh.geometry.computeBoundingBox();
    const timerCenterOffset = -0.5 * (timerMesh.geometry.boundingBox.max.x - timerMesh.geometry.boundingBox.min.x);
    timerMesh.position.set(ring.position.x + timerCenterOffset, ring.position.y + 0.1, ring.position.z);
  }
  
  // Play chime sound to indicate restart
  chimeSound.play().catch(error => console.log('Sound play error:', error));
}

function animate() {
renderer.setAnimationLoop(render);
}

function render() {
// Update sphere positions to match controller positions
if (controller1 && controller2) {
sphere1.position.copy(controller1.position);
sphere2.position.copy(controller2.position);
}

// Check for collisions
if (!isExploding && !transitionImmunity && checkCollision()) {
    handleCollision();
  }

// Move ring with the grabbing controller while maintaining the offset
if (grabbed && grabbingController) {
ring.position.copy(grabbingController.position).add(grabOffset);
ring.quaternion.copy(grabbingController.quaternion).multiply(grabRotationOffset); // Update ring rotation to match controller rotation

// Hide the spheres when the ring is grabbed
sphere1.visible = false;
sphere2.visible = false;
} else {
// Show the spheres when the ring is not grabbed
sphere1.visible = true;
sphere2.visible = true;
}

// Keep the text and timer above the ring and billboarded to face the player
if (textMesh) {
textMesh.position.set(ring.position.x, ring.position.y + 0.2, ring.position.z);
textMesh.geometry.computeBoundingBox();
const centerOffset = -0.5 * (textMesh.geometry.boundingBox.max.x - textMesh.geometry.boundingBox.min.x);
textMesh.position.x += centerOffset;
textMesh.lookAt(camera.position);
}

// Update timer with seconds:milliseconds format and check time limit
if (startTime !== null && timerFont) {
elapsedTime = Date.now() - startTime;

const minutes = Math.floor(elapsedTime / 60000);
const seconds = Math.floor((elapsedTime % 60000) / 1000);
const milliseconds = Math.floor(elapsedTime % 1000);
const timerText = `${minutes}:${seconds.toString().padStart(2, '0')}:${milliseconds.toString().padStart(3, '0')}`;

// Update timer text
if (timerMesh && timerMesh.geometry) {
timerMesh.geometry.dispose();
timerMesh.geometry = new THREE.TextGeometry(timerText, {
font: timerFont,
size: 0.02,
height: 0.005,
});
timerMesh.geometry.computeBoundingBox();
const timerCenterOffset = -0.5 * (timerMesh.geometry.boundingBox.max.x - timerMesh.geometry.boundingBox.min.x);
timerMesh.position.set(ring.position.x + timerCenterOffset, ring.position.y + 0.1, ring.position.z);
timerMesh.lookAt(camera.position);
}
}

// Ensure timer text stays attached to the ring and faces the player
if (timerMesh) {
timerMesh.position.set(ring.position.x, ring.position.y + 0.15, ring.position.z);
const timerCenterOffset = -0.5 * (timerMesh.geometry.boundingBox.max.x - timerMesh.geometry.boundingBox.min.x);
timerMesh.position.x += timerCenterOffset;
timerMesh.lookAt(camera.position);
}

// Check for wire collision and update wire color
updateWireColor();

if (confettiStartTime !== null) {
  const elapsed = Date.now() - confettiStartTime;
  
  if (elapsed < 10000) { // 10 seconds of confetti
    for (let i = 0; i < confettiParticles.length; i++) {
      const confetti = confettiParticles[i];
      
      // Add gravity and update position
      confetti.userData.velocity.y -= 0.0003;
      confetti.position.add(confetti.userData.velocity);
      
      // Update rotation
      confetti.rotation.x += confetti.userData.rotationSpeed.x;
      confetti.rotation.y += confetti.userData.rotationSpeed.y;
      confetti.rotation.z += confetti.userData.rotationSpeed.z;
      
      // Add fluttering effect
      confetti.userData.velocity.x += Math.sin(elapsed * 0.01 + confetti.userData.flutter) * 0.0001;
      confetti.userData.velocity.z += Math.cos(elapsed * 0.01 + confetti.userData.flutter) * 0.0001;
    }
  } else {
    // Clean up confetti
    for (let i = 0; i < confettiParticles.length; i++) {
      scene.remove(confettiParticles[i]);
      confettiParticles[i].material.dispose();
    }
    confettiParticles = [];
    confettiStartTime = null;
  }
}

if (isExploding) {
    const explosionElapsed = Date.now() - explosionStartTime;
    const explosionDuration = 2000; // 2 seconds
    
    if (explosionElapsed < explosionDuration) {
      // Update fragment positions and rotations
      for (let i = 0; i < explosionFragments.length; i++) {
        const fragment = explosionFragments[i];
        fragment.position.add(fragment.userData.velocity);
        fragment.rotation.x += fragment.userData.rotationSpeed.x;
        fragment.rotation.y += fragment.userData.rotationSpeed.y;
        fragment.rotation.z += fragment.userData.rotationSpeed.z;
        
        // Add gravity effect
        fragment.userData.velocity.y -= 0.0005;
      }
    } else {
      // Clean up explosion
      for (let i = 0; i < explosionFragments.length; i++) {
        const fragment = explosionFragments[i];
        scene.remove(fragment);
        if (fragment.geometry) fragment.geometry.dispose();
        if (fragment.material) fragment.material.dispose();
      }
      
      // Reset
      explosionFragments = [];
      isExploding = false;
      
      // Show and reset ring
      ring.visible = true;
      ring.position.copy(ringStartPosition);
      ring.rotation.set(0, Math.PI / 2, 0);

        // Reset timer display to 0:00:000
    if (timerMesh && timerFont) {
      timerMesh.geometry.dispose();
      timerMesh.geometry = new THREE.TextGeometry('0:00:000', {
        font: timerFont,
        size: 0.02,
        height: 0.005,
      });
      timerMesh.geometry.computeBoundingBox();
      const timerCenterOffset = -0.5 * (timerMesh.geometry.boundingBox.max.x - timerMesh.geometry.boundingBox.min.x);
      timerMesh.position.set(ring.position.x + timerCenterOffset, ring.position.y + 0.1, ring.position.z);
      timerMesh.lookAt(camera.position);
    
    }
  }
  }
  
renderer.render(scene, camera);
}

function updateWireColor() {
const ringBox = new THREE.Box3().setFromObject(ring);
const colors = wire.geometry.attributes.color.array;

// Calculate a dynamic pointBox size based on the ring's scale
const ringScale = ring.scale.x; // Assuming uniform scale
const pointBoxSize = 0.01 * ringScale; // Adjust the multiplier as needed

for (let i = 0; i < wirePoints.length; i++) {
const point = wirePoints[i];
const pointBox = new THREE.Box3().setFromCenterAndSize(point, new THREE.Vector3(pointBoxSize, pointBoxSize, pointBoxSize));

if (ringBox.intersectsBox(pointBox)) {
// Color this segment blue
colors[i * 3] = 0;     // R
colors[i * 3 + 1] = 0; // G
colors[i * 3 + 2] = 1; // B
}
//No ELSE, so color will remain unless reset
}

wire.geometry.attributes.color.needsUpdate = true;

// Check if the entire wire is blue (victory condition)
let allBlue = true;
for (let i = 0; i < wirePoints.length; i++) {
if (colors[i * 3] !== 0 || colors[i * 3 + 1] !== 0 || colors[i * 3 + 2] !== 1) {
allBlue = false;
break;
}
}
if (allBlue) {
victory();
}
}

function handleCollision() {
explodeRing(); // Add explosion effect
contactSound.play().catch(error => console.log('Sound play error:', error)); // Play contact sound
resetWireColor(); // Reset wire color to pink
triggerHapticFeedback(controller1, 1.0, 100); // haptic feedback
triggerHapticFeedback(controller2, 1.0, 100);  // haptic feedback
grabbed = false; // Override the grab
grabbingController = null; // Clear the grabbing controller

// Reset timer but don't change level
elapsedTime = 0;
startTime = null;
}

function resetWireColor() {
const colors = wire.geometry.attributes.color.array;
for (let i = 0; i < colors.length; i += 3) {
colors[i] = 1; // R
colors[i + 1] = 0; // G
colors[i + 2] = 1; // B
}
wire.geometry.attributes.color.needsUpdate = true;
}

// Helper function to format time as SS:MMM
function formatTime(ms) {
const minutes = Math.floor(ms / 60000);  
const seconds = Math.floor((ms % 60000) / 1000);
const milliseconds = Math.floor(ms % 1000);
return `${minutes}:${seconds.toString().padStart(2, '0')}:${milliseconds.toString().padStart(3, '0')}`;
}

function createConfetti() {
  confettiStartTime = Date.now();
  const confettiGeometry = new THREE.PlaneGeometry(0.015, 0.015);
  const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
  
  // Create 3000 confetti particles
  for (let i = 0; i < 1000; i++) {
    const material = new THREE.MeshBasicMaterial({ 
      color: colors[Math.floor(Math.random() * colors.length)], 
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.9
    });
    
    const confetti = new THREE.Mesh(confettiGeometry, material);
    // Position around center with slight spread
    confetti.position.set(
      ring.position.x + (Math.random() - 0.5) * 2,
      ring.position.y + Math.random() * 1.5,
      ring.position.z + (Math.random() - 0.5) * 2
    );
    
    confetti.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
    
    // Physics properties
    confetti.userData.velocity = new THREE.Vector3(
      (Math.random() - 0.5) * 0.03,
      Math.random() * 0.03,
      (Math.random() - 0.5) * 0.03
    );
    confetti.userData.rotationSpeed = new THREE.Vector3(
      (Math.random() - 0.5) * 0.15,
      (Math.random() - 0.5) * 0.15,
      (Math.random() - 0.5) * 0.15
    );
    confetti.userData.flutter = Math.random() * 10;
    
    scene.add(confetti);
    confettiParticles.push(confetti);
  }
}

function victory() {
if (startTime !== null) {
// Store the completion time for this level
const levelTime = Date.now() - startTime;
levelTimes[currentLevel - 1] = levelTime;

startTime = null;

// Play victory sounds
victorySound.play().catch(error => console.log('Sound play error:', error));
applauseSound.play().catch(error => console.log('Sound play error:', error));

triggerHapticFeedback(controller1, 0.5, 500); // haptic feedback
triggerHapticFeedback(controller2, 0.5, 500);  // haptic feedback

// Flash the wire white and blue
flashWire(3, false);

console.log(`Level ${currentLevel} completed in ${levelTime}ms`);

// Advance to the next level - CHANGED to support four levels
if (currentLevel < 5) {  // Updated to go to level 5
  ring.visible = false;
  transitionImmunity = true;
  setTimeout(() => {
currentLevel++;
// Update the level text
if (textMesh && font) {
textMesh.geometry.dispose();
textMesh.geometry = new THREE.TextGeometry(`LEVEL ${currentLevel}/5`, { font: font, size: 0.02, height: 0.005 });
textMesh.geometry.computeBoundingBox();
}

// create the new wire
wire = createWire(currentLevel);

// Reset the ring position and create the new wire
ring.position.copy(ringStartPosition);
ring.rotation.set(0, Math.PI / 2, 0);

 // Keep ring invisible until we're sure it's safe
 setTimeout(() => {
      ring.visible = true;
      transitionImmunity = false; // Disable immunity after ring is safely positioned
    }, 100); // Short delay before showing ring

// Reset timer for next level
elapsedTime = 0;
grabbed = false;
grabbingController = null;

// Reset the timer display to 0:00:000
if (timerMesh && timerFont) {
timerMesh.geometry.dispose();
timerMesh.geometry = new THREE.TextGeometry('0:00:000', {
font: timerFont,
size: 0.02,
height: 0.005,
});
timerMesh.geometry.computeBoundingBox();
const timerCenterOffset = -0.5 * (timerMesh.geometry.boundingBox.max.x - timerMesh.geometry.boundingBox.min.x);
timerMesh.position.set(ring.position.x + timerCenterOffset, ring.position.y + 0.1, ring.position.z);
}
}, 2000); // Wait 2 seconds before starting next level
} else {
// Game complete! Show summary of times
const totalTime = levelTimes.reduce((total, time) => total + time, 0);

// Hide the ring and wire when game is complete
ring.visible = false;
wire.visible = false;

// Play grand finale sounds
longHornsSound.play().catch(error => console.log('Sound play error:', error));
longApplauseSound.play().catch(error => console.log('Sound play error:', error));

 // special game completion haptic pattern - alternating pulses
 const celebratePulses = () => {
    let count = 0;
    const interval = setInterval(() => {
      triggerHapticFeedback(controller1, 0.7, 100);
      triggerHapticFeedback(controller2, 0.7, 100);
      count++;
      if (count >= 5) clearInterval(interval);
    }, 300);
  };
  celebratePulses();

createConfetti(); // Add confetti effect

// Flash the wire more dramatically
flashWire(6, true);

if (textMesh && font) {
textMesh.geometry.dispose();

// Create individual text meshes for each line of the summary
// Game complete text
const gameCompleteGeometry = new THREE.TextGeometry('GAME COMPLETE!', { 
font: font, 
size: 0.03, 
height: 0.005 
});
const gameCompleteMesh = new THREE.Mesh(
gameCompleteGeometry, 
new THREE.MeshStandardMaterial({ color: 0xffff00 })
);
gameCompleteGeometry.computeBoundingBox();
const completeOffset = -0.5 * (gameCompleteGeometry.boundingBox.max.x - gameCompleteGeometry.boundingBox.min.x);
gameCompleteMesh.position.set(completeOffset, 1.5, -0.75);
scene.add(gameCompleteMesh);

// Level 1 time 
const level1Text = `Level 1: ${formatTime(levelTimes[0] || 0)}`;
const level1Geometry = new THREE.TextGeometry(level1Text, { font: font, size: 0.02, height: 0.005 });
const level1Mesh = new THREE.Mesh(level1Geometry, new THREE.MeshStandardMaterial({ color: 0xffffff }));
level1Geometry.computeBoundingBox();
const level1Offset = -0.5 * (level1Geometry.boundingBox.max.x - level1Geometry.boundingBox.min.x);
level1Mesh.position.set(level1Offset, 1.45, -0.75);
scene.add(level1Mesh);

// Level 2 time
const level2Text = `Level 2: ${formatTime(levelTimes[1] || 0)}`;
const level2Geometry = new THREE.TextGeometry(level2Text, { font: font, size: 0.02, height: 0.005 });
const level2Mesh = new THREE.Mesh(level2Geometry, new THREE.MeshStandardMaterial({ color: 0xffffff }));
level2Geometry.computeBoundingBox();
const level2Offset = -0.5 * (level2Geometry.boundingBox.max.x - level2Geometry.boundingBox.min.x);
level2Mesh.position.set(level2Offset, 1.4, -0.75);
scene.add(level2Mesh);

// Level 3 time
const level3Text = `Level 3: ${formatTime(levelTimes[2] || 0)}`;
const level3Geometry = new THREE.TextGeometry(level3Text, { font: font, size: 0.02, height: 0.005 });
const level3Mesh = new THREE.Mesh(level3Geometry, new THREE.MeshStandardMaterial({ color: 0xffffff }));
level3Geometry.computeBoundingBox();
const level3Offset = -0.5 * (level3Geometry.boundingBox.max.x - level3Geometry.boundingBox.min.x);
level3Mesh.position.set(level3Offset, 1.35, -0.75);
scene.add(level3Mesh);

// Level 4 time
const level4Text = `Level 4: ${formatTime(levelTimes[3] || 0)}`;
const level4Geometry = new THREE.TextGeometry(level4Text, { font: font, size: 0.02, height: 0.005 });
const level4Mesh = new THREE.Mesh(level4Geometry, new THREE.MeshStandardMaterial({ color: 0xffffff }));
level4Geometry.computeBoundingBox();
const level4Offset = -0.5 * (level4Geometry.boundingBox.max.x - level4Geometry.boundingBox.min.x);
level4Mesh.position.set(level4Offset, 1.3, -0.75);
scene.add(level4Mesh);

// Level 5 time
const level5Text = `Level 5: ${formatTime(levelTimes[4] || 0)}`;
const level5Geometry = new THREE.TextGeometry(level5Text, { font: font, size: 0.02, height: 0.005 });
const level5Mesh = new THREE.Mesh(level5Geometry, new THREE.MeshStandardMaterial({ color: 0xffffff }));
level5Geometry.computeBoundingBox();
const level5Offset = -0.5 * (level5Geometry.boundingBox.max.x - level5Geometry.boundingBox.min.x);
level5Mesh.position.set(level5Offset, 1.25, -0.75);
scene.add(level5Mesh);

// Total time 
const totalText = `Total: ${formatTime(totalTime)}`;
const totalGeometry = new THREE.TextGeometry(totalText, { font: font, size: 0.025, height: 0.005 });
const totalMesh = new THREE.Mesh(totalGeometry, new THREE.MeshStandardMaterial({ color: 0x00ffff }));
totalGeometry.computeBoundingBox();
const totalOffset = -0.5 * (totalGeometry.boundingBox.max.x - totalGeometry.boundingBox.min.x);
totalMesh.position.set(totalOffset, 1.2, -0.75);
scene.add(totalMesh);

// Add Restart button
const restartGeometry = new THREE.TextGeometry('RESTART', { font: font, size: 0.025, height: 0.005 });
const restartMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 0.5 });
const restartMesh = new THREE.Mesh(restartGeometry, restartMaterial);
restartGeometry.computeBoundingBox();
const restartWidth = restartGeometry.boundingBox.max.x - restartGeometry.boundingBox.min.x;
const restartOffset = -0.5 * restartWidth;
restartMesh.position.set(restartOffset - 0.1, 1.0, -0.75);
scene.add(restartMesh);

// Create invisible box for restart button interaction
const restartBox = new THREE.Mesh(
  new THREE.BoxGeometry(restartWidth + 0.05, 0.05, 0.01),
  new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 })
);
restartBox.position.copy(restartMesh.position);
restartBox.position.y += 0.01; // Slight offset for better interaction
scene.add(restartBox);
restartBox.userData.isButton = true;
restartBox.userData.buttonType = 'restart';

// Add Quit button
const quitGeometry = new THREE.TextGeometry('QUIT', { font: font, size: 0.025, height: 0.005 });
const quitMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.5 });
const quitMesh = new THREE.Mesh(quitGeometry, quitMaterial);
quitGeometry.computeBoundingBox();
const quitWidth = quitGeometry.boundingBox.max.x - quitGeometry.boundingBox.min.x;
const quitOffset = -0.5 * quitWidth;
quitMesh.position.set(quitOffset + 0.15, 1.0, -0.75);
scene.add(quitMesh);

// Create invisible box for quit button interaction
const quitBox = new THREE.Mesh(
  new THREE.BoxGeometry(quitWidth + 0.05, 0.05, 0.01),
  new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 })
);
quitBox.position.copy(quitMesh.position);
quitBox.position.y += 0.01; // Slight offset for better interaction
scene.add(quitBox);
quitBox.userData.isButton = true;
quitBox.userData.buttonType = 'quit';

// Store references to these meshes to remove them if needed
gameCompletionMeshes = [
  gameCompleteMesh, level1Mesh, level2Mesh, level3Mesh, level4Mesh, level5Mesh, 
  totalMesh, restartMesh, quitMesh, restartBox, quitBox
];

// Remove the original text mesh since we're replacing it with multiple meshes
scene.remove(textMesh);

// Hide the timer mesh
if (timerMesh) timerMesh.visible = false;
}
}
}
}
</script>
</body>
</html>
